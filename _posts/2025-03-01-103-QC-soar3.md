---
title: 2차시 3:QC - Math and Theory3
layout: single
classes: wide
categories:
  - Math 
  - Theory
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

- 출처: [www.quantumsoar.com](https://www.quantumsoar.com)

## 3.01 초고밀도 코딩
### 1. 초고밀도 코딩 1
이 과정의 마지막 섹션에 오신 것을 환영합니다. 마지막 섹션까지 오신 것을 축하드립니다! 지금까지 배운 모든 지식은 이 섹션을 위해 만들어졌습니다. 이 섹션에서는 널리 사용되는 양자 알고리즘을 기초부터 연구하여 양자 컴퓨터의 진정한 힘을 발견해 보겠습니다!

첫 번째 양자 프로토콜인 초고밀도 코딩부터 시작해 보겠습니다. 이 양자 프로토콜은 얽힘 현상을 이용하여 단 하나의 큐비트만 전송하여 2비트의 고전적 정보(00, 01, 10 또는 11)를 전송할 수 있습니다. 이는 고전적 컴퓨터보다 속도가 훨씬 빠릅니다. 고전적 컴퓨터에서는 2비트의 정보를 전송하려면 2비트를 전송해야 하지만, 양자 컴퓨터에서는 단 하나의 큐비트만 전송하면 되기 때문입니다!

앨리스와 밥이라는 두 사람이 있고, 앨리스가 밥에게 2비트의 정보를 보내려고 한다고 가정해 보겠습니다. 먼저 앨리스와 밥은 다음 상태에서 최대 2개의 큐비트를 얽히게 합니다.

$\|\psi\rangle = \frac{1}{\sqrt{2}}(\|00\rangle + \|11\rangle)$

앨리스는 첫 번째 큐비트를 가져가고, 밥은 다른 큐비트를 가져갑니다. 이제 앨리스가 밥에게 2비트의 정보를 전송할 때마다, 전송하려는 2비트에 따라 큐비트에 몇 가지 연산을 적용합니다.

앨리스는 00 을 전송하려고 합니다. \
아무것도 하지 않으므로 두 큐비트 모두 $\|\psi_{1}\rangle = \frac{1}{\sqrt{2}}(\|00\rangle + \|11\rangle)$ 상태에 있습니다.

앨리스는 01 을 전송하려고 합니다. \
자신의 큐비트에 X를 적용하므로 두 큐비트 모두 $\|\psi_{1}\rangle = \frac{1}{\sqrt{2}}(\|10\rangle + \|01\rangle)$ 상태에 있습니다.

앨리스는 10 을 전송하려고 합니다. \
자신의 큐비트에 Z를 적용하므로 두 큐비트 모두 $\|\psi_{1}\rangle = \frac{1}{\sqrt{2}}(\|00\rangle - \|11\rangle)$ 상태에 있습니다.

앨리스는 11 을 전송하려고 합니다. \
자신의 큐비트에 X를 적용한 후 Z를 적용하므로 두 큐비트 모두 $\|\psi_{1}\rangle = \frac{1}{\sqrt{2}}(\|10\rangle - \|01\rangle)$ 상태에 있습니다.

이제 앨리스는 자신의 큐비트를 밥에게 전송하므로 밥은 두 큐비트 모두 위의 네 가지 상태 중 하나에 있습니다.

### 2. 초고밀도 코딩 2
이제 밥은 두 큐비트를 모두 가지게 되었으므로, 첫 번째 큐비트를 제어 큐비트로, 두 번째 큐비트를 대상으로 하는 CNOT 게이트를 적용합니다. 그런 다음 첫 번째 큐비트에 아다마르 게이트를 적용합니다.

$\|\psi_{1}\rangle = \frac{1}{\sqrt{2}}(\|00\rangle + \|11\rangle) \xrightarrow{CNOT}\frac{1}{\sqrt{2}}(\|00\rangle + \|10\rangle) = \|+\rangle\|0\rangle \xrightarrow{H} \|00\rangle$

$\|\psi_{1}\rangle = \frac{1}{\sqrt{2}}(\|10\rangle + \|01\rangle) \xrightarrow{CNOT}\frac{1}{\sqrt{2}}(\|11\rangle + \|01\rangle) = \|+\rangle\|1\rangle \xrightarrow{H} \|01\rangle$

$\|\psi_{1}\rangle = \frac{1}{\sqrt{2}}(\|00\rangle - \|11\rangle) \xrightarrow{CNOT}\frac{1}{\sqrt{2}}(\|00\rangle - \|10\rangle) = \|-\rangle\|0\rangle \xrightarrow{H} \|10\rangle$

$\|\psi_{1}\rangle = \frac{1}{\sqrt{2}}(\|10\rangle - \|01\rangle) \xrightarrow{CNOT}\frac{1}{\sqrt{2}}(\|10\rangle - \|01\rangle) = \|-\rangle\|1\rangle \xrightarrow{H} \|11\rangle$

보시다시피 밥이 게이트를 적용한 후에는 큐비트를 측정하기만 하면 되고, 앨리스가 전송하려고 했던 두 비트만 남게 됩니다.

양자 컴퓨터에서 두 비트의 고전적 정보를 전송하려면 큐비트 하나만 보내면 됩니다. 물론 두 개의 얽힌 큐비트가 필요하지만, 큐비트가 얽히고 각자 한 개씩 가져가면 한 개의 큐비트를 전송하여 두 비트의 고전적 정보를 전송할 수 있습니다.

### 3. 이 알고리즘이 작동하는 이유는 무엇일까요?
이 알고리즘이 작동하는 이유는 앨리스가 큐비트에 게이트를 적용할 때 큐비트가 남게 될 수 있는 상태의 조합이 벨 상태이기 때문입니다.

앨리스는 00 을 전송하려고 합니다.  $\|\psi_{1}\rangle = \frac{1}{\sqrt{2}}(\|00\rangle + \|11\rangle) = \|\Phi^{+}\rangle$

앨리스는 01 을 전송하려고 합니다. $\|\psi_{1}\rangle = \frac{1}{\sqrt{2}}(\|10\rangle + \|01\rangle) = \|\Psi^{+}\rangle$

앨리스는 10 을 전송하려고 합니다. $\|\psi_{1}\rangle = \frac{1}{\sqrt{2}}(\|00\rangle - \|11\rangle) = \|\Phi^{-}\rangle$

앨리스는 11 을 전송하려고 합니다. $\|\psi_{1}\rangle = \frac{1}{\sqrt{2}}(\|10\rangle - \|01\rangle) = \|\Psi^{-}\rangle$


이 네 가지 상태는 2개 큐비트 상태 공간에 대한 정규직교 기저를 형성하며, 이를 벨 기저(Bell Basis)라고 합니다. 따라서 게이트를 조작하여 벨 기저를 2개 큐비트 시스템의 표준 기저로 변환할 수 있습니다 $\\{∣00⟩,∣01⟩,∣10⟩,∣11⟩\\}$. 
CNOT와 H는 벨 기저 상태를 표준 기저로 변환합니다. 중요한 점은 큐비트 중 하나에만 게이트를 적용하여 상태 $\frac{1}{\sqrt{2}}(\|00\rangle + \|11\rangle)$ 에서 벨 기저의 모든 상태를 생성할 수 있다는 것입니다.

초고밀도 코딩은 양자 통신 프로토콜 중 하나로, 정보 전송의 효율성을 극대화하는 것을 목적:통신 용량을 두 배로 늘리는 프로토콜

### 4. 연습문제
문제1. 초고밀도 코딩에서 앨리스와 밥이 공유하는 초기 얽힘 상태는 무엇입니까?
> 답: 초기상태 $\|\psi_{0}\rangle = \frac{1}{\sqrt{2}}(\|00\rangle + \|11\rangle)$

문제2. 앨리스가 고전 비트 01을 전송하고 싶다면, 그녀는 큐비트에 어떤 게이트를 적용해야 할까요? 그 결과 상태는 무엇일까요?
> 답: 앨리스는 자신의 큐비트에 X 게이트를 적용하여 다음 상태를 생성합니다 \
$\|\psi_{1}\rangle = \frac{1}{\sqrt{2}}(\|10\rangle + \|01\rangle)$

문제3. 밥이 위의 상태에 CNOT와 Hadamard를 적용한 후, 결과 상태는 무엇입니까? 
> 답: 1단계: CNOT(첫 번째 큐비트 제어, 두 번째 큐비트 대상) 적용: \
$\|\psi_{2}\rangle = \frac{1}{\sqrt{2}}(\|11\rangle + \|01\rangle)$
>
2단계: 첫 번째 큐비트에 Hadamard 적용: \
$\|\psi_{3}\rangle = \frac{1}{\sqrt{2}}(\|-\rangle\|1\rangle + \|+\rangle\|1\rangle) = \|01\rangle$ \
이 상태를 측정하면 Bob은 Alice가 전송하려고 했던 원래 2비트를 얻게 됩니다.

## 3.02 고전적 연산 전제조건
### 1. 고전 컴퓨터 연산
양자 컴퓨터에서 상태에 함수를 적용하는 방법을 알아보기 전에, 고전 컴퓨터가 비트를 조작하는 방식에 대한 기본 정보를 알아야 합니다.

고전 컴퓨터에는 NOT, AND, OR, XOR(배타적 논리합)의 네 가지 기본 연산이 있습니다. 각 연산의 진리표는 다음과 같습니다.

<div style="display: flex; justify-content: center; gap: 20px; flex-wrap: nowrap; overflow-x: auto;">
  <figure style="text-align: leading;">
    <figcaption style="font-size: 16px; font-weight: bold;"> $AND$</figcaption>
    <img src="https://www.quantumsoar.com/_app/immutable/assets/and.ZvCq4C8d.png" width="100"><br/>    
  </figure>
  
  <figure style="text-align: leading;">
    <figcaption style="font-size: 16px; font-weight: bold;"> $OR$</figcaption>
    <img src="https://www.quantumsoar.com/_app/immutable/assets/or.Bw2kv7Fi.png" width="100"><br/>
    
  </figure>
  <figure style="text-align: leading;">
    <figcaption style="font-size: 16px; font-weight: bold;"> $XOR(exclusive-or)$</figcaption>
    <img src="https://www.quantumsoar.com/_app/immutable/assets/xor.DbKFm_fQ.png" width="100"><br/>
  
  </figure>
  <figure style="text-align: leading;">
    <figcaption style="font-size: 16px; font-weight: bold;"> $NOT$</figcaption>
    <img src="https://www.quantumsoar.com/_app/immutable/assets/not.C3Aoi8AD.png" width="100"><br/>
  
  </figure>
</div>

한 가지 주의해야 할 점은 XOR 연산이 0과 XOR 연산을 수행하면 항등원으로 작용할 수 있다는 것입니다:
$0 \oplus 0 = 0$ and $0 \oplus 1 = 1$ ,여기서 $\oplus$는 XOR 연산입니다. 따라서 \
$x\in \\{0,1\\}$ 경우, $0 \oplus x = x$

### 2. 가역 고전 게이트
고전 컴퓨터에 함수를 적용하면, 함수는 입력을 받아 결과를 출력합니다.

<img src="https://www.quantumsoar.com/_app/immutable/assets/classical_function.MHDE4XiP.png" width="400">

반면 양자 컴퓨터에서는 큐비트 상태에 적용할 수 있는 게이트에 몇 가지 제한이 있기 때문에 그렇게 간단하지 않습니다. 모든 양자 연산(측정 제외)은 유니터리 연산이어야 하므로 가역적이어야 한다는 점을 기억하세요. 즉, 큐비트에 함수를 적용하려면 해당 함수가 가역적이어야 합니다.

> x를 찾을 수 있는 f(x)가 있다면 함수 f는 가역적이다 $\Leftrightarrow$ 각 x에 대해 고유한 f(x)가 존재합니다.

이제 가역 함수를 만드는 방법을 살펴보자:

<figure style="text-align: center; justify-content: center">
    <figcaption style="font-size: 20px; font-weight: bold;"> $\text{Reversible f}$</figcaption>
    <img src="https://www.quantumsoar.com/_app/immutable/assets/classical_reversible_function.CIwbLxUh.png" width="400"><br/>
</figure>

보시다시피, 부울 함수에서 가역 함수를 만들려면 출력 $f(x)$를 반환하는 대신 다른 비트 $c$를 입력합니다. 입력 $x$와 $c\oplus f(x)$를 반환합니다. 여기서 $\oplus$는 XOR 연산입니다. 이제 'f(x)를 c와 XOR하면 출력 f(x)는 어떻게 구할까?'라고 생각하실 수도 있습니다. 

$c=0$ 으로 입력하면 $c\oplus f(x) = 0 \oplus f(x) = f(x)$, 왜냐하면($x\in \\{0,1\\}$ 경우, $0 \oplus x = x$)

$c=0$ 으로 입력하면: 

<img src="https://www.quantumsoar.com/_app/immutable/assets/classical_reversible_functionz.DMiayofa.png" width="400">

이 그림은 부울 함수 f(x)의 가역 형태입니다. 이제 예를 살펴보겠습니다.

### 3. 가역 고전 게이트
다음은 AND 게이트와 가역 AND 연산의 예입니다. AND 연산의 진리표를 보면, 출력이 f(A, B)=0이면 x의 값을 결정할 수 없습니다(x는 00, 01 또는 10일 수 있기 때문입니다). 이제 아래의 가역 AND 연산을 살펴보겠습니다. 진리표에서 볼 수 있듯이 각 출력은 각 입력에 대해 고유하므로 연산이 가역적입니다.

<img src="https://www.quantumsoar.com/_app/immutable/assets/reversible_and.C6NJ_EOT.png" width="400">

<img src="https://www.quantumsoar.com/_app/immutable/assets/reversible_and_table.B2d3Cf7x.png" width="400">

### 4. 연습문제
문제1. 0과 1을 XOR하면 고전적인 XOR 연산의 출력은 무엇입니까?
> 답: 출력은 $0 \oplus 1 = 1$ 입니다. XOR은 입력 중 하나가 0일 때 항등항으로 작용합니다.

문제2. 함수가 가역적이라는 것은 무엇을 의미합니까?
> 답: 모든 출력이 정확히 하나의 입력에 대응할 때 함수는 가역적입니다. 이는 주어진 $f(x)$에 대해 $x$를 유일하게 결정할 수 있음을 보장합니다.

문제3. 고전적인 AND 연산은 가역적인가요? 그 이유는 무엇인가요?
> 답: 아니요, AND 연산은 가역적이지 않습니다. $f(A,B)=0$ 이면 여러 입력이 동일한 출력을 내므로 입력이 00, 01 또는 10인지 판별할 수 없습니다.

문제4. 추가 비트를 사용하여 고전적인 부울 함수 f(x)를 가역 함수로 만들 수 있을까요?
> 답: 추가 비트 $c$를 도입하고 $x$와 $c \oplus f(x)$ 를 반환합니다. $c=0$ 으로 설정하면 연산을 가역적으로 유지하면서 $f(x)$ 를 직접 복구할 수 있습니다

## 3.03 양자 컴퓨터의 함수
### 1. 양자 컴퓨터에 함수 적용하기 1
이제 양자 컴퓨터에 함수를 적용하는 방법을 살펴보겠습니다. 이전 수업에서 양자 연산은 유니터리 연산이어야 하므로 가역적이어야 한다고 설명했습니다. 이를 위해 큐비트 상태에 함수를 적용할 때 가역 고전 게이트와 동일한 구조를 사용합니다. 다이어그램은 다음과 같습니다.

<img src="https://www.quantumsoar.com/_app/immutable/assets/quantum_oracle.FHQLICjY.png" widht="400">

$U_{f}\|x\rangle\|y\rangle = \|x\rangle\|y \oplus f(x)\rangle$

$U_{f}$는 함수 $f$를 적용하고 위에서 본 것과 같이 상태를 변환하는 양자 게이트입니다.

> 다중 큐비트 상태 $\|0\rangle\|1\rangle$에 가역 함수 $U_{f}$를 적용합니다. 여기서 $f(0)=1, f(1)=1$ 입니다.
> 
> 답: $U_f\|0\rangle \|1\rangle = \|0\rangle \|1 \oplus f(0)\rangle = \|0\rangle \|1 \oplus 1\rangle = \|0\rangle \|0\rangle$

### 2. 양자 컴퓨터에 함수 적용하기 2
비트를 $0$과 $XOR$ 연산하면 같은 비트가 남습니다. $0 \oplus 0 = 1$이고 $0 \oplus 0 = 1$입니다. 따라서 $x \oplus x = x$이고, 여기서 $x \in \\{0,1\\}$입니다. 이 사실을 이용하여 $f(x)$의 값을 구할 수 있습니다.

$\|y\rangle = \|0\rangle$ 으로 설정하면 다음과 같습니다.

<img src="https://www.quantumsoar.com/_app/immutable/assets/quantum_oracle_standard.BXwLTZR2.png" width="400">

$U_{f}\|x\rangle\|0\rangle = \|x\rangle\|0 \oplus f(x)\rangle = \|x\rangle\|f(x)\rangle$

이것이 우리가 양자 컴퓨터에서 함수를 가역적으로 적용하는 방식입니다.

> 다중 큐비트 상태 $\|0\rangle\|0\rangle$에 가역 함수 $U_{f}$를 적용합니다. 여기서 $f(0)=1, f(1)=1$ 입니다.
>
> 답: $U_f\|0\rangle \|0\rangle = \|0\rangle \|0 \oplus f(0)\rangle = \|0\rangle \|0 \oplus 1\rangle = \|0\rangle \|1\rangle$

### 3.위상 오라클
양자 컴퓨팅에서는 중첩을 구현할 수 있으므로 다양한 방식으로 함수를 쿼리할 수 있습니다. $\|y\rangle = \|-\rangle$ 로 설정하면 어떻게 되는지 살펴보겠습니다($1 \oplus f(x) = NOT f(x) = f(x)^{-}$)

$U_f \|x\rangle \|-\rangle = U_f \frac{1}{\sqrt{2}} (\|x\rangle \|0\rangle - \|x\rangle \|1\rangle)$ \
$= \frac{1}{\sqrt{2}} (U_f \|x\rangle \|0\rangle - U_f \|x\rangle \|1\rangle)$ \
$= \frac{1}{\sqrt{2}} (\|x\rangle \|0 \oplus f(x)\rangle - U_f\|x\rangle \|1 \oplus f(x)\rangle)$ \
$= \frac{1}{\sqrt{2}} (\|x\rangle \|f(x)\rangle - \|x\rangle \|\overline{f(x)}\rangle)$

여기서 $\overline{f(x)}$ 는 $f(x)$ 의 NOT 연산입니다. 이제 2가지 시나리오를 살펴보자

$f(x)=0$ 인 경우: \
$\frac{1}{\sqrt{2}} (\|x\rangle \|f(x)\rangle - \|x\rangle \|\overline{f(x)}\rangle) = \frac{1}{\sqrt{2}} (\|x\rangle \|0\rangle - \|x\rangle \|1\rangle) = \|x\rangle\|-\rangle$

$f(x)=1$ 인 경우: \
$\frac{1}{\sqrt{2}} (\|x\rangle \|f(x)\rangle - \|x\rangle \|\overline{f(x)}\rangle) = \frac{1}{\sqrt{2}} (\|x\rangle \|1\rangle - \|x\rangle \|0\rangle) = -\|x\rangle\|-\rangle$

두가지 경우를 일반화하면: \
$\frac{1}{\sqrt{2}} (\|x\rangle \|f(x)\rangle - \|x\rangle \|\overline{f(x)}\rangle) =(-1)^{f(x)}\|x\rangle\|-\rangle$

이를 통해 상태 $\|-\rangle$ 에 출력 큐비트가 있는 함수를 적용하면 다음 상태를 얻을 수 있음을 알 수 있습니다. \


<figure style="text-align: center; justify-content: center">
    <figcaption style="font-size: 20px; font-weight: bold;"> $U_f |x\rangle |-\rangle = (-1)^{f(x)}|x\rangle|-\rangle$</figcaption>
    <img src="https://www.quantumsoar.com/_app/immutable/assets/quantum_phase_oracle.B8tCP_iw.png" width="400"><br/>
</figure>


이와 같은 함수를 쿼리(고전컴퓨팅에서 호출)할 때, 출력 $f(x)$ 는 출력 큐비트에 인코딩되는 것이 아니라 위상으로 인코딩됩니다. 이를 위상 오라클(Phase Oracle)이라고 하며, 많은 양자 알고리즘에서 사용됩니다. 다음 강의에서는 이 위상 오라클 기법을 사용하는 도이치 알고리즘(Deutch's Algorithm)을 살펴보겠습니다!

### 4. 연습문제
문제1. 양자 게이트 $U_{f}$를 사용하여 함수 $f(x)$ 를 적용하는 일반 공식은 무엇입니까?
> 답: 공식은 $U_{f}\|x\rangle\|y\rangle = \|x\rangle\|y \oplus f(x)\rangle$ 입니다. 이는 입력 큐비트를 보존하고 함수 출력을 두 번째 큐비트에 저장함으로써 가역성을 보장합니다.

문제2. $y=0$ 으로 설정함으로써, $U_f\|x\rangle\|0\rangle$ 로 얻을 수 있는 상태는?
> 답: 결과 상태는 $\|x\rangle\|f(x)\rangle$ 입니다. 왜냐하면 $0 \oplus f(x) = f(x)$ 이기 때문입니다. 이를 통해 연산의 가역성을 유지하면서 $f(x)$ 를 추출할 수 있습니다.

문제3. $\|y\rangle = \|-\rangle = \frac{1}{\sqrt{2}}(\|0\rangle - \|1\rangle)$ 로 설정하고, $U_f$를 적용하면 어떻게 되나요?
> 답: $U_{f}\|x\rangle\|-\rangle = (-1)^{f(x)}\|x\rangle\|- \rangle$ \
함수 값은 출력 큐비트 대신 상대 위상에 인코딩됩니다. 함수의 정보가 "되돌아와서" 입력 레지스터의 위상에 저장됨(상태 뒤집기-위상 킥백)

문제4. $\forall{x}, f(x)=1$ 일 때, $\|x\rangle\|-\rangle$ 결과 상태를 계산하시오.
> 답: $U_{f}\|x\rangle\|-\rangle = (-1)^{1}\|x\rangle\|- \rangle = -\|x\rangle\|- \rangle$ 

문제5. $f(x) = x$ 일 때, $U_f\|1\rangle\|0\rangle$ 의 결과 상태를 계산하시오.
> 답: $U_{f}\|1\rangle\|0\rangle = \|1\rangle\|0 \oplus 1 \rangle = \|11 \rangle$ 


## 3.04 도이치 알고리즘
### 1. 문제와 고전적 해법
이제 첫 번째 양자 알고리즘인 도이치 알고리즘을 살펴보겠습니다! 알고리즘을 살펴보기 전에 이 알고리즘이 어떤 문제를 해결하는지, 그리고 고전적 컴퓨터가 어떻게 문제를 해결하는지 살펴보겠습니다. 단일 비트를 입력으로 받아 단일 비트 f를 출력하는 함수 f가 있다고 가정해 보겠습니다. $f:\\{0,1\\}→\\{0,1\\}$. 함수 $f$가 상수 함수인지 균형 함수인지 알아내고자 합니다.

상수 함수는 항상 동일한 비트를 출력으로 반환합니다. 예를 들어, $f(x)=0$ 으로 정의된 함수는 어떤 비트를 입력하든 항상 0비트를 반환하므로 상수 함수입니다. 아래는 1비트를 입력으로 받는 두 개의 상수 함수입니다. 1비트를 입력으로 받는 함수가 상수이면 $f(0)=f(1)$ 입니다.

<div style="display: flex; justify-content: center; gap: 20px;  max-width:70%">
  <figure style="text-align: leading;">
    <img src="https://www.quantumsoar.com/_app/immutable/assets/constant_function_1.BfuupmuQ.png" width="100"><br/>    
  </figure>
  
  <figure style="text-align: leading;">
    <img src="https://www.quantumsoar.com/_app/immutable/assets/constant_function_2.4nKia_hP.png" width="100"><br/>
  </figure>
</div>

반면, 균형 함수는 입력의 절반에 대해서는 0을 반환하고, 나머지 절반에 대해서는 1을 반환합니다. 1비트를 입력으로 받는 두 가지 균형 함수는 다음과 같습니다.

<div style="display: flex; justify-content: center; gap: 20px;  max-width:70%">
  <figure style="text-align: leading;">
    <img src="https://www.quantumsoar.com/_app/immutable/assets/balanced_function_1.D5HLtvKN.png" width="100"><br/>    
  </figure>
  
  <figure style="text-align: leading;">
    <img src="https://www.quantumsoar.com/_app/immutable/assets/balanced_function_2.Bucmz3AT.png" width="100"><br/>
  </figure>
</div>


위에서 볼 수 있듯이, NOT 함수:  \
$f(0)=1$이고 $f(1)=0$은 하나의 입력($x=0$)에 대해서는 1을 반환하고 다른 입력($x=1$)에 대해서는 0을 반환하므로 균형 함수입니다. 
한 비트를 받는 함수가 상수이면 $f(0) = f(1)$이지만, NOT 함수는 $f(0) \neq f(1)$이므로 상수 함수가 아닙니다.

고전 컴퓨터가 함수가 상수인지 균형 함수인지 알아내려면 함수에 두 번 질의해야 합니다. 한 번은 $f(0)$으로, 그리고 다시 $f(1)$로 $f$가 상수인지 균형 함수인지 확인합니다. $f(0)=f(1)$이면 함수는 상수이고, $f(0)$과 $f(1)$이 같지 않으면 함수가 균형 함수임을 알 수 있습니다. 반면 양자 컴퓨터를 사용하면 함수 $f:\\{0,1\\}→\\{0,1\\}$이 상수인지 균형 함수인지 한 번의 질의만으로 알아낼 수 있습니다!


### 2. 도이치 알고리즘
알고리즘 회로는 다음과 같습니다. 보시다시피 함수 $f$를 가역적으로 적용하는 $U_f$ 게이트가 있습니다. \
$U_f|x\rangle\|y\rangle = \|x\rangle\|y \oplus f(x)\rangle.$ 이 알고리즘을 사용하면 함수에 대한 단일 쿼리를 통해 $f$가 상수인지 균형인지 확인할 수 있습니다.

<img src="https://www.quantumsoar.com/_app/immutable/assets/circuit.CPJWFUCU.png" width="500">


<div>
$$
\begin{align}
|\psi_0\rangle &= |00\rangle  \\
|\psi_1\rangle &= |01\rangle \\
|\psi_2\rangle &= |+-\rangle \\
&= \frac{1}{\sqrt{2}} (|0\rangle + |1\rangle) \otimes |-\rangle \\
&= \frac{1}{\sqrt{2}} (|0\rangle|-\rangle + |1\rangle|-\rangle)
\end{align}
$$
</div>

이제$\|\psi_3\rangle$ 에서, $U_f$ 를 적용하면:

<div>
$$\begin{align*}
|\psi_3\rangle &= U_f \frac{1}{\sqrt{2}} (|0\rangle|-\rangle + |1\rangle|-\rangle) \\
&= \frac{1}{\sqrt{2}} (U_f |0\rangle|-\rangle + U_f |1\rangle|-\rangle)
\end{align*}$$
</div>

이제 $U_f \|0\rangle\|-\rangle$와 $U_f\|1\rangle\|-\rangle$살펴보면, 둘 다 위상 오라클 형식:
$U_f \|x\rangle\|-\rangle = (-1)^{f(x)}\|x\rangle\|-\rangle$:

$\|\psi_3 \rangle = \frac{1}{\sqrt{2}} ((-1)^{f(0)} \|0\rangle\|-\rangle + (-1)^{f(1)} \|1\rangle\|-\rangle)$ \
$\|\psi_3 \rangle = \frac{1}{\sqrt{2}} ((-1)^{f(0)} \|0\rangle + (-1)^{f(1)} \|1\rangle) \otimes \|-\rangle$

이제 서로 다른 두가지 시나리오를 고려해보자: \
$f(0) = f(1)$ 인 경우: 

$\|\psi_3\rangle = \frac{1}{\sqrt{2}} ( \|0\rangle + \|1\rangle ) \otimes \|-\rangle, \quad \text{if } f(0)=f(1)=0$

$\text{or}$

$\|\psi_3\rangle = \frac{1}{\sqrt{2}} ( -\|0\rangle - \|1\rangle ) \otimes \|-\rangle \equiv \frac{1}{\sqrt{2}} ( \|0\rangle + \|1\rangle ) \otimes \|-\rangle, \quad \text{if } f(0)=f(1)=1$

그러므로, $f(0)=f(1)$ 이면 상태는 다음과 같다. \
$\|\psi_3\rangle = \frac{1}{\sqrt{2}} ( \|0\rangle + \|1\rangle ) \otimes \|-\rangle = \|+\rangle\|-\rangle$

$f(0) \neq f(1)$ 인 경우: 

$\|\psi_3\rangle = \frac{1}{\sqrt{2}} ( \|0\rangle - \|1\rangle ) \otimes \|-\rangle, \quad \text{if } f(0)=0, f(1)=1$

$\|\psi_3\rangle = \frac{1}{\sqrt{2}} ( -\|0\rangle + \|1\rangle ) \otimes \|-\rangle \equiv \frac{1}{\sqrt{2}} ( \|0\rangle - \|1\rangle ) \otimes \|-\rangle, \quad \text{if } f(0)=1, f(1)=0$

따라서 $f(0) \neq f(1)$ 이면 상태는:\
$\|\psi_3\rangle = \frac{1}{\sqrt{2}} ( \|0\rangle - \|1\rangle ) \otimes \|-\rangle = \|-\rangle\|-\rangle$

보시다시피, $f(0) = f(1)$ 이면 $\|\psi_3\rangle = \|+\rangle\|-\rangle$ , $f(0) \neq f(1)$ 이면 $\|\psi_3\rangle = \|-\rangle\|-\rangle$. 나머지 알고리즘을 마칠 수 있는지 확인해보세요

이제 첫번째 큐비트에 아다마트 게이트를 적용합니다. \
$f(0) = f(1)$ 이면 $\|\psi_4\rangle = H\|+\rangle\|-\rangle = \|0\rangle\|-\rangle$ , 

$f(0) \neq f(1)$ 이면 $\|\psi_4\rangle = H\|-\rangle\|-\rangle = \|1\rangle\|-\rangle$

이제 첫 번째 큐비트를 측정하기만 하면 됩니다. 보시다시피, $0$을 측정하면 $f(0)=f(1)$임을 알 수 있는데, 이는 함수가 상수임을 의미합니다. 반면 1을 측정하면 $f(1) \neq f(1)$임을 알 수 있으므로 함수가 균형 상태임을 알 수 있습니다. 양자 컴퓨터에서는 함수에 대한 단 한 번의 쿼리만으로도 이를 알아낼 수 있습니다! 첫 번째 양자 컴퓨팅 알고리즘을 완성하신 것을 축하드립니다! 모든 단계를 이해할 때까지 알고리즘을 몇 번 직접 연습해 보는 것이 좋습니다.

간단한 연습으로, 상수 $0$ 함수(즉, 모든 $x$에 대해 $f(x)=0$)를 사용하여 알고리즘을 실행하고 측정값이 $0$임을 증명해 보세요.

### 3. 연습문제
Deutsch's Algorithm Quantum Circuit

<img src="https://www.quantumsoar.com/_app/immutable/assets/circuit.CPJWFUCU.png" width="400">

문제1. 이 수업의 연습 문제에서는 상수 함수 $f(x)=1$을 사용하는 도이치 알고리즘의 예를 살펴보겠습니다. $\|\psi_2\rangle$ 에서의 상태는 무엇입니까?
> <div>
$$
\begin{align}
|\psi_0\rangle &= |00\rangle  \\
|\psi_1\rangle &= |01\rangle \\
|\psi_2\rangle &= |+-\rangle \\
&= \frac{1}{\sqrt{2}} (|0\rangle + |1\rangle) \otimes |-\rangle \\
&= \frac{1}{\sqrt{2}} (|0\rangle|-\rangle + |1\rangle|-\rangle)
\end{align}
$$
> </div>

문제2. $\|\psi_3\rangle$ 에서 $U_f$ 연산을 적용합니다. $\|\psi_3\rangle$ 을 구합니다. $f$ 가 상수이므로 전역 위상을 인수분해하고 삭제해 보세요. 어떤 상태가 남습니까?
> <div>
$$
\begin{align}
|\psi_3\rangle &= U_f \frac{1}{\sqrt{2}} (|0\rangle|-\rangle + |1\rangle|-\rangle) \\
&= \frac{1}{\sqrt{2}} (U_f |0\rangle|-\rangle + U_f |1\rangle|-\rangle) \\
&= \frac{1}{\sqrt{2}} ((-1)^{f(0)} |0\rangle|-\rangle + (-1)^{f(1)} |1\rangle|-\rangle)
\end{align}
$$
> </div>
>
> $f(0)=1, f(1)=1$ 이므로: \
$|\psi_3\rangle= \frac{1}{\sqrt{2}} ((-1) |0\rangle|-\rangle + (-1)|1\rangle|-\rangle)$ \
$= (-1)\frac{1}{\sqrt{2}} (|0\rangle|-\rangle + |1\rangle|-\rangle)$
>
> 전역위상을 제거하기: $\equiv \frac{1}{\sqrt{2}} (\|0\rangle\|-\rangle + \|1\rangle\|-\rangle$ \
$ = \frac{1}{\sqrt{2}} (\|0\rangle + \|1\rangle)\|-\rangle = \|+\rangle)\|-\rangle$

문제3. 아다마르를 적용한 후 첫 번째 큐비트 상태는 무엇입니까? 이를 무엇으로 측정할 것입니까?
> 답: $\|\psi_4\rangle = H\|+\rangle\|-\rangle = \|0\rangle\|-\rangle$ , 
첫 번째 큐비트가 $\|0\rangle$ 상태에 있으므로 $0$으로 측정합니다. 균형 함수 $f(0)=1,f(1)=0$을 사용하여 알고리즘을 다시 실행합니다.


## 3.05 공통 정체성
### 1. 모든 이진 문자열에 대한 균일 중첩

이제 임의의 비트 수에 작용하는 양자 알고리즘을 살펴보겠습니다. 하지만 그 전에 여러 양자 알고리즘에서 흔히 나타나는 몇 가지 항등식을 알아야 합니다.

$n\|0\rangle$ 의 레지스터가 있고 각 큐비트에 하다마드를 적용한다고 가정해 보겠습니다. 상태는 어떻게 될까요? 양자 회로는 다음과 같습니다: \
$H^{\otimes n}\|0\rangle^{\otimes n} = H\|0\rangle H\|0\rangle H\|0\rangle..$가장 잘 표현할 수 있는 방법을 찾아보자.  다른 $n$의 값으로 시도해 봅시다.

$n=2$: 

<div>
$$
\begin{aligned}
H^{\otimes 2} |0\rangle^{\otimes 2}
&= H|0\rangle H|0\rangle = |+\rangle|+\rangle
= \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle) \otimes  \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle) \\
&= \frac{1}{2} \left( |00\rangle + |01\rangle + |10\rangle + |11\rangle \right) \\
&= \frac{1}{\sqrt{2^2}} \sum_{x \in \{0,1\}^2} |x\rangle
\end{aligned}
$$
</div>

$n=3$:

<div>
$$
\begin{aligned}
H^{\otimes 3} |0\rangle^{\otimes 3} 
&= H|0\rangle H|0\rangle H|0\rangle = |+\rangle|+\rangle|+\rangle \\
&= \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle) \otimes  \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle \otimes  \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle) \\
&= \frac{1}{2} \left( |000\rangle + |001\rangle + |010\rangle + |011\rangle + |100\rangle + |101\rangle + |110\rangle + |111\rangle \right) \\
&= \frac{1}{\sqrt{2^3}} \sum_{x \in \{0,1\}^3} |x\rangle
\end{aligned}
$$
</div>

보시다시피, $\|0\rangle^{\otimes n}$ 상태의 큐비트 레지스터에 하다마드를 적용하면 길이 n인 모든 이진 문자열의 동일한 중첩을 얻습니다. 이는 각 큐비트가 $\|+\rangle$ 상태에 있고, 측정 시 50%의 확률로 $0$으로 붕괴되고 50%의 확률로 $1$로 붕괴되기 때문에 합리적입니다. 이를 길이 $n$인 모든 이진 문자열에 대한 균일 중첩이라고 합니다. 이는 다음과 같은 항등성을 제공합니다.

> $H^{\otimes n} \|0\rangle^{\otimes n} = \frac{1}{\sqrt{2^n}} \sum_{x \in \\{0,1\\}^n} \|x\rangle$


### 2. 임의의 상태에 대한 하다마드
다음 항등식은 임의의 상태 $\|x\rangle$ 에 있는 큐비트에 하다마드를 적용하는 것입니다. 따라서 다음을 구하려고 합니다.

$H^{\otimes n} \|x\rangle = H^{\otimes n} \|x_{0}x_{1}x_{2}...x_{n-1}\rangle, x_i \in \\{0,1\\}$ 경우에

보시다시피 이는 이전 항등식의 일반화된 사례입니다. $n=1$부터 살펴보겠습니다. \
가능한 경우는 두가지입니다. $x_0 = 0$ 이거나 $x_0 = 1$ \

우리가 $x_0 = 0$을 취할 경우, $H\|x_0\rangle = H\|0\rangle = \frac{1}{\sqrt{2}}(\|0\rangle + \|1\rangle)$ \
우리가 $x_0 = 1$을 취할 경우, $H\|x_0\rangle = H\|1\rangle = \frac{1}{\sqrt{2}}(\|0\rangle - \|1\rangle)$ \
일반화하면, $H\|x_0\rangle =  \frac{1}{\sqrt{2}}(\|0\rangle +(-)^{x_0} \|1\rangle)$

이제 임의의 비트에 대한 아다마르 게이트 변환에 대한 식을 찾았습니다. 이제 이를 바탕으로 $n=2$인 경우를 살펴보겠습니다.

<div>
$$
\begin{aligned}
H^{\otimes 2} |x_0 x_1\rangle
&= H|x_0\rangle H|x_1\rangle \\
&= \frac{1}{\sqrt{2}} \bigl( |0\rangle + (-1)^{x_0} |1\rangle \bigr)
   \otimes
   \frac{1}{\sqrt{2}} \bigl( |0\rangle + (-1)^{x_1} |1\rangle \bigr) \\[1em]
&= \frac{1}{\sqrt{2}^2} 
    ( |00\rangle
   + (-1)^{x_0} |01\rangle
   + (-1)^{x_1} |10\rangle
   + (-1)^{x_0 + x_1} |11\rangle) \\
&= 
\frac{1}{\sqrt{2^2}} (
(-1)^{x_0 x_1 \cdot 00} |00\rangle +
(-1)^{x_0 x_1 \cdot 01} |01\rangle +
(-1)^{x_0 x_1 \cdot 10} |10\rangle +
(-1)^{x_0 x_1 \cdot 11} |11\rangle
)
\end{aligned}
$$
</div>

위에서 $x \cdot y$ 는 $x$와 $y$의 내적(dot product)를 말합니다. 예를 들어: \
$010 \cdot 110 = (0)(1) + (1)(1) + (0)(0) = 1  $

이전 항등식과 마찬가지로, 길이가 n인 모든 이진 문자열에 대한 중첩을 얻습니다. 하지만 이 경우, 각 $x_i$는 $0$ 또는 $1$이므로 $x_i = 1$ 일 때 발생하는 $\|-\rangle$ 상태를 고려해야 합니다. 위에서 볼 수 있듯이, 중첩 상태에 1이 있을 때마다
$(-1)^{x_i}$의 인수가 해당 상태에 더해집니다. 여기서 $i$는 $1$의 위치입니다.

일반화하면 다음과 같은 항등식을 얻습니다.

> $H^{\otimes n} \|x\rangle =  \frac{1}{\sqrt{2^n}}\sum_{z \in \\{0,1\\}^n} (-1)^{x \cdot z}\|z\rangle$ \
$\|x\rangle = \|x_{0}x_{1}x_{2}...x_{n-1}\rangle $이고 각 $x_i \in \\{0,1\\}$. $x \cdot z$는 내적을 나타낸다.

### 3. 요약
요약하면, 우리는 다음 두 항등식을 도출했습니다.

$H^{\otimes n} \|0\rangle^{\otimes n} =  \frac{1}{\sqrt{2^n}}\sum_{x \in \\{0,1\\}^n} \|x\rangle$ 

$H^{\otimes n} \|x\rangle =  \frac{1}{\sqrt{2^n}}\sum_{z \in \\{0,1\\}^n} (-1)^{x \cdot z}\|z\rangle$ 

여기서, $\|x\rangle = \|x_{0}x_{1}x_{2}...x_{n-1}\rangle $이고 각 $x_i \in \\{0,1\\}$. $x \cdot z$는 내적을 나타낸다.

직접 유도할 수 없거나 일부 단계가 헷갈리더라도 걱정하지 마세요. 모든 양자 알고리즘에서 사용되는 이 함수들의 작동 방식과 적용 방법을 확실히 이해하시기 바랍니다.

### 4. 연습문제
문제1. 2큐비트 레지스터의 초기 상태는 $\|00\rangle$이며,$H^{\otimes 2}$를 적용한 후 어떻게 됩니까?
> <div>
$$\begin{align}
H^{\otimes 2} |00\rangle
&= H|0\rangle \otimes  H|0\rangle = |+\rangle|+\rangle \\
&= \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle) \otimes  \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle) \\
&= \frac{1}{2} \left( |00\rangle + |01\rangle + |10\rangle + |11\rangle \right) 
\end{align}
$$ 
></div>


문제2. $\|000\rangle$인 3큐비트 레지스터에 $H^{\otimes 3}$ 을 적용하면?
> <div>
$$\begin{align}
H^{\otimes 3} |000\rangle
&= H|0\rangle \otimes  H|0\rangle \otimes  H|0\rangle = |+\rangle|+\rangle|+\rangle \\
&=\frac{1}{2} \left( |000\rangle + |001\rangle + |010\rangle + |011\rangle + |100\rangle + |101\rangle + |110\rangle + |111\rangle \right) 
\end{align}
$$ 
></div>

문제3. 임의의 상태 $\|\psi\rangle$에 $H^{\otimes n}$을 적용한 일반 공식을 내적의 관점에서 표현하시오.
> $H^{\otimes n} \|x\rangle =  \frac{1}{\sqrt{2^n}}\sum_{z \in \\{0,1\\}^n} (-1)^{x \cdot z}\|z\rangle$ \
$x \cdot z = x_0 z_0 + x_1 z_1 + \dots + x_{n-1} z_{n-1} \pmod{2}$ :그 결과를 $\pmod{2}$로 처리하여 0 또는 1 중 하나의 비트 값을 얻는다는 의미.

문제4. 내적 공식을 활용하여 $H^{\otimes 2}\|10\rangle$ 을 계산하시오.
> <div>
$$|\psi\rangle = \frac{1}{2} \sum_{z \in \{00, 01, 10, 11\}} (-1)^{10 \cdot z} |z\rangle$$
$$\begin{aligned} 10 \cdot 00 
&= 1 \cdot 0 + 0 \cdot 0 = 0  \\ 
10 \cdot 01 &= 1 \cdot 0 + 0 \cdot 1 = 0 \\
10 \cdot 10 &= 1 \cdot 1 + 0 \cdot 0 = 1 \\
10 \cdot 11 &= 1 \cdot 1 + 0 \cdot 1 = 1 \end{aligned}$$
$$|\psi\rangle = \frac{1}{2} \left( (-1)^0 |00\rangle + (-1)^0 |01\rangle + (-1)^1 |10\rangle + (-1)^1 |11\rangle \right)$$
$$= \frac{1}{2} \left( |00\rangle + |01\rangle - |10\rangle - |11\rangle \right)$$
></div>
