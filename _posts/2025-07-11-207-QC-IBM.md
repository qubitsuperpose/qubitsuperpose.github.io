---
title: 6차시 7:Quantum algorithmic foundations (Classical computations on quantum computers)
layout: single
classes: wide
categories:
  - Fundamentals of quantum algorithms
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

# 양자 컴퓨터의 고전적 계산

- 출처: [Classical computations on quantum computers](https://quantum.cloud.ibm.com/learning/en/courses/fundamentals-of-quantum-algorithms/quantum-algorithmic-foundations/simulating-classical-computations)


이제 우리는 **양자 컴퓨터에서 고전적 알고리즘을 구현하는 것**에 주목할 것입니다.
우리는 **고전적 불리언 회로로 수행될 수 있는 모든 계산이 유사한 점근적 계산 비용으로 양자 회로에 의해서도 수행될 수 있음**을 알게 될 것입니다.
더욱이, 이는 곧 설명될 **"깔끔한" 방식으로 수행될 수 있으며**, 이는 이러한 계산을 더 큰 양자 계산 내에서 서브루틴으로 사용하는 데 중요한 요구사항입니다.

## 1. 양자 회로를 이용한 부울 회로 시뮬레이션

불리언 회로는 AND, OR, NOT, 그리고 FANOUT 게이트로 구성됩니다.
양자 회로로 불리언 회로를 시뮬레이션하기 위해, 우리는 이 **네 가지 게이트 각각이 양자 게이트로 어떻게 시뮬레이션될 수 있는지 보여주는 것으로 시작**할 것입니다.
일단 그것이 완료되면, 주어진 불리언 회로를 양자 회로로 변환하는 것은 한 번에 하나의 게이트를 시뮬레이션하는 간단한 문제입니다.
우리는 이를 위해 **NOT 게이트, 제어-NOT 게이트, 그리고 토폴리 게이트만 필요**할 것인데, 이들은 모두 유니터리일 뿐만 아니라 결정론적 연산입니다.

### 1.1 토폴리 게이트

토폴리 게이트는 대안적으로 **제어-제어-NOT 게이트로 설명될 수 있으며**, 표준 기저 상태에 대한 그들의 동작은 다음 그림과 같습니다.

<img src="{{site.url}}{{site.baseurl}}/assets/images/QC2/Toffoli-gate.svg" alt="Example of a Boolean circuit" style="width: 50%;" />


큐비트가 위에서 아래로 중요도가 증가하는 순서로 정렬되는 Qiskit의 순서 규칙을 염두에 두면, 이 게이트의 행렬 표현은 다음과 같습니다.
<br>
$$
\begin{pmatrix}
1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0
\end{pmatrix}
$$

토폴리 게이트에 대해 생각하는 또 다른 방법은 이들이 본질적으로 AND 함수의 질의 게이트라는 것입니다. 이는 이들이 이진 문자열 입력과 출력을 갖는 임의 함수에 대한 유니터리 질의 게이트 구현에서 이전 수업에서 본 패턴을 따른다는 의미입니다.

토폴리 게이트는 수업 초반에 논의된 기본 게이트 세트에는 포함되지 않지만, **H, T, T†, 그리고 CNOT 게이트로부터 토폴리 게이트를 다음과 같이 구성하는 것이 가능**합니다.

<img src="{{site.url}}{{site.baseurl}}/assets/images/QC2/build-Toffoli.svg" alt="Example of a Boolean circuit" style="width: 60%;" />


### 1.2 Toffoli, controlled-NOT 및 NOT 게이트를 사용한 부울 게이트 시뮬레이션

몇 개의 NOT 게이트와 함께 사용되는 **단일 토폴리 게이트는 AND 및 OR 게이트를 구현**할 수 있으며, **FANOUT 게이트는 제어-NOT 게이트를 사용하여 쉽게 구현**될 수 있습니다. 이는 다음 다이어그램이 시사하는 바와 같습니다.

<img src="{{site.url}}{{site.baseurl}}/assets/images/QC2/AND-OR-FANOUT-with-Toffoli.svg" alt="Example of a Boolean circuit" style="width: 50%;" />


세 가지 경우 모두에서, AND, OR, 그리고 FANOUT 게이트가 작용하는 큐비트들은 왼쪽에서 입력으로 들어오며, 우리는 또한 **각각에 대해 영 상태로 초기화된 하나의 작업 공간 큐비트를 필요로** 합니다.
이러한 작업 공간 큐비트들은 게이트 구현을 나타내는 상자 안에 나타나며, 이는 그들이 새롭고 따라서 이러한 구현 비용의 일부임을 시사합니다.

AND 및 OR 게이트의 경우 출력 큐비트 외에 두 개의 큐비트가 남아 있습니다.
예를 들어, AND 게이트 시뮬레이션을 나타내는 다이어그램의 상자 안에서, 상위 두 큐비트는 $\vert a\rangle$ 및 $\vert b\rangle$ 상태로 남아 있습니다.
이러한 큐비트들은 더 이상 필요하지 않고 출력의 일부가 아니기 때문에 상자 안에 남아있는 것으로 그림에 나타나 있습니다.
지금은 무시할 수 있지만, 우리는 곧 다시 이들에게 주목할 것입니다.

남아 있는 불리언 게이트인 NOT 게이트는 우리의 기본 양자 게이트 세트에 포함되어 있으므로, 우리는 이것에 대한 시뮬레이션이 필요하지 않습니다.

### 1.3 부울 회로의 게이트별 시뮬레이션

이제 AND, OR, NOT, 그리고 FANOUT 게이트로 구성되고, $n$개의 입력 비트와 $m$개의 출력 비트를 갖는 일반적인 불리언 회로 $C$가 있다고 가정해 봅시다.
$C$의 게이트 수를 $t = \operatorname{size}(C)$라고 하고, $C$가 계산하는 함수를 $f$라고 합시다. 이 함수는 $\Sigma = \{0,1\}$에 대해 
\[f:\Sigma^n\rightarrow\Sigma^m\]의 형태를 취합니다.

이제 $C$의 AND, OR, 그리고 FANOUT 게이트를 하나씩 거쳐가면서, 필요한 작업 공간 큐비트의 추가를 포함하여 위에서 설명한 해당 시뮬레이션으로 각각을 대체할 때 어떤 일이 일어나는지 고려해 봅시다.

<img src="{{site.url}}{{site.baseurl}}/assets/images/QC2/reversible-circuit-simulation.svg" alt="Example of a Boolean circuit" style="width: 50%;" />


결과 회로를 $R$이라고 부르고, $R$의 큐비트를 정렬하여 $C$의 $n$개 입력 비트가 $R$의 상위 $n$개 큐비트에 해당하고 작업 공간 큐비트가 하단에 오도록 합시다.
여기서 $k$는 필요한 작업 공간 큐비트의 수입니다. $C$의 각 AND, OR, 그리고 FANOUT 게이트에 하나씩 — 그리고 $g$는 $R$이 실행된 후 게이트 시뮬레이션에 의해 생성된 남은 큐비트의 상태를 설명하는 $g:\Sigma^n \rightarrow \Sigma^{n+k-m}$ 형태의 함수입니다.

그림에서, 출력 $f(x)$에 해당하는 큐비트들은 상단에 있고, $g(x)$를 저장하는 나머지, 남은 큐비트들은 하단에 있습니다.
원한다면 **SWAP 게이트를 사용하여 큐비트를 재정렬함으로써 이것이 발생하도록 강제할 수 있으며**, SWAP 게이트는 다음과 같이 세 개의 제어-NOT 게이트로 구현될 수 있습니다:

<img src="{{site.url}}{{site.baseurl}}/assets/images/QC2/swap.svg" alt="Example of a Boolean circuit" style="width: 50%;" />


다음 섹션에서 보겠지만, 출력 큐비트를 이런 식으로 재정렬하는 것이 꼭 필수적인 것은 아니지만, 우리가 선택한다면 충분히 쉽게 할 수 있습니다.

남은 큐비트의 고전적 상태를 설명하는 함수 $g$는 회로 $C$에 의해 결정되지만, 우리는 사실 그것에 대해 크게 걱정할 필요가 없습니다.
계산이 끝났을 때 이 큐비트들이 어떤 상태에 있는지 구체적으로 신경 쓰지 않습니다.
문자 $g$는 $f$ 다음에 오므로, 그런 이유로 이 함수에 대한 합리적인 이름이지만, $g$라는 이름을 선택하는 더 좋은 이유가 있습니다 — 그것은 **쓰레기(garbage)의 줄임말**입니다.

## 2. 쓰레기 청소

만약 주어진 불리언 회로 $C$에 의해 계산되는 함수 $f$를 양자 회로로 평가하는 것이 우리의 유일한 관심사라면, 방금 설명한 게이트별 시뮬레이션 이상으로 진행할 필요는 없습니다.
이는 함수 출력 외에, 많은 쓰레기가 남을 것이라는 것을 의미합니다.

그러나 이것은 우리가 더 큰 양자 계산 내에서 고전적 계산을 서브루틴으로 수행하고자 할 경우 충분하지 않습니다. 왜냐하면 **그러한 쓰레기 큐비트들이 문제를 일으킬 것**이기 때문입니다.
**간섭 현상은 양자 알고리즘에 매우 중요**하며, 쓰레기 큐비트들은 양자 알고리즘이 작동하는 데 필요한 간섭 패턴을 망가뜨릴 수 있습니다.

다행히도, 소위 말하는 **쓰레기를 정리하는 것은 어렵지 않습니다**.
핵심은 $R$이 양자 회로이기 때문에, 각 게이트를 역원으로 교체하고 역순으로 적용함으로써 **그것을 역방향으로 실행할 수 있으며**, 이로써 연산 $R^{\dagger}$에 대한 양자 회로를 얻을 수 있다는 사실을 이용하는 것입니다.
**토폴리 게이트, CNOT 게이트, 그리고 NOT 게이트는 실제로 그들 자신의 역원**이므로, $R$을 역방향으로 실행하는 것은 단순히 게이트를 역순으로 적용하는 문제일 뿐입니다 — 하지만 더 일반적으로 모든 양자 회로는 방금 설명한 대로 역방향으로 실행될 수 있습니다.

구체적으로, 우리가 할 수 있는 것은 $m$개의 큐비트를 더 추가하고(함수 $f$가 $m$개의 출력 비트를 가짐을 상기하며), CNOT 게이트를 사용하여 $R$의 출력을 이 큐비트들에 복사한 다음, **$R$을 역방향으로 실행하여 쓰레기를 정리하는 것**입니다.

다음 그림은 결과 회로를 보여주고 표준 기저 상태에 대한 그 동작을 설명합니다.

<img src="{{site.url}}{{site.baseurl}}/assets/images/QC2/garbage-free-computation.svg" alt="Example of a Boolean circuit" style="width: 50%;" />


전체 회로 주위에 상자를 치고 그것을 $Q$라고 부르면, 다음과 같이 보입니다:

<img src="{{site.url}}{{site.baseurl}}/assets/images/QC2/simulation-as-query-gate.svg" alt="Example of a Boolean circuit" style="width: 50%;" />

$C$가 $t$개의 게이트를 가진다는 점을 고려할 때, 회로 $Q$는 $O(t)$개의 게이트를 가질 것입니다.

만약 우리가 $k$개의 추가 작업 공간 큐비트를 무시한다면, 우리가 가지는 것은 함수 $f$에 대한 질의 게이트처럼 정확히 작동하는 회로 $Q$입니다.
만약 우리가 단순히 어떤 문자열 $x$에 대한 함수 $f$를 계산하고 싶다면, $y = 0^m$으로 설정할 수 있으며 결과 값 $f(x)$는 하단 $m$개의 큐비트에 나타날 것입니다 — 또는 원한다면 하단 $m$개의 큐비트에 다른 상태를 입력할 수도 있습니다 (아마도 Deutsch 또는 Deutsch-Jozsa 알고리즘에서처럼 위상 킥백을 활용하기 위함일 것입니다).

이는 어떤 질의 알고리즘에 대해서도, 입력 함수를 계산하는 불리언 회로가 있다면, 각 질의 게이트를 해당 회로 구현으로 대체할 수 있고, 질의 알고리즘이 올바르게 작동할 것임을 의미합니다.

**작업 공간 큐비트가 이 프로세스를 작동시키는 데 필요하지만**, 결합된 회로가 실행되면 **초기 상태로 돌아간다는 점에 유의**하십시오.
이는 이 큐비트들을 다른 목적으로 다시 작업 공간 큐비트로 사용할 수 있게 합니다.
필요한 작업 공간 큐비트의 수를 줄이는 알려진 전략들도 있지만 (이는 회로를 더 크게 만드는 대가를 치릅니다), 여기서는 그러한 전략들을 논의하지 않을 것입니다.

### 2.1 가역 함수 구현

방금 설명된 구성은 어떤 불리언 회로라도 양자 회로를 사용하여 가비지(쓰레기 출력) 없이 시뮬레이션할 수 있도록 해준다.
만약 $C$가 함수 $f:\Sigma^n \rightarrow \Sigma^m$를 구현하는 불리언 회로라면, 우리는 표준 기저 상태에서 다음과 같이 작동하는 양자 회로 $Q$를 얻는다.
\[
Q \bigl( \vert y \rangle \vert 0^k \rangle \vert x\rangle\bigr)
= \vert y \oplus f(x) \rangle \vert 0^k \rangle \vert x\rangle
\]

숫자 $k$는 **총 몇 개의 작업 공간 큐비트가 필요한지**를 나타낸다.
이것은 이 과정의 목적에는 충분하지만, 함수 $f$ 자체가 가역적일 때는 이 방법론을 **한 단계 더 발전시키는 것이 가능**하다.

정확히 말하자면, 함수 $f$가 $f:\Sigma^n \rightarrow \Sigma^n$의 형태를 취하고, 또한 모든 $x\in\Sigma^n$에 대해 $f^{-1}(f(x)) = x$인 함수 $f^{-1}$가 존재한다고 가정해보자 (이는 존재할 경우 필연적으로 유일하다).

이는 모든 $x\in\Sigma^n$에 대해 $\vert x \rangle$을 $\vert f(x) \rangle$로 변환하는 연산이 단위 연산임을 의미하므로, 우리는 다음과 같이 정의된 단위 연산을 구현하는 양자 회로를 구축할 수 있을 것으로 기대할 수 있습니다.
\[
U \vert x \rangle = \vert f(x) \rangle
\]

분명히 말해, 이것이 유니타리(unitary) 연산이라는 사실은 **$f$가 가역적이라는 것에 의존**한다 — $f$가 가역적이지 않을 때는 유니타리가 아니다.
작업 공간 큐비트를 무시하면, $U$는 회로 $Q$가 구현하는 연산과 다르다. 왜냐하면 우리는 입력의 사본을 유지하고 이를 임의의 문자열에 XOR하는 것이 아니라, $x$를 $f(x)$로 **교체**하고 있기 때문이다.

질문은: $f$가 가역적일 때, 이것을 할 수 있는가?

대답은 **'예'**이다. 단, 작업 공간 큐비트를 사용할 수 있고, $f$를 계산하는 불리언 회로를 가지는 것 외에도 $f^{-1}$를 계산하는 불리언 회로를 가지고 있어야 한다.
따라서, 이것은 우리가 아직 계산적으로 역함수를 구하는 방법을 모를 때 **지름길이 아니다!**
다음 다이어그램은 두 개의 양자 회로 $Q_f$와 $Q_{f^{-1}}$를 합성하여 이를 수행할 수 있는 방법을 보여준다. 이들은 위에서 설명한 방법을 통해 함수 $f$와 $f^{-1}$에 대해 개별적으로 얻어지며, $n$개의 스왑 게이트와 함께 사용된다. 여기서 $k$는 $Q_f$와 $Q_{f^{-1}}$에 필요한 작업 공간 큐비트 수 중 **최대값으로 취해진다**.

<img src="{{site.url}}{{site.baseurl}}/assets/images/QC2/fully-reversible-simulation.svg" alt="Example of a Boolean circuit" style="width: 50%;" />
