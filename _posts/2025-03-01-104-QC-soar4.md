---
title: 2차시 4:QC - Math and Theory4
layout: single
classes: wide
categories:
  - Math 
  - Theory
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

- 출처: [www.quantumsoar.com](https://www.quantumsoar.com)

## 3.06 도이치-조자 알고리즘
### 1. 문제와 고전적 해법
도이치-조자 알고리즘은 도이치 알고리즘과 동일한 문제를 해결하여 함수가 상수 함수인지 균형 함수인지 판별합니다. 하지만 도이치-조자 알고리즘은 일반적인 경우이며, 함수 $f$ 를 상수 함수 또는 균형 함수로 분류할 수 있습니다. 여기서 f는 임의의 개수의 비트를 입력으로 받습니다.
$f:\\{0,1\\}^n → \\{0,1\\}$. 이는 도이치 알고리즘과 다른 점입니다. 도이치 알고리즘에서는 한 비트를 입력으로 받는 함수만 다루었기 때문입니다.

간단히 복습하기 위해 상수 함수와 균형 함수를 다시 살펴보겠습니다.

상수 함수는 모든 입력에 대해 0 또는 1을 반환합니다. 다음은 길이가 3인 비트 문자열을 입력으로 받는 함수 $g$에 대한 이러한 함수의 예입니다.

<div style="display: flex; justify-content: center; gap: 20px;  max-width:70%">
  <figure style="text-align: leading;">
    <img src="https://www.quantumsoar.com/_app/immutable/assets/constant_function_1.6q457VbS.png" width="100"><br/>    
  </figure>
  
  <figure style="text-align: leading;">
    <img src="https://www.quantumsoar.com/_app/immutable/assets/constant_function_2.3Sf_jfcE.png" width="100"><br/>
  </figure>
</div>

균형 함수는 입력의 절반에 대해 0을 반환하고, 나머지 절반에 대해 1을 반환합니다. 다음은 길이가 3인 비트 문자열을 입력으로 받는 균형 함수 $f$ 의 예입니다.

<img src="https://www.quantumsoar.com/_app/immutable/assets/balanced_function_1.C1l7trg-.png" width="300">

위에서 볼 수 있듯이 입력의 절반은 0이고 나머지 절반은 1입니다.

우리의 임무는 함수 $f:\\{0,1\\}^n → \\{0,1\\}$이 상수 함수인지 균형 함수인지 판별하는 것입니다. 클래식 컴퓨터에서 이를 수행하려면 최악의 경우 함수 $f$가 $2^{n−1}+1$번 쿼리를 실행해야 합니다 $n$은 입력으로 받는 비트 문자열의 길이입니다. 이는 길이가 $n$인 경우 비트 문자열이 $2^n$개이므로 함수에 대해 가능한 입력 값이 $2^n$개이기 때문입니다. 최악의 경우 입력$2^{n-1}$의 절반을 입력해도 모든 입력에 대해 동일한 출력이 반환됩니다. 이 경우 함수가 상수 함수인지 균형 함수인지 아직 알 수 없습니다. 따라서 마지막으로 함수를 쿼리해야 합니다. 출력이 나머지와 같으면 상수 함수이고, 출력이 다르면 균형 함수입니다. 따라서 최악의 경우 함수를 $2^{n−1}+1$ 번 쿼리해야 합니다. 하지만 양자 컴퓨터에서는 Detutsch-Jozsa 알고리즘을 사용하여 $f$가 상수인지 균형인지 판별하기 위해 함수에 대한 쿼리를 하나만 실행하면 됩니다!

### 2. 양자 해: 도이치-조자 알고리즘
다음은 이 알고리즘의 회로입니다. 보시다시피, 상수 또는 균형 함수로 분류하려는 함수 $f$는 평소처럼 게이트 $U_f$​ 에 인코딩되어 있습니다. 알고리즘을 살펴보겠습니다.

<img src="https://www.quantumsoar.com/_app/immutable/assets/circuit.DrCMAHnx.png" width="500">

<div>
$$
\begin{aligned}
|\psi_0\rangle &= |0\rangle^{\otimes n} |-\rangle \\
|\psi_1\rangle &= H^{\otimes n} |0\rangle^{\otimes n} |-\rangle = H|0\rangle \, H|0\rangle \, \cdots \, H|0\rangle \, |-\rangle
\end{aligned}
$$
</div>

이전 수업에서 우리는 Hadamard Gates를 ∣0⟩의 레지스터에 적용하면 모든 비트 문자열에 대해 균일한 중첩이 생성된다는 것을 알고 있습니다.

$\|\psi\rangle = (\frac{1}{\sqrt{2^n}} \sum_{x \in \\{0, 1\\}^n} \|x\rangle)\|-\rangle$ \
$\qquad=\frac{1}{\sqrt{2^n}} \sum_{x \in \\{0, 1\\}^n} \|x\rangle\|-\rangle$

이제 가역적인 $f$ 로 작용하는 $U_f$ 를 적용: \
$\|\psi_2\rangle = U_f (\frac{1}{\sqrt{2^n}} \sum_{x \in \\{0, 1\\}^n} \|x\rangle\|-\rangle)$ \
$\qquad=\frac{1}{\sqrt{2^n}} \sum_{x \in \\{0, 1\\}^n} U_f \|x\rangle\|-\rangle$

위상 오라클 형식의 $U_f\|x\rangle\|-\rangle$을 평가하면: \
$\|\psi_2\rangle = \frac{1}{\sqrt{2^n}} \sum_{x \in \\{0, 1\\}^n} (-1)^{f(x)}\|x\rangle\|-\rangle$ \
$\qquad= (\frac{1}{\sqrt{2^n}} \sum_{x \in \\{0, 1\\}^n} (-1)^{f(x)}\|x\rangle)\|-\rangle$

$\|\psi_3\rangle$ 에서 첫번째 레지스터의 각각의 큐비트에 아다마드 게이트를 적용: \
$\|\psi_3\rangle = H^{\otimes n}(\frac{1}{\sqrt{2^n}} \sum_{x \in \\{0, 1\\}^n} (-1)^{f(x)}\|x\rangle)\|-\rangle$ \
$\qquad= (\frac{1}{\sqrt{2^n}} \sum_{x \in \\{0, 1\\}^n} (-1)^{f(x)}H^{\otimes n}\|x\rangle)\|-\rangle$

이전 수업에서 우리는 임의의 비트 문자열에 Hadamard Gates를 적용할 때 항등성을 찾았습니다. 이 항등성을 사용하면 다음을 얻습니다.

$\|\psi_3\rangle = \left(\frac{1}{\sqrt{2^n}}\sum_{x\in\\{0,1\\}^n}(-1)^{f(x)}\left[\frac{1}{\sqrt{2^n}}\sum_{z\in\\{0,1\\}^n}(-1)^{x\cdot z}\|z\rangle\right]\right)\|-\rangle$ \
$= \left(\sum_{x\in\\{0,1\\}^n}\frac{1}{2^n}\sum_{z\in\\{0,1\\}^n}(-1)^{f(x)}(-1)^{x\cdot z}\|z\rangle\right)\|-\rangle$ \
$= \left(\sum_{z\in\\{0,1\\}^n}\left[\frac{1}{2^n}\sum_{x\in\\{0,1\\}^n}(-1)^{f(x)+x\cdot z}\right]\|z\rangle\right)\|-\rangle$

큐비트의 첫 번째 레지스터에 대해 모든 $0$ 상태인 $\|00...0\rangle$ 의 진폭을 살펴보겠습니다(음수 상태는 측정되지 않으므로 무시합니다). $z=00...0$ 으로 설정하면 이를 구할 수 있습니다. 이를 통해 첫 번째 레지스터에서 $\|00...0\rangle$ 의 진폭은 다음과 같습니다.

$\frac{1}{2^n}\sum_{x\in\\{0,1\\}^n}(-1)^{f(x)+x\cdot 00...0}$ \\
$= \frac{1}{2^n}\sum_{x\in\\{0,1\\}^n}(-1)^{f(x)+[(0)(x_0)+(0)(x_1)+(0)(x_2)+...+(0)(x_{n-1})]}$ \
$= \frac{1}{2^n}\sum_{x\in\\{0,1\\}^n}(-1)^{f(x)+0}$ \
$= \frac{1}{2^n}\sum_{x\in\\{0,1\\}^n}(-1)^{f(x)} $

이제 $f$가 상수인지 고려해보자: $f$ 가 상수라면, 
$\frac{1}{2^n}\sum_{x\in\\{0,1\\}^n}(-1)^{f(x)} = \frac{1}{2^n}\sum_{x\in\\{0,1\\}^n}1 = \frac{1}{2^n}2^n = 1, \text{ if } f(x)=0 \text{ for all } x$  \
$\frac{1}{2^n}\sum_{x\in\\{0,1\\}^n}(-1)^{f(x)} = \frac{1}{2^n}\sum_{x\in\\{0,1\\}^n}(-1) = \frac{1}{2^n}(-2^n) = -1, \text{ if } f(x)=1 \text{ for all } x$

이 두 가지 사례를 합치면 다음과 같습니다. \
$f$가 상수이면 $\|00...0\rangle$ 상태의 진폭은 $\pm1$입니다.

이제 $f$가 균형인지 고려해보자: $f$ 가 균형이라면, \
$\frac{1}{2^n}\sum_{x\in\\{0,1\\}^n}(-1)^{f(x)} = \frac{1}{2^n}\sum_{x\in\\{0,1\\}^n}\left((-1)^1 + (-1)^1 + (-1)^0 + \cdots + (-1)^0\right)$
$= \frac{1}{2^n}\sum_{x\in\\{0,1\\}^n}(0) = 0$

위에서 볼 수 있듯이, $f(x)=0$(반쪽)이고 $f(x)=1$(반쪽)이므로 $-1$과 $1$의 개수가 같아져 $0$이 됩니다. 따라서 함수가 균형 상태라면 $\|00...0\rangle$ 상태의 진폭은 0이 됩니다.

따라서 함수 $f$가 상수라면 $\|00...0\rangle$ 을 측정할 확률이 $\|\pm 1\|^2 = 1$
이므로 모든 $0(00...0)$을 측정하게 됩니다. 반면에 다른 값을 측정하면 함수가 균형 상태임을 알 수 있습니다(함수가 균형 상태라면 $\|00...0\rangle$을 측정할 확률 $= \|0\|^2=0$이므로).

이제 알고리즘을 완료했습니다. 함수에 대한 한 번의 쿼리로 함수가 상수인지 균형 상태인지 알아낼 수 있었습니다! 과정이 아직 낯설게 느껴지더라도 걱정하지 마세요. 알고리즘의 기본 단계만 이해하면 됩니다. 보시다시피 양자 컴퓨팅은 그렇게 어렵지 않습니다. 기본 원리만 익히면 퍼즐처럼 방정식을 원하는 대로 조작하는 것뿐입니다.

간단한 연습으로, 상수 $0$ 함수(즉, 모든 $x$에 대해 $f(x)=0$)를 사용하여 알고리즘을 살펴보고 측정 결과가 $00...0$임을 보여주세요.

### 3. 연습문제
문제1. 상수 함수를 정의하고 n=3에 대한 예를 들어보세요.
> 답: 상수 함수는 모든 입력에 대해 항상 동일한 값을 출력합니다. n=3일 때의 예:  \
모든 $x \in \\{0,1\\}^3$에 대해 $f(x)=0$이고, \
모든 $x \in \\{0,1\\}^3$에 대해 $f(x)=1$이다, 

문제2. 균형 함수를 정의하고 n=3에 대한 예를 들어보세요.
> 답: 균형 함수는 입력의 정확히 절반에 대해 $0$을 출력하고 나머지 절반에 대해 $1$을 출력.\
 n=3일 때의 예:\
$f(x)=x_0$ (함수는 입력의 첫 번째 비트를 출력합니다). \
이는 0을 출력하는 4개와 1을 출력하는 4개를 생성합니다.

문제3. 고전 컴퓨터에서 $f:\\{0,1\\}^3 →\\{0,1\\}$이 상수인지 균형인지 판별하려면 몇 번의 함수 평가가 필요합니까?
> 답: 최악의 경우, 기존 컴퓨터는 $2^{3-1} + 1=5$ 번 계산해야 합니다. 3비트의 경우 가능한 조합은 8가지이므로, 입력의 절반을 계산한 후에도 4개의 출력이 모두 같은지 확신할 수 없을 수 있으므로, 한 번 더 계산하여 결정해야 합니다.

문제4. 모든 x에 대해 상수 zero 함수 $f(x)=0$에 대해 Deutsch–Jozsa 알고리즘을 실행하세요. 최종 측정 결과는 무엇입니까?
> 답: $f(x)=0$에 대해, 오라클은 위상에 기여하지 못한다:\
$\|\psi_2\rangle = \frac{1}{\sqrt{2}}\sum_x \|x\rangle\|-\rangle$ 첫번째 레지스터에 아다마트 게이트를 적용한 후, $\|\psi_3\rangle = \|00...0\rangle\|-\rangle$, 따라서 측정결과는 항상 $00...0$이다.


## 3.07 번스타인-바자라이 알고리즘
### 1. 문제와 고전적 해결책

$f:\\{0,1\\}^n \to \\{0,1\\}$로 정의된 함수가 있다고 가정합시다. 여기서 $f(x) = x \cdot s \pmod{2}$이고, $x \cdot s = x_0s_0 + x_1s_1 + \cdots + x_{n-1}s_{n-1}$은 $x$와 $s$ 사이의 내적입니다. 우리의 목표는 함수 $f$를 적용할 수 있다는 조건 하에 숨겨진 비트열 $s$를 찾는 것입니다.

고전 컴퓨터로 $s$를 찾기 위해서는, 모두 $0$인 비트스트링에서 한 위치에만 $1$을 입력으로 사용하여 $s$의 위치 중 하나를 얻습니다:

$f(00...01) = (0)s_0 + (0)s_1 + ... + (0)s_{n-2} + (1)s_{n-1} = s_{n-1}$

$f(00...10) = (0)s_0 + (0)s_1 + ... + (1)s_{n-2} + (0)s_{n-1} = s_{n-2}$

$...$

$f(10...0) = (1)s_0 + (0)s_1 + ... + (0)s_{n-2} + (0)s_{n-1} = s_0$

보시다시피, 고전 컴퓨터가 비밀 비트스트링 $s$를 찾기 위해서는 함수를 $n$번 쿼리해야 하며, 여기서 $n$은 비트스트링 $s$의 길이입니다. 반면에 양자 컴퓨터를 사용하면 함수를 단 한 번만 쿼리하면 됩니다!

### 2. Bernstein-Vazirani 알고리즘

다음은 알고리즘의 양자 회로입니다. 보시다시피 Deutsch-Jozsa 알고리즘과 동일하며, 유일한 차이점은 $U_f$에 의해 적용되는 함수입니다.

<img src="https://www.quantumsoar.com/_app/immutable/assets/circuit.DrCMAHnx.png" width="500">

지난 레슨과 동일하게 회로를 따라가면:

$\|\psi_3\rangle = \frac{1}{2^n}\sum_{x\in\\{0,1\\}^n}(-1)^{f(x)}\sum_{z\in\\{0,1\\}^n}(-1)^{x\cdot z}\|z\rangle\|-\rangle$

$= \frac{1}{2^n}\sum_{x\in\\{0,1\\}^n}\sum_{z\in\\{0,1\\}^n}(-1)^{f(x)}(-1)^{x\cdot z}\|z\rangle\|-\rangle$

$= \frac{1}{2^n}\sum_{x\in\\{0,1\\}^n}\sum_{z\in\\{0,1\\}^n}(-1)^{f(x)+x\cdot z}\|z\rangle\|-\rangle$

이제 $f(x)$를 이전에 정의한 연산으로 대체할 수 있습니다:

$= \frac{1}{2^n}\sum_{x\in\\{0,1\\}^n}\sum_{z\in\\{0,1\\}^n}(-1)^{x\cdot s+x\cdot z}\|z\rangle\|-\rangle$

$= \frac{1}{2^n}\sum_{x\in\\{0,1\\}^n}\sum_{z\in\\{0,1\\}^n}(-1)^{(s+z)\cdot x}\|z\rangle\|-\rangle$

여기서 $s+z$는 비트별 XOR을 나타내며, $(s+z)_i = s_i \oplus z_i$로, $s$의 각 비트를 같은 위치의 $z$의 비트와 XOR합니다. 예를 들어 $0110+1110=1000$입니다.

이제 첫 번째 큐비트 레지스터에서 $\|s\rangle$ 상태의 진폭을 살펴보겠습니다. 이를 찾기 위해 $z=s$로 설정합니다:

$\|s\rangle$ 상태의 진폭:

$\frac{1}{2^n}\sum_{x\in\\{0,1\\}^n}(-1)^{(s+s)\cdot x}$

$= \frac{1}{2^n}\sum_{x\in\\{0,1\\}^n}(-1)^{000...0\cdot x}$

$= \frac{1}{2^n}\sum_{x\in\\{0,1\\}^n}(-1)^0$

$= \frac{1}{2^n}\sum_{x\in\\{0,1\\}^n}1$

$= \frac{1}{2^n}2^n$

$= 1$

이로부터 알고리즘 이후 $\|s\rangle$ 상태가 $1$의 진폭을 가지며, 이는 $s$를 측정할 확률이 $\|1\|^2=1$임을 의미합니다. 따라서 첫 번째 레지스터의 큐비트를 측정하기만 하면 비트스트링 $s$를 얻을 수 있습니다. 그게 전부입니다. 함수를 단 한 번만 쿼리하여 $s$를 찾을 수 있었습니다!

간단한 연습으로, 비트스트링 $s=10$으로 알고리즘을 따라가서 얻은 측정값이 $10$임을 보이세요.

### 3. 연습문제
문제1. 고전 컴퓨터가 비밀 문자열 $s$ 를 알아내기 위해 필요한 질의 수는 얼마인가요?
> 답: 고전 컴퓨터는 비트열 \(s\)의 길이인 \(n\)번의 질의가 필요합니다.

문제2. 양자 컴퓨터가 베른스타인-바지라니 알고리즘에서 필요한 질의(query) 수는 몇 개인가요?
> 답: 단일 실행으로 양자 알고리즘이 전체 문자열 \(s\)를 드러내기 때문에, 오직 한 번의 질의만 필요합니다.

문제3. 만약 숨겨진 문자열이 \(s=10\)일 때, 알고리즘은 어떤 결과를 출력하나요?
> 답: 최종 측정 결과는 항상 $\|10\rangle$이 될 것입니다.

문제4. 다음은 \(n=3\)과 은닉 문자열 \(s=101\)로 베른슈타인-바지라니 알고리즘을 수행하는 과정입니다. 최종 측정 결과가 \(101\)이 됨을 보이세요.
> 답: 레슨의 예시를 따라 하세요, 단계는 동일할 것입니다.


## 3.08 양자 푸리에 변환(QFT)

### 1. 양자 푸리에 변환(QFT) 개요
양자 푸리에 변환(Quantum Fourier Transform, QFT)은 큐비트를 표준 기저 {∣0⟩,∣1⟩}에서 푸리에 기저로 변환하는 양자 알고리즘입니다. 이는 고전 컴퓨터에서처럼 0과 1로 값을 인코딩하는 대신, QFT가 큐비트의 위상 내에 값을 인코딩함을 의미합니다. 이는 이진 값을 나타내는 또 다른 방법을 제공합니다. 다음은 3개의 큐비트에 대해 블로흐 구상에서 QFT가 큐비트를 변환하는 방식입니다:

<img src="https://www.quantumsoar.com/_app/immutable/assets/qft_animation.ElRxynqy.gif" width="500">

보시다시피 QFT가 적용된 후 큐비트는 이제 균일한 중첩 상태에 있으며 초기 값은 큐비트의 위상에 인코딩됩니다.

### 2. QFT 회로 및 변환
QFT 회로는 다음과 같습니다.

<img src="https://www.quantumsoar.com/_app/immutable/assets/qft_circuit.Cza7j_Kk.png" width="500">

$R_k$ 게이트는 $$R_k = \begin{bmatrix} 1 & 0 \\ 0 & e^{2\pi i/2^k} \end{bmatrix}$$ 로 정의됩니다. 보시다시피, 이 게이트는 중첩 상태의 큐비트에 $e^{2\pi i/2^k}$ 의 상대 위상을 부여합니다.

이 회로는 상태 $\|j\rangle = \|j_0 j_1 j_2 ... j_{n-1}\rangle$ 를 다음과 같이 변환합니다:

> 
$QFT\|j\rangle = \frac{1}{\sqrt{2}}\left(\|0\rangle + e^{2\pi i\left(\frac{j_{n-1}}{2}\right)}\|1\rangle\right) \otimes \frac{1}{\sqrt{2}}\left(\|0\rangle + e^{2\pi i\left(\frac{j_{n-2}}{2} + \frac{j_{n-1}}{4}\right)}\|1\rangle\right) \otimes \cdots $ \
$\otimes \frac{1}{\sqrt{2}}\left(\|0\rangle + e^{2\pi i\left(\frac{j_0}{2} + \frac{j_1}{4} + \cdots + \frac{j_{n-1}}{2^{n-1}}\right)}\|1\rangle\right) \otimes \frac{1}{\sqrt{2}}\left(\|0\rangle + e^{2\pi i\left(\frac{j_0}{2} + \frac{j_1}{4} + \cdots + \frac{j_{n-1}}{2^n}\right)}\|1\rangle\right)$


3개의 큐비트 $\|j\rangle = \|j_0 j_1 j_2\rangle$ 에 대한 예시를 살펴보겠습니다:

$QFT\|j\rangle = QFT\|j_0 j_1 j_2\rangle = \frac{1}{\sqrt{2}}(\|0\rangle + e^{2\pi i(\frac{j_2}{2})}\|1\rangle) \otimes $ 
$\frac{1}{\sqrt{2}}(\|0\rangle + e^{2\pi i(\frac{j_1}{2} + \frac{j_2}{4})}\|1\rangle) \otimes \frac{1}{\sqrt{2}}(\|0\rangle + e^{2\pi i(\frac{j_0}{2} + \frac{j_1}{4} + \frac{j_2}{8})}\|1\rangle)$

위에서 볼 수 있듯이, $QFT$ 를 적용하면 상태의 값이 큐비트의 위상에 인코딩됩니다. 다음은 상태 $\|5\rangle = \|101\rangle$ 에 대한 예시입니다:

$QFT\|5\rangle = QFT\|101\rangle = \frac{1}{\sqrt{2}}(\|0\rangle + e^{2\pi i(\frac{1}{2})}\|1\rangle) \otimes$ \
 $\frac{1}{\sqrt{2}}(\|0\rangle + e^{2\pi i(\frac{0}{2} + \frac{1}{4})}\|1\rangle) \otimes \frac{1}{\sqrt{2}}(\|0\rangle + e^{2\pi i(\frac{1}{2} + \frac{0}{4} + \frac{1}{8})}\|1\rangle)$

$= \frac{1}{\sqrt{2}}(\|0\rangle + e^{2\pi i(\frac{1}{2})}\|1\rangle) \otimes \frac{1}{\sqrt{2}}(\|0\rangle + e^{2\pi i(\frac{1}{4})}\|1\rangle) \otimes \frac{1}{\sqrt{2}}(\|0\rangle + e^{2\pi i(\frac{5}{8})}\|1\rangle)$

### 3. 역 QFT 회로 및 변환

$IQFT$는 $QFT$의 역변환입니다. 따라서 $QFT$를 적용한 후 $IQFT$를 적용하면 원래 상태를 되돌릴 수 있습니다:

> $QFT\|x\rangle = \|\tilde{x}\rangle, \quad IQFT\|\tilde{x}\rangle = \|x\rangle$

이전에 다음을 확인했습니다:

$QFT\|5\rangle = QFT\|101\rangle$

$= \frac{1}{\sqrt{2}}(\|0\rangle + e^{2\pi i(\frac{1}{2})}\|1\rangle) \otimes \frac{1}{\sqrt{2}}(\|0\rangle + e^{2\pi i(\frac{1}{4})}\|1\rangle) \otimes \frac{1}{\sqrt{2}}(\|0\rangle + e^{2\pi i(\frac{5}{8})}\|1\rangle)$

따라서:

$IQFT\left(\frac{1}{\sqrt{2}}(\|0\rangle + e^{2\pi i(\frac{1}{2})}\|1\rangle) \otimes \frac{1}{\sqrt{2}}(\|0\rangle + e^{2\pi i(\frac{1}{4})}\|1\rangle) \otimes \frac{1}{\sqrt{2}}(\|0\rangle + e^{2\pi i(\frac{5}{8})}\|1\rangle)\right)$

$= \|5\rangle$


### 4. 연습문제
문제1. 양자 푸리에 변환(QFT)은 일반적으로 무엇을 하는가?
> 답: QFT는 양자 상태를 계산 기저에서 푸리에 기저로 변환하여, 숫자를 중첩 상태의 위상으로 인코딩합니다.

문제2. 상태 $|j\rangle$에 대한 QFT의 일반 공식을 작성하시오.
> 답: $\text{QFT}\|j\rangle = \frac{1}{\sqrt{N}}\sum_{k=0}^{N-1}e^{2\pi ijk/N}\|k\rangle$ \
여기서 $N = 2^n$이고 $n$은 $\|j\rangle$의 큐비트 수입니다.

문제3. $\text{QFT}\|0...000\rangle$은 무엇인가?
> 답: $ \text{QFT}\|0...000\rangle = \frac{1}{\sqrt{N}}\sum_{k=0}^{N-1}\|k\rangle$ \
상대 위상이 없는 모든 기저 상태에 대한 균일한 중첩입니다.

문제4. 상태 $\|j\rangle$에 QFT를 적용한 직후 역 QFT(IQFT)를 적용하면 어떻게 되는가?
> 답: 원래 상태를 복원합니다: \
$\text{IQFT}(\text{QFT}(\|j\rangle)) = \|j\rangle$

## 3.09 양자 위상 추정
### 1. 양자 위상 추정 1
이제 양자 위상 추정 알고리즘, 즉 $\text{QPE}$를 살펴봄으로써 $\text{QFT}$의 용도 중 하나를 알아보겠습니다. 상태 $\|v\rangle$이 $U$ 게이트의 고유벡터이고, 고유값이 $e^{i\theta}$라고 가정합시다 $(U\|v\rangle = e^{i\theta}\|v\rangle)$. $\text{QPE}$ 알고리즘은 $U$ 게이트를 적용할 수 있고 큐비트를 상태 $\|v\rangle$로 준비할 수 있다는 전제 하에 고유값 $e^{i\theta}$를 추정할 수 있게 해줍니다.

<img src="https://www.quantumsoar.com/_app/immutable/assets/circuit.DzSBiKav.png" width="500">


다음은 알고리즘의 회로입니다:

$\|\psi_0\rangle = \|0\rangle^{\otimes m}\|v\rangle$ 

$\|\psi_1\rangle = \left(\frac{1}{\sqrt{2}}(\|0\rangle + \|1\rangle) \otimes ... \otimes \frac{1}{\sqrt{2}}(\|0\rangle + \|1\rangle) \otimes \frac{1}{\sqrt{2}}(\|0\rangle + \|1\rangle)\right)\|v\rangle$

$\|\psi_2\rangle = \left(\frac{1}{\sqrt{2}}(\|0\rangle + \|1\rangle) \otimes ... \otimes \frac{1}{\sqrt{2}}(\|0\rangle + \|1\rangle) \otimes \frac{1}{\sqrt{2}}(\|0\rangle + \|1\rangle)\right)CU\|v\rangle$

이제 제어-$U$ 게이트를 그것의 고유벡터 $\|v\rangle$에 적용하면, 위상 킥백이 발생하여 $e^{i\theta}$의 상대 위상을 제어 큐비트로 '킥'합니다:

$\|\psi_2\rangle = \left(\frac{1}{\sqrt{2}}(\|0\rangle + \|1\rangle) \otimes ... \otimes \frac{1}{\sqrt{2}}(\|0\rangle + \|1\rangle) \otimes \frac{1}{\sqrt{2}}(\|0\rangle + e^{i\theta}\|1\rangle)\right)\|v\rangle$

$U^2 = UU$ 게이트를 적용할 때 $\|\psi_3\rangle$에서 위상 킥백이 다시 발생합니다:

$\|\psi_3\rangle = \left(\frac{1}{\sqrt{2}}(\|0\rangle + \|1\rangle) \otimes ... \otimes \frac{1}{\sqrt{2}}(\|0\rangle + e^{i\theta}e^{i\theta}\|1\rangle) \otimes \frac{1}{\sqrt{2}}(\|0\rangle + e^{i\theta}\|1\rangle)\right)\|v\rangle$

$\|\psi_3\rangle = \left(\frac{1}{\sqrt{2}}(\|0\rangle + \|1\rangle) \otimes ... \otimes \frac{1}{\sqrt{2}}(\|0\rangle + e^{2i\theta}\|1\rangle) \otimes \frac{1}{\sqrt{2}}(\|0\rangle + e^{i\theta}\|1\rangle)\right)\|v\rangle$

첫 번째 레지스터의 각 큐비트를 제어로 하는 제어-$U$ 게이트를 적용한 후, 다음 상태가 남습니다:

$\|\psi_4\rangle = \left(\frac{1}{\sqrt{2}}(\|0\rangle + e^{2^{m-1}i\theta}\|1\rangle) \otimes \frac{1}{\sqrt{2}}(\|0\rangle + e^{2^{m-2}i\theta}\|1\rangle) \otimes ... \otimes \frac{1}{\sqrt{2}}(\|0\rangle + e^{2i\theta}\|1\rangle) \otimes \frac{1}{\sqrt{2}}(\|0\rangle + e^{i\theta}\|1\rangle)\right)\|v\rangle$

이제 $\theta = 2\pi j$로 설정하겠습니다. 여기서 $j$는 비트스트링 $0.j_0j_1...j_{m-1}$이고 각 $j_i \in \\{0,1\\}$입니다. $j$를 이진법 대신 십진법으로 나타내면 $j = \frac{j_0}{2} + \frac{j_1}{4} + \frac{j_2}{8} + ... + \frac{j_{m-1}}{2^m}$ 입니다.

$\|\psi_4\rangle = \frac{1}{\sqrt{2}}\left(\|0\rangle + e^{2\pi i 2^{m-1}\left(\frac{j_0}{2} + \frac{j_1}{4} + \frac{j_2}{8} + ... + \frac{j_{m-1}}{2^m}\right)}\|1\rangle\right)$
$\otimes \frac{1}{\sqrt{2}}\left(\|0\rangle + e^{2\pi i 2^{m-2}\left(\frac{j_0}{2} + \frac{j_1}{4} + \frac{j_2}{8} + ... + \frac{j_{m-1}}{2^m}\right)}\|1\rangle\right)$
$\otimes ... \otimes \frac{1}{\sqrt{2}}\left(\|0\rangle + e^{2\pi i 2\left(\frac{j_0}{2} + \frac{j_1}{4} + \frac{j_2}{8} + ... + \frac{j_{m-1}}{2^m}\right)}\|1\rangle\right)$
$\otimes \frac{1}{\sqrt{2}}\left(\|0\rangle + e^{2\pi i\left(\frac{j_0}{2} + \frac{j_1}{4} + \frac{j_2}{8} + ... + \frac{j_{m-1}}{2^m}\right)}\|1\rangle\right)\|v\rangle$

$= \frac{1}{\sqrt{2}}\left(\|0\rangle + e^{2\pi i\left(2^{m-2}j_0 + ... + j_{m-2} + \frac{j_{m-1}}{2}\right)}\|1\rangle\right)$
$\otimes \frac{1}{\sqrt{2}}\left(\|0\rangle + e^{2\pi i\left(2^{m-1}j_0 + ... + j_{n-3} + \frac{j_{m-2}}{2} + \frac{j_{m-1}}{4}\right)}\|1\rangle\right)$
$\otimes ... \otimes \frac{1}{\sqrt{2}}\left(\|0\rangle + e^{2\pi i\left(j_0 + \frac{j_1}{2} + \frac{j_2}{4} + ... + \frac{j_{m-1}}{2^{m-1}}\right)}\|1\rangle\right)$
$\otimes \frac{1}{\sqrt{2}}\left(\|0\rangle + e^{2\pi i\left(\frac{j_0}{2} + \frac{j_1}{4} + \frac{j_2}{8} + ... + \frac{j_{m-1}}{2^m}\right)}|1\rangle\right)\|v\rangle$

상대 위상의 괄호 안에 있는 모든 정수는 $2\pi$의 배수이므로 제거할 수 있으며, 이는 상대 위상의 값에 영향을 주지 않습니다:

$= \frac{1}{\sqrt{2}}\left(\|0\rangle + e^{2\pi i\left(\frac{j_{m-1}}{2}\right)}\|1\rangle\right) \otimes$
$\frac{1}{\sqrt{2}}\left(\|0\rangle + e^{2\pi i\left(\frac{j_{m-2}}{2} + \frac{j_{m-1}}{4}\right)}\|1\rangle\right) \otimes ... \otimes$
$\frac{1}{\sqrt{2}}\left(\|0\rangle + e^{2\pi i\left(\frac{j_1}{2} + \frac{j_2}{4} + ... + \frac{j_{m-1}}{2^{m-1}}\right)}\|1\rangle\right) \otimes$
$\frac{1}{\sqrt{2}}\left(\|0\rangle + e^{2\pi i\left(\frac{j_0}{2} + \frac{j_1}{4} + ... + \frac{j_{m-1}}{2^m}\right)}\|1\rangle\right)$


### 2. Quantum Phase Estimation 2

이제 $IQFT$가 적용되기 직전에 다음 상태가 남습니다:

$\|\psi_4\rangle = \frac{1}{\sqrt{2}}(\|0\rangle + e^{2\pi i(\frac{j_{m-1}}{2})}\|1\rangle) \otimes \frac{1}{\sqrt{2}}(\|0\rangle + e^{2\pi i(\frac{j_{m-2}}{2} + \frac{j_{m-1}}{4})}\|1\rangle) \otimes \ldots $ \
$\otimes \frac{1}{\sqrt{2}}(\|0\rangle + e^{2\pi i(\frac{j_1}{2} + \frac{j_2}{4} + \ldots + \frac{j_{m-1}}{2^{m-1}})}\|1\rangle) \otimes \frac{1}{\sqrt{2}}(\|0\rangle + e^{2\pi i(\frac{j_0}{2} + \frac{j_1}{4} + \ldots + \frac{j_{m-1}}{2^m})}\|1\rangle)$

보시다시피, 이 상태는 $\|j\rangle$ 상태에 $QFT$를 적용한 것과 동일하므로, $\|\psi_4\rangle = QFT\|j\rangle$입니다. 따라서 $IQFT$를 적용하면 $\|j\rangle$ 상태를 얻게 됩니다:

$\|\psi_5\rangle = IQFT[\frac{1}{\sqrt{2}}(\|0\rangle + e^{2\pi i(\frac{j_{m-1}}{2})}\|1\rangle) \otimes \frac{1}{\sqrt{2}}(\|0\rangle + e^{2\pi i(\frac{j_{m-2}}{2} + \frac{j_{m-1}}{4})}\|1\rangle) \otimes \ldots $ \ 
$\otimes \frac{1}{\sqrt{2}}(\|0\rangle + e^{2\pi i(\frac{j_0}{2} + \frac{j_1}{4} + \ldots + \frac{j_{m-1}}{2^{m-1}})}\|1\rangle) \otimes \frac{1}{\sqrt{2}}(\|0\rangle + e^{2\pi i(\frac{j_0}{2} + \frac{j_1}{4} + \ldots + \frac{j_{m-1}}{2^m})}\|1\rangle)]$

$= \|j_0j_1j_2\ldots j_{m-1}\rangle = \|j\rangle$

보시다시피, 이제 $j$를 얻었습니다. $j$를 이용하여 $e^{2\pi ij}$를 계산함으로써 고유값을 찾을 수 있습니다. 다음 강의에서는 아마도 가장 유명한 양자 알고리즘인 Shor's Algorithm을 살펴볼 것입니다. 이 알고리즘은 QPE를 사용하여 두 소수의 곱을 효율적으로 인수분해합니다.


### 3. 연습문제
문제1. 양자 위상 추정(QPE) 알고리즘의 목적은 무엇인가?
> 답: QPE 알고리즘은 유니터리 연산자의 고유값을 추정한다.  
고유벡터 $\|\psi\rangle\$가 알려진 상태에서 $U|\\psi\rangle = e^{i\theta}\|\psi\rangle\$일 때,  
QPE는 이진 형태로 부호화된 위상 $\theta/2\pi$의 근사값을 구한다.  
이를 통해 $e^{i\theta}$를 복원할 수 있으며, 이는 쇼어의 소인수분해나 양자 시뮬레이션과 같은 알고리즘에서 핵심적인 역할을 한다.

문제2. 위상 킥백(phase kickback)이 어떻게 고유값을 첫 번째 레지스터에 인코딩하는가?
> 답: 게이트 $U$에 대해 $\|v\rangle\$가 고유벡터이므로, 위상 인자가 "제어 큐비트로 되돌아온다(kicks back)". 따라서 첫 번째 레지스터는 이제 그 위상에 고유값에 대한 정보를 보유한다.

문제3. 양자 위상 추정(QPE)에서 역 양자 푸리에 변환(IQFT)을 적용한 후에는 어떤 일이 발생하는가?
> 답: IQFT는 위상 인코딩된 중첩 상태를 계산 기저 상태로 변환합니다:  
$\|\psi_3\rangle = \|j\rangle\|v\rangle$
여기서 $j$는 $\theta / 2\pi$의 $n$비트 정밀도 이진 표현입니다. 마지막으로 첫 번째 레지스터를 측정하면 $j$를 얻으며, 이를 통해 고유값을 $e^{2\pi i j}$로 재구성할 수 있습니다.

## 3.10 쇼어 알고리즘
### 1. 사전 지식 1

이제 2개의 소수의 곱을 효율적으로 인수분해할 수 있는 Shor 알고리즘을 다루겠습니다. $N=pq$가 있다고 가정하면, 여기서 $p$와 $q$는 모두 소수입니다. $N$이 주어졌을 때 우리는 $p$와 $q$를 찾으려고 합니다. 이것이 매우 유용해 보이지 않을 수도 있지만, 인기 있는 암호화 알고리즘인 RSA는 고전 컴퓨터가 효율적으로 숫자를 인수분해하여 $p$와 $q$를 찾을 수 없다는 점을 이용합니다. 따라서 이 알고리즘을 통해 우리는 RSA 암호화를 깰 수 있습니다. 하지만 이것은 당분간 일어나지 않을 것입니다. 왜냐하면 수백만 개의 큐비트를 가진 결함 허용 양자 컴퓨터가 필요한데, 이는 몇 년 동안 사용할 수 없을 것이기 때문입니다.

알고리즘을 다루기 전에 모듈러 연산을 이해해야 합니다.

$a$를 $n$으로 나누면 나머지가 $b$일 때, $a \equiv b \mod(n)$이라고 합니다. 예를 들어 $3 \equiv 1 \mod(2)$입니다. 왜냐하면 $3$을 $2$로 나누면 나머지가 $1$이기 때문입니다.

모듈러 거듭제곱은 어떤 수의 거듭제곱을 다른 수로 $mod$ 연산하는 것입니다. 예를 들어:

$2^0 \equiv 1 \mod(9)$

$2^1 \equiv 2 \mod(9)$

$2^2 \equiv 4 \mod(9)$

$2^3 \equiv 8 \mod(9)$

$2^4 \equiv 7 \mod(9)$

$2^5 \equiv 5 \mod(9)$

$2^6 \equiv 1 \mod(9)$

$2^7 \equiv 2 \mod(9)$

$2^8 \equiv 4 \mod(9)$

$2^9 \equiv 8 \mod(9)$

$2^{10} \equiv 7 \mod(9)$

$2^{11} \equiv 5 \mod(9)$

$2^{12} \equiv 1 \mod(9)$

$2^{13} \equiv 2 \mod(9)$

$2^{14} \equiv 4 \mod(9)$

$\cdots$

이렇게 하면 반복되는 패턴을 얻게 되는데, 이 경우 패턴은 $1, 2, 4, 8, 7, 5$입니다. 이 패턴의 길이를 주기 $r$이라고 합니다. 따라서 $2$와 $\mod(9)$의 모듈러 거듭제곱의 주기는 $6$입니다.

이것이 인수분해와 어떤 관련이 있을까요? 우리는 이 주기와 약간의 정수론을 사용하여 $p$와 $q$의 근사값을 얻을 수 있습니다. 모듈러 거듭제곱은 항상 $a^0 \equiv 1 \mod(N)$으로 시작하므로, 주기는 $a^r \equiv 1 \mod(N)$인 가장 작은 수 $r$입니다 ($1 \mod(N)$으로 돌아올 때 패턴이 다시 시작되기 때문입니다).

따라서 우리는 다음을 알고 있습니다:

$a^r \equiv 1 \mod(N)$

$\implies a^r - 1 \equiv 0 \mod(N)$

$\implies (a^{r/2} + 1)(a^{r/2} - 1) \equiv 0 \mod(N)$

따라서 이로부터 $N$을 $(a^{r/2} + 1)(a^{r/2} - 1)$로 나누면 나머지가 0이 될 것임을 알 수 있습니다. 이는 $(a^{r/2} + 1)(a^{r/2} - 1)$가 $N$의 인수임을 의미합니다. 그러므로 주기 $r$의 좋은 근사값을 얻으면, $(a^{r/2} + 1)$ 그리고/또는 $(a^{r/2} - 1)$가 $p$ 그리고/또는 $q$를 포함할 가능성이 높습니다.

### 2. 사전 지식 2

이제 Shor 알고리즘에서 사용되는 몇 가지 양자 게이트와 양자 상태를 살펴보겠습니다. Shor 알고리즘에서는 다음 연산으로 정의되는 $U_{a,N}$ 게이트를 사용합니다:

$U_{a,N}\|x\rangle = \|xa \text{ mod}(N)\rangle$


이를 통해 $\text{mod}(N)$에서 $a$의 모듈러 지수를 계산할 수 있습니다:

$U_{a,N}\|1\rangle = \|a \text{ mod}(N)\rangle$

$U_{a,N}^2\|1\rangle = \|a^2 \text{ mod}(N)\rangle$

$U_{a,N}^3\|1\rangle = \|a^3 \text{ mod}(N)\rangle$

$\vdots$

$U_{a,N}^r\|1\rangle = \|a^r \text{ mod}(N)\rangle = \|1 \text{ mod}(n)\rangle$

이 강의의 나머지 부분에서는 방정식이 너무 복잡해지지 않도록 $U_{a,N}$ 게이트를 $U$로 표기하겠습니다.

이제 다음 상태를 고려해봅시다:

$\|u_s\rangle = \frac{1}{\sqrt{r}}(e^{-2\pi is(0)/r}\|a^0 \text{ mod}(N)\rangle + e^{-2\pi is(1)/r}\|a^1 \text{ mod}(N)\rangle + \ldots $ \
$+ e^{-2\pi is(r-2)/r}\|a^{r-2} \text{ mod}(N)\rangle + e^{-2\pi is(r-1)/r}\|a^{r-1} \text{ mod}(N)\rangle)$

이제 이 상태에 $U$ 게이트를 적용해봅시다:

$U\|u_s\rangle = U\frac{1}{\sqrt{r}}(e^{-2\pi is(0)/r}\|a^0 \text{ mod}(N)\rangle + e^{-2\pi is(1)/r}\|a^1 \text{ mod}(N)\rangle + \ldots $ \
$ + e^{-2\pi is(r-2)/r}\|a^{r-2} \text{ mod}(N)\rangle + e^{-2\pi is(r-1)/r}\|a^{r-1} \text{ mod}(N)\rangle)$

$= \frac{1}{\sqrt{r}}(e^{-2\pi is(0)/r}\|a^1 \text{ mod}(N)\rangle + e^{-2\pi is(1)/r}\|a^2 \text{ mod}(N)\rangle + \ldots $ \
$ + e^{-2\pi is(r-2)/r}\|a^{r-1} \text{ mod}(N)\rangle + e^{-2\pi is(r-1)/r}\|a^r \text{ mod}(N)\rangle)$

$= \frac{1}{\sqrt{r}}(e^{-2\pi is(0)/r}\|a^1 \text{ mod}(N)\rangle + e^{-2\pi is(1)/r}\|a^2 \text{ mod}(N)\rangle + \ldots $ \
 $+ e^{-2\pi is(r-2)/r}\|a^{r-1} \text{ mod}(N)\rangle + e^{-2\pi is(r-1)/r}\|a^0 \text{ mod}(N)\rangle)$

$= e^{2\pi is/r}\frac{1}{\sqrt{r}}(e^{-2\pi is(1)/r}\|a^1 \text{ mod}(N)\rangle + e^{-2\pi is(2)/r}\|a^2 \text{ mod}(N)\rangle + \ldots $ \
$+ e^{-2\pi is(r-1)/r}\|a^{r-1} \text{ mod}(N)\rangle + e^{-2\pi is(r)/r}\|a^0 \text{ mod}(N)\rangle)$

$= e^{2\pi is/r}\|u_s\rangle$

위에서 볼 수 있듯이, $\|u_s\rangle$ 상태는 $U_{a,N}$ 게이트의 고유벡터이며, 고유값은 $e^{2\pi is/r}$입니다. 그러면 $QPE$로 $s/r$을 측정하여 $r$을 얻을 수 있지 않을까요? 그렇게 간단하지 않습니다! $r$을 모르기 때문에 고유값을 측정하기 위한 $\|u_s\rangle$ 상태를 구성할 수 없습니다.

$0 \leq s < r$에 대한 모든 $\|u_s\rangle$ 상태의 중첩을 포함하는 상태는 $\|1\rangle$과 같다는 것이 밝혀졌습니다.

$\frac{1}{\sqrt{r}}\sum_{s=0}^{r-1}\|u_s\rangle = \|1\rangle$

이 결과의 증명은 이 강의의 범위를 벗어나므로, 엄밀한 증명은 Isaac Chuang과 Michael Nielsen의 Quantum Computation and Information을 참조하세요.

### 3. Shor 알고리즘

이제 Shor 알고리즘을 살펴보겠습니다! 이 알고리즘은 3단계로 구성됩니다:

1단계: $1 < a < N$이고 $\gcd(a, N) = 1$인 $a$를 선택합니다. 만약 $\gcd(a, N) \neq 1$인 $a$를 선택하게 되면, $a$와 $N$ 사이의 공약수가 $N$의 소인수가 되므로 쉽게 찾을 수 있습니다. 이 경우는 극히 드뭅니다. 대부분의 경우 $\gcd(a, N) = 1$인 $a$를 얻게 됩니다.

2단계: 이제 알고리즘의 양자 부분입니다. 선택한 $a$에 대해 $\mod(N)$에서 $a$의 모듈러 지수 연산의 주기를 찾으려고 합니다. 이를 위해 다음 회로를 사용합니다:

<img src="https://www.quantumsoar.com/_app/immutable/assets/shors_algorithm_circuit.DpL_XP_2.png" width="500">


보시다시피, 이것은 고유벡터 $\|1\rangle$을 사용하는 $QPE$ 회로입니다. 이를 통해 $s/r$을 측정합니다. $\|1\rangle = \frac{1}{\sqrt{r}}\sum_{s=0}^{r-1}\|u_s\rangle = \frac{1}{\sqrt{r}}(\|u_0\rangle + \|u_1\rangle + \cdots + \|u_{r-1}\rangle)$ 이고, 각 $\|u_s\rangle$는 $U$ 게이트의 고유벡터이므로, 위상 추정 후 고유값을 측정할 때 $0 \leq s \leq r-1$인 하나의 $s$에 대해 $s/r$을 측정합니다. 따라서 측정 시 다음 중 하나를 측정하게 됩니다: $\frac{0}{r}, \frac{1}{r}, \frac{2}{r}, \ldots, \frac{r-1}{r}$

이 시점에서 $0$을 측정하면 $s = 0$인 경우입니다. 이 경우 위상 추정에 대해 0이 아닌 측정값을 얻기 위해 알고리즘을 반복해야 합니다.

이제 $s/r$의 추정값을 얻었으므로, 아직 $s$를 모르기 때문에 $r$을 찾아야 합니다. 이를 위해 연분수라는 기법을 사용합니다. 이 기법을 통해 분수를 절단하여 $s$와 $r$을 추정할 수 있습니다:

예제: $0.312 = 0 + \frac{1}{3 + \frac{1}{4 + \frac{1}{1 + \frac{1}{7}}}}$

분수를 절단하여 $0.312$를 추정할 수 있습니다:

절단 예제: $0.312 \approx 0 + \frac{1}{3 + \frac{1}{4 + 1}} = 0.3125$

동일한 기법을 사용하여 $s$와 $r$을 추정합니다. $r < N$이 될 때까지 분수를 계속 절단합니다. 주기 $r$은 $N$보다 작아야 하기 때문입니다.

3단계: 이제 $r$의 추정값으로 다음을 계산할 수 있습니다:

$\gcd(a^{r/2} + 1, N)$ 그리고 $\gcd(a^{r/2} - 1, N)$

앞서 보았듯이, $r$의 근사값으로 $p$ 그리고/또는 $q$를 얻을 가능성이 높습니다. 둘 다 $1$이면 $r$의 근사값이 잘못된 것이므로 알고리즘을 반복해야 합니다.

보시다시피, 이제 $N$의 소인수를 찾았습니다! 이제 여러분은 RSA 암호화를 깰 수 있는 기술을 갖추었습니다. 여러분만의 양자 컴퓨터만 있다면 말이죠!


### 4. Shor 알고리즘 예제

$N=15$인 알고리즘의 예제를 살펴보겠습니다. 따라서 우리는 $15$의 소인수를 찾으려고 합니다.

**Step 1:** 이제 $\gcd(a,15)=1$을 만족하는 $a$를 선택해야 합니다. 이 예제에서는 $a=7$을 선택하겠습니다.

**Step 2:** 이제 $QPE$를 사용하여 $r$을 추정합니다. $7^r \equiv 1 \pmod{15}$를 만족하는 $r$이 필요합니다. 알고리즘을 사용하여 $r=4$로 추정합니다.

**Step 3:** 이제 다음을 계산합니다:

$\gcd(7^{4/2}-1, 15) = \gcd(48, 15) = 3$

$\gcd(7^{4/2}+1, 15) = \gcd(50, 15) = 5$

보시다시피 우리는 $15$의 두 소수인 $3$과 $5$를 찾았습니다!

이 알고리즘에는 많은 단계가 있으며, 진행되는 모든 것을 완전히 이해하지 못한다면, 가장 좋은 방법은 자신만의 예제로 알고리즘을 몇 번 수행하면서 직관을 쌓아가는 것입니다.

### 5. 연습문제
문제1. 쇼어 알고리즘을 이용하여 $N = 15$을 $a = 7$ 로 인수분해하라. 단계는 무엇인가?
> 답: 1단계: gcd 확인:
$\gcd(7,15)=1$ 
>
2단계: $7^x \mod 15$의 주기 $r$을 구합니다. 쇼어 알고리즘의 양자 단계를 통해 주기 $r=4$를 찾습니다. 
> 
3단계: gcd 계산: 
$\gcd(7^{r/2}-1,15)=\gcd(7^2-1,15)=\gcd(48,15)=3$
$\gcd(7^{r/2}+1,15)=\gcd(50,15)=5$ 
> 
결과: 15의 소인수는 $3$과 $5$입니다.

문제2. 쇼어 알고리즘을 이용하여 $N = 21$ 을 $a = 2$ 로 인수분해하라. 단계는 무엇인가?
> 답: 1단계: gcd 확인:
$\gcd(2,21)=1$
>
2단계: $2^x \mod 21$의 주기 $r$ 찾기. 쇼어 알고리즘의 양자 단계를 통해 주기 $r=6$을 찾음.
>
3단계: GCD 계산:
$\gcd(2^{r/2}-1,21)=\gcd(2^3-1,21)=\gcd(7,21)=7$
$\gcd(2^{r/2}+1,21)=\gcd(2^3+1,21)=\gcd(9,21)=3$
>
결과: 21의 소인수는 $3$과 $7$입니다.
