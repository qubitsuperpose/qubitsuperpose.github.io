---
title: 7차시 1:QGSS 2025 - 1
layout: single
classes: wide
categories:
  - QGSS 2025
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

## 1. 양자역학의 기초: 올리비아 레인즈 - QGSS 2025

- 출처:[양자역학의 기초: 올리비아 레인즈 - QGSS 2025](https://www.youtube.com/watch?v=maJaB4-WfFg&list=PLOFEBzvs-VvoIfbpOb_geVnwFmbW6ij0m)


### **1. 양자 역학 이전 시대: 고전 물리학의 한계**

과거에는 뉴턴 역학과 맥스웰의 전자기학을 기반으로 하는 고전 물리학이 우주의 모든 것을 설명할 수 있다고 믿어졌습니다. 하지만 19세기 말, 원자 규모에서 발생하는 미묘한 '이상 현상'들이 발견되면서 이러한 자신감은 흔들리기 시작했습니다.

*   **자외선 재앙 (Ultraviolet Catastrophe)**: 고전 물리학은 흑체가 짧은 파장(자외선 영역)에서 무한한 에너지를 방출할 것이라고 예측했지만, 실제 실험 결과는 특정 주파수에서 에너지가 최고점에 달했다가 감소하는 모습을 보였습니다. 막스 플랑크(Max Planck)는 에너지가 연속적이지 않고 '양자(quanta)'라는 불연속적인 덩어리로 방출된다는 혁명적인 아이디어를 제시하며 이 문제를 해결했습니다. 이 E=hν라는 공식은 양자 역학의 첫걸음이었습니다.
*   **광전 효과 (Photoelectric Effect)**: 금속 표면에 빛을 비추면 전자가 방출되는 현상입니다. 고전적인 파동 이론으로는 설명할 수 없었죠. 아인슈타인(Einstein)은 빛이 '광자(photons)'라는 입자로 구성되어 있으며, 각 광자의 에너지가 주파수에 비례한다고 제안했습니다. 특정 문턱 주파수 이상의 빛만 전자를 방출시킬 수 있고, 빛의 세기가 아닌 주파수가 전자의 에너지를 결정한다는 실험 결과는 아인슈타인의 이론을 뒷받침했습니다. 아인슈타인은 이 공로로 1921년 노벨 물리학상을 수상했습니다.
*   **원자의 안정성 및 스펙트럼 (Atomic Stability & Spectra)**: 러더퍼드(Rutherford) 원자 모델과 같은 고전 모델은 원자가 왜 안정적인지, 왜 특정 파장의 빛만 방출하는지 설명할 수 없었습니다. 닐스 보어(Niels Bohr)는 전자가 에너지를 방출하지 않고 특정 '양자화된 궤도(quantized orbits)'에만 존재할 수 있다는 가설을 세웠습니다. 전자가 다른 에너지 레벨로 점프할 때만 에너지를 흡수하거나 방출한다는 그의 이론은 수소 원자의 스펙트럼을 잘 설명했습니다.

### **2. 파동-입자 이중성 (Wave-Particle Duality)**

*   **드 브로이 가설 (De Broglie's Hypothesis)**: 빛이 입자처럼 행동할 수 있다면, 전자와 같은 입자도 파동처럼 행동할 수 있다는 아이디어를 루이 드 브로이(Louis de Broglie)가 제안했습니다. 모든 움직이는 입자는 드 브로이 파장(λ = h/p)을 가진다는 것이 핵심입니다.
*   **데이비슨-거머 실험 (Davisson-Germer Experiment)**: 이 실험은 니켈 결정에 전자를 쏘았을 때 파동처럼 간섭 무늬를 만드는 것을 관찰하여 드 브로이 가설을 화려하게 입증했습니다. 이는 입자가 파동과 같은 특성을 가짐을 보여주는 결정적인 증거였으며, 양자 역학의 발전에 중요한 전환점이 되었습니다.

### **3. 양자 역학의 정립과 핵심 원리**

*   **행렬 역학 (Matrix Mechanics, 1925)**: 베르너 하이젠베르크(Werner Heisenberg)는 고전 물리학처럼 입자의 궤적을 추적하는 대신, 관측 가능한 양(예: 위치, 운동량)을 행렬로 표현하는 급진적인 수학적 체계를 도입했습니다. 여기서 핵심 통찰은 **위치와 운동량은 서로 교환되지 않는다(don't commute)**는 것이며, 이는 **불확정성 원리 (Uncertainty Principle)**와 깊이 연결되어 있습니다. 즉, 한 물체의 위치와 운동량을 동시에 정확하게 알 수 없다는 의미입니다.
*   **파동 역학 (Wave Mechanics, 1926)**: 에르빈 슈뢰딩거(Erwin Schrödinger)는 입자를 '파동 함수(wave functions)'로 기술하는 방법을 제시했습니다. 파동 함수는 양자 시스템의 상태를 설명하는 수학적 함수이며, 입자를 특정 위치에서 찾을 확률 진폭을 알려줍니다. 흥미롭게도 슈뢰딩거의 파동 역학은 하이젠베르크의 행렬 역학과 수학적으로 동등하다는 것이 밝혀졌습니다. 이 둘은 같은 이론을 다른 방식으로 표현한 것일 뿐입니다.

이제 양자 역학의 핵심 원리들을 살펴봅시다.

*   **중첩 (Superposition)**: 양자 역학을 특별하게 만드는 첫 번째 핵심 요소입니다. 중첩 상태에서는 입자가 어느 한 곳에만 있는 것이 아니라 동시에 여러 상태에 존재할 수 있습니다. 유명한 **이중 슬릿 실험 (Double-Slit Experiment)**을 통해 이해할 수 있습니다. 전자를 하나씩 쏘아도 두 슬릿을 동시에 통과하여 파동처럼 간섭 무늬를 만듭니다. 우리가 어떤 슬릿을 통과했는지 관찰하려 하면 간섭 무늬가 사라지고 두 개의 개별 분포만 나타납니다. 이는 **양자 역학의 측정 문제 (measurement problem)**를 보여줍니다. 중첩은 양자 시스템이 고전 시스템과 근본적으로 다르게 행동한다는 것을 증명하며, 양자 알고리즘에서 정답의 확률을 증폭시키고 오답을 상쇄하는 데 중요한 역할을 합니다.
*   **양자 간섭 (Quantum Interference)**: 중첩에서 파생되는 현상으로, 확률 파동이 서로 또는 자기 자신과 간섭하여 증폭되거나 상쇄되는 것입니다. '건설적 간섭(constructive interference)'은 파동 함수가 결합하여 증폭되어 입자를 찾을 확률을 높이고, '파괴적 간섭(destructive interference)'은 파동 함수가 상쇄되어 입자를 찾을 확률을 줄이거나 없앱니다.

### **4. 얽힘 (Entanglement)과 비국소성 (Non-locality)**

*   **EPR 논문 (1935)**: 아인슈타인과 그의 동료들인,  EPR 논문 저자들은 양자 역학이 불완전하다고 결론 내렸습니다.
*   **슈뢰딩거의 응답**: 슈뢰딩거는 아인슈타인의 생각에 동의하면서, 이러한 현상을 설명하기 위해 **'얽힘(entanglement)'**이라는 용어를 만들었습니다. 그는 얽힘이 양자 역학의 핵심적인 미스터리이며, 얽힌 시스템은 개별 구성 요소가 아무리 멀리 떨어져 있어도 단일 양자 객체처럼 행동한다고 선언했습니다. **슈뢰딩거의 고양이 (Schrödinger's cat)** 사고 실험은 중첩과 얽힘의 기묘한 결과를 보여주는 유명한 예시입니다. 얽힘은 양자 현실이 본질적으로 **비국소적(non-local)**이라는 것을 의미하며, 한 입자에 대한 측정은 지구 반대편에 있는 다른 입자에도 즉시 영향을 미칠 수 있습니다.
*   **벨 부등식 (Bell Inequality, 1960년대)**: 물리학자 존 벨(John Bell)은 이러한 철학적 논쟁을 실험적으로 검증 가능한 수학적 부등식인 벨 부등식으로 공식화했습니다.
*   **CHSH 부등식 (Clauser-Horn-Shimon-Holt Inequality)**: 벨 정리의 테스트 가능한 버전으로, 실험적으로 세계가 국소 숨은 변수에 의해 지배되는지, 아니면 양자 역학이 비국소적 상관관계를 허용하는지를 결정할 수 있게 합니다. 실험 결과, CHSH 부등식은 **위반되는 것으로 확인되었습니다**. 이는 자연이 국소 실재론(local realism)을 따르지 않으며, 결과가 미리 결정되는 숨은 변수가 없음을 의미합니다. 얽힌 쌍은 고전적인 설명으로는 이해할 수 없는 방식으로 깊이 연결되어 있습니다. 이러한 비국소적 상관관계는 이제 양자 암호학, 양자 네트워크, 그리고 디바이스 독립형 양자 컴퓨팅과 같은 양자 기술의 중요한 자원이 됩니다.

### **5. 양자 정보 과학의 탄생 (1990년대 이후)**

1990년대는 양자 역학이 "왜 그렇게 이상한가?"라는 질문에서 "이 이상함을 어떻게 유용하게 활용할 수 있을까?"로 사고방식이 전환된 시기입니다.

*   **획기적인 양자 알고리즘**: 1994년, 피터 쇼어(Peter Shor)는 고전 컴퓨터보다 기하급수적으로 빠르게 큰 숫자를 인수분해하는 알고리즘을, 로브 그로버(Lov Grover)는 정렬되지 않은 데이터베이스를 제곱근만큼 빠르게 검색하는 알고리즘을 제안했습니다. 이들은 양자 역학이 계산적으로 유용하다는 것을 보여주었습니다.
*   **디빈첸조의 기준 (DiVincenzo's Criteria)**: 1996년, 데이비드 디빈첸조(David DiVincenzo)는 쇼어와 그로버의 알고리즘을 실제로 실행할 수 있는 양자 컴퓨터가 되기 위해 어떤 물리적 시스템이 충족해야 할 일련의 기준을 제시했습니다. 여기에는 큐비트 초기화, 게이트 연산 구현, 오류 수정 등이 포함되었습니다.
*   **실험적 진전**: 동시에 실험 물리학자들은 트랩 이온(trapped ions)과 초전도 큐비트(superconducting qubits)와 같은 시스템을 사용하여 큐비트를 실험실에서 구현하는 초기 단계에서 진전을 보였습니다.

이 모든 것의 영향은 엄청난 **사고방식의 전환(mindset shift)**이었습니다. 과학자들은 양자의 기묘함을 '버그'가 아니라 '특징'으로 보기 시작했습니다. 얽힘, 중첩, 불확정성에 저항하는 대신, 이를 활용하여 양자 기술의 토대를 마련하기 시작한 것입니다.

양자 정보 분야는 수 세기에 걸친 물리학의 토대 위에 세워졌으며, 1990년대는 우리가 우주를 설명하는 것뿐만 아니라 계산하고 더 잘 이해하기 위해 이러한 아이디어들을 활용하기 시작한 순간이었습니다.


## 2. 양자 시뮬레이션 소개: 케일린 페리스 - QQGS 2025

- 출처:[양자 시뮬레이션 소개: 케일린 페리스 - QQGS 2025](https://www.youtube.com/watch?v=xl0eHpfLvAs&list=PLOFEBzvs-VvoIfbpOb_geVnwFmbW6ij0m&index=2)

양자 컴퓨터를 사용하여 양자 시뮬레이션을 시작하는 데 필요한 기본 지식들을 소개하는 강연입니다. 이 강연은 양자 역학의 기초와 수학적 도구를 검토하고, 양자 시뮬레이션의 의미와 해결하려는 문제 유형, 고전적 접근 방식, 그리고 양자 컴퓨터를 이용한 양자 시뮬레이션 방법에 대해 다룹니다. 또한, 양자 시뮬레이션 알고리즘의 구성 요소와 문제를 양자 컴퓨팅 환경에 매핑하는 방법, 그리고 주요 시뮬레이션 접근 방식들을 간략히 소개하며, 실제 코드 예제를 통해 이를 설명합니다.

### **1. 양자 역학의 기본 개념 및 수학적 도구**

*   **양자 역학의 5가지 기본 공준 (Postulates)**:
    *   **양자 상태 기술**: 
        - 물리적 시스템의 상태는 **상태 벡터(state vector)**로 완전히 기술되며, 이는 힐베르트 공간(Hilbert space)의 요소입니다. 힐베르트 공간은 특정 양자 시스템이 가질 수 있는 모든 가능한 상태를 포함하는 벡터 공간입니다.
    *   **관측량(Observables)과 연산자(Operators)**: 
        -   모든 물리적으로 측정 가능한 양(관측량)에는 해당 **헤르미트 연산자(Hermitian operator)**가 있습니다. 이 연산자는 측정 가능한 양과 관련된 모든 가능한 상태를 설명하는 완전한 기저(basis)를 형성합니다.
    *   **측정(Measurements) 및 고유값(Eigenvalues)**: 
        -   상태 벡터에 관측량 연산자를 적용하면 상태 벡터가 변하며, 해당 연산자의 **고유값** 중 하나를 반환합니다. 결과 상태는 즉시 해당 연산자와 관련된 가능한 **고유 상태(eigenstate)** 중 하나로 붕괴됩니다.
    *   **측정 결과의 확률적 특성**: 
        -   상태를 측정할 때, 특정 고유값의 측정 확률은 파동 함수가 가능한 고유 상태와 얼마나 겹치는지에 따라 결정됩니다.
    *   **시간 진화(Time Evolution)**: 
        -   파동 함수가 시간적으로 어떻게 진화하는지는 **시간 의존 슈뢰딩거 방정식(time-dependent Schrödinger equation)**에 의해 지배됩니다.
*   **수학적 도구 및 표기법**:
    *   **상태 벡터(State Vectors)**: 
        -   양자 파동 함수는 측정 결과에 해당하는 요소를 가진 열 벡터(column vector)로 기술됩니다. 이 요소들은 **양자 진폭(quantum amplitudes)**이라고 불리는 복소수이며, 이 복소수의 제곱 크기는 특정 측정 결과의 확률과 관련이 있습니다.
    *   **디랙 표기법(Dirac Notation or Brackette Notation)**: 
        -   양자 상태는 `ket`으로, 그 쌍대(dual)는 `bra`로 표현됩니다.
    *   **기저(Basis)**: 
        -   파동 함수를 기술하기 위해서는 기저 상태(basis states)를 선택해야 하며, 하나의 벡터 공간에는 여러 기저가 존재할 수 있습니다. 기저는 벡터 공간 내에서 모든 상태 벡터를 해당 기저의 구성 요소들의 선형 조합으로 기술할 수 있는 벡터들의 집합입니다.
    *   **연산자(Operators)**: 
        -   양자 역학에서 사용되는 관측량 연산자들은 일반적으로 **행렬(matrix)**로 표현됩니다. 이 행렬 표현은 시스템의 가능한 에너지 준위를 분석적으로 이해하는 데 사용됩니다.
    *   **일반적인 연산**: 
        -   **복소 켤레(complex conjugate)**, **내적(inner product)** (두 벡터의 중첩을 나타내는 스칼라 값을 반환), **텐서 곱(tensor product)** (두 양자 상태를 결합하여 더 큰 양자 상태를 만드는 방법), **헤르미트 켤레(Hermitian conjugate or adjoint)** (행렬의 모든 요소에 복소 켤레를 취하고 대각선을 따라 요소를 뒤집는 것) 등이 있습니다.
    *   **기대값(Expectation Value)**: 
        -   양자 시스템을 특성화하거나 이해하기 위해 수학적으로 측정하려는 값입니다.

### **2. 양자 시뮬레이션이란? (양자 시뮬레이션의 피라미드)**

양자 시뮬레이션은 크게 세 가지 유형의 문제 해결을 목표로 합니다:

*   **고유 상태 풀기(Eigenstate Solvers)**: 
    -   매우 큰 행렬(예: 해밀토니안)을 대각화하여 시스템의 가능한 모든 에너지 준위(고유값)와 해당 고유 상태를 찾는 문제. 작은 행렬에는 비교적 간단하지만, 시스템의 복잡도가 증가하고 행렬 크기가 기하급수적으로 커지면 고전 컴퓨터로는 대각화가 불가능해집니다.
*   **양자 역학(Quantum Dynamics)**: 
    -   시스템이 시간적으로 어떻게 진화하는지 이해하는 문제, 특히 외부 자극에 대한 반응이나 화학 반응과 같이 시간 의존성이 있는 경우. 시스템이 클수록 계산하기 매우 어려워집니다.
*   **상전이(Phase Transitions)**: 
    -   시스템의 **바닥 상태(ground state)**가 온도, 자기장, 압력 등과 같은 질서 매개변수(order parameter)의 변화에 따라 어떻게 변하는지 이해하는 문제. 고전적 상전이와 달리 양자 상전이는 시스템의 바닥 상태 자체의 급격한 변화를 설명합니다 (예: 도체-초전도체 전이).

### **3. 고전적 접근 방식**

양자 시스템을 고전 컴퓨터로 시뮬레이션하는 데에는 본질적인 문제가 있습니다. 시뮬레이션하려는 시스템이 너무 커지면 정확한 고유 상태와 고유값을 풀기가 불가능해지기 때문입니다. 따라서 고전적 접근 방식은 종종 근사치를 사용합니다.

*   **텐서 네트워크(Tensor Networks)**: 
    -   비교적 최근에 인기를 얻고 있는 접근 방식으로, 파동 함수를 거대한 벡터 대신 개별 텐서로 표현하고, 이 텐서들의 얽힘(entanglement)을 통해 연결합니다. 강한 상관관계나 높은 얽힘을 가진 시스템 연구에 유용하지만, 얽힘의 정도에 따라 한계가 있습니다.
*   **밀도 범함수 이론(Density Functional Theory, DFT)**: 
    -   재료 내 전자의 거동을 이해하는 데 널리 사용되는 강력한 시뮬레이션 도구입니다. 많은 전자들의 상호작용을 개별 전자가 전자 밀도와 상호작용하는 것으로 근사화하여 계산 비용을 줄입니다. 그러나 강하게 상관된 시스템에서는 예측력이 떨어질 수 있다는 한계가 있습니다.

### **4. 양자 컴퓨터를 이용한 양자 시뮬레이션 접근 방식**

양자 컴퓨터를 사용하여 양자 시뮬레이션 문제를 해결하는 워크플로는 다음과 같습니다:

*   **양자 시뮬레이션 알고리즘의 구성**:
    1.  **양자 시스템 선택 및 특성화**: 
        -   시뮬레이션할 시스템을 정의하고, 해밀토니안과 중요한 관측량을 식별합니다.
    2.  **해밀토니안 매핑**: 
        -   해밀토니안과 파동 함수의 표현을 양자 컴퓨팅 환경에 매핑합니다. 이는 연산자를 폴리(Pauli) 또는 스핀 기반 연산자로 변환하는 것을 포함하며, **Jordan-Wigner 변환(Jordan-Wigner transform)** 또는 **Bravyi-Kitaev 변환(Bravyi-Kitaev transform)**과 같은 방법이 사용됩니다. 효율적인 매핑은 회로의 크기와 오류 완화 능력에 중요합니다.
    3.  **양자 알고리즘 준비**: 
        -   문제를 해결하기 위한 양자 회로를 준비합니다 (예: **변분 양자 해결사(Variational Quantum Eigensolver, VQE)**, **시간 진화 회로(time evolution circuit)**).
    4.  **후처리(Post-processing)**: 
        -   양자 컴퓨터에서 실험을 실행한 후, 오류 완화(error mitigation) 또는 원시 데이터 분석을 위한 필요한 후처리 단계를 수행합니다.

*   **정규적인 양자 시뮬레이션 알고리즘**:
    *   **변분 양자 고유값 해결사(Variational Quantum Eigensolver, VQE)**: 
        -   양자 시스템의 바닥 상태 에너지를 찾는 **하이브리드 양자-고전(hybrid quantum-classical)** 접근 방식입니다. **안자츠(ansatz)**라고 하는 매개변수화된 양자 회로를 사용하여 가능한 파동 함수를 표현하고, 고전 최적화기를 통해 시스템의 총 에너지 측정을 최소화하여 바닥 상태 에너지를 근사합니다.
    *   **샘플 기반 양자 대각화(Sample-based Quantum Diagonalization)**: 
        -   문제의 대칭성을 활용하여 양자 컴퓨터에서 얻은 결과를 개선하는 새로운 접근 방식입니다. 안자츠로 상태를 준비하고, 그 확률 분포를 샘플링한 후, **구성 복구 루프(configuration recovery loop)**를 통해 물리적으로 불가능한 측정값을 제거하여 결과를 정제합니다. 그런 다음 고전 대각화 방법을 적용하여 가장 낮은 에너지를 찾습니다.
    *   **양자 역학/시간 진화(Quantum Dynamics / Time Evolution)**: 
        -   **시간 진화 연산자(time evolution operator)**를 구현하여 파동 함수가 시간적으로 어떻게 진화하는지 관찰합니다. 해밀토니안을 지수화한 행렬로 구성되어 있어, **트로터 근사(Trotter approximation)**를 사용하여 해밀토니안의 구성 요소를 분리하고 매우 작은 시간 단계로 연산자를 적용하여 근사합니다.
    *   **위상 추정 알고리즘(Phase Estimation Algorithms, QPE)**: 
        -   시스템의 기대값이나 관측량을 추정하거나 상전이를 연구하는 데 사용되는 알고리즘 클래스입니다. 정규 양자 위상 추정 알고리즘은 회로 깊이가 깊고 제어 연산이 많아 현재 양자 컴퓨터로는 실행하기 어렵습니다. 반복 양자 위상 추정(iterative quantum phase estimation)과 같은 다른 형태도 있습니다.

### **5. 실습 코드 예제 (Hubbard Model)**

강연에서는 **허바드 모델(Hubbard model)**이라는 비교적 간단한 모델을 사용하여 양자 역학 시뮬레이션의 실제 예시를 보여줍니다.

*   **모델 설정**: 
    -   전자가 개별 사이트(sites)를 뛰어넘을 수 있는 능력(호핑 에너지)과 같은 사이트를 점유할 때 전자가 서로 반발하는 능력(반발 에너지)을 설명하는 해밀토니안으로 구성됩니다. 예시에서는 단일 체인(1D chain)의 5개 사이트에 스핀 업(spin up) 전자와 스핀 다운(spin down) 전자가 존재할 수 있는 시스템을 가정합니다.
*   **매핑**: 
    -   이 모델의 두 번째 양자화(second quantization) 연산자는 양자 회로에서 직접 실행할 수 없으므로, **Jordan-Wigner 변환**을 사용하여 이 연산자들을 양자 컴퓨터에서 접근 가능한 폴리 연산자로 매핑합니다. 이 매핑을 통해 해밀토니안은 폴리 X 및 폴리 Y 회전 등으로 표현됩니다.
*   **시뮬레이션 예시**: 
    -   초기 상태로 단일 스핀 업 전자를 1D 체인의 한 사이트에 배치하고, 시스템이 시간적으로 진화함에 따라 전자가 각 사이트에 존재할 확률 분포를 관찰합니다. Qiskit 라이브러리의 `evolved_operator_ansatz` 함수를 사용하여 해밀토니안을 기반으로 시간 진화 회로를 생성합니다.
*   **결과**: 
    -   시뮬레이션 결과는 전자의 확률 분포가 시간에 따라 어떻게 퍼져나가는지를 보여주는 플롯으로 나타납니다. 이 예시에서는 스핀 업 전자만 시뮬레이션했기 때문에, 확률 분포는 체인의 한쪽 스핀 섹터에만 나타나는 것을 확인할 수 있습니다. 이 예시는 현재의 양자 컴퓨터가 아닌, 잡음이 없는 결함 허용 양자 컴퓨터(fault-tolerant quantum computer)를 가정한 시뮬레이션입니다.


## 3. Deutsch 알고리즘과 Grover 알고리즘

- 출처:[Foundational Quantum Algorithms Part I](https://www.youtube.com/watch?v=PVCZb0p2FBo&list=PLOFEBzvs-VvoIfbpOb_geVnwFmbW6ij0m&index=3)

**양자 컴퓨팅의 기초 알고리즘: Deutsch 알고리즘 및 Grover 알고리즘**

-   이 강연은 기초적인 양자 알고리즘인 Deutsch 알고리즘과 Grover 알고리즘을 소개합니다. 이들은 비교적 간단하지만, 양자 알고리즘의 근본적인 예시이며 양자 우위를 이해하는 중요한 출발점입니다.

### **1. 계산 모델의 추상적 이해 및 쿼리 모델 (Query Model)**

*   **기본 계산 모델**: 
    -   먼저, 입력(이진 문자열)을 받아 계산(파란색 사각형)을 거쳐 출력(이진 문자열)을 생성하는 간단한 계산 모델을 소개합니다.
*   **쿼리 모델 도입**: 
    -   하지만 이 강연에서는 **쿼리 모델**이라는 다른 계산 모델을 주로 사용합니다. 이 모델은 실용적인 모델이라기보다는 알고리즘 연구를 위한 엄격한 틀로, 입력이 문자열이 아니라 **함수(f)** 형태로 제공된다는 점이 특징입니다.
*   **오라클(Oracle) 또는 블랙박스(Black Box)**: 
    -   계산은 이 함수에 대해 **쿼리(query)**를 통해 접근합니다. 즉, 함수를 다양한 입력에 대해 평가하고 그 결과를 받는 방식입니다. 이때 함수를 제공하는 메커니즘을 '오라클' 또는 '블랙박스'라고 부르며, 내부 작동 방식은 알 수 없습니다.
*   **계산 비용 측정**: 
    -   쿼리 알고리즘의 계산 비용은 **쿼리 횟수**로 측정됩니다. 오라클 구현 비용은 고려하지 않으며, 오라클이 주어졌을 때 문제 해결에 필요한 쿼리 수에 집중합니다.

### **2. 양자 쿼리 게이트 (Quantum Query Gates)**

*   **정의**: 
    -   양자 회로에서 쿼리를 수행하기 위해 **유니타리(unitary)**한 쿼리 게이트 `UF`를 사용합니다. 이 게이트는 `n+m` 큐비트에 작용하며, 입력 큐비트 `|x>`는 그대로 유지되고, 출력 큐비트 `|y>`는 `f(x)`와 **비트별 배타적 논리합(bitwise exclusive OR)**이 적용된 `|y ⊕ f(x)>`로 변환됩니다.
*   **유니타리 특성**: 
    -   이 게이트는 항상 유니타리입니다. 즉, 행렬로 표현하면 각 행과 열에 하나의 1만 있는 순열 행렬이 되며, 이는 항상 유니타리이고 자체 역 연산이 됩니다 (`UF† = UF`).
*   **중첩 상태에서의 쿼리**: 
    -   이 게이트를 사용하면 양자 상태의 **선형성(linearity)** 덕분에 **중첩(superposition)** 상태에서 쿼리를 수행할 수 있습니다.

### **3. Deutsch 알고리즘: 첫 번째 양자 우위의 예시**

*   **Deutsch 문제**: 
    -  Deutsch 알고리즘은 1비트 입력에 대해 1비트 출력을 내는 함수 `f`가 주어졌을 때, 이 함수가 **상수 함수(constant function)**인지 **균형 함수(balanced function)**인지 판별하는 문제입니다.
        *   상수 함수: `f(0)=f(1)=0` 또는 `f(0)=f(1)=1`
        *   균형 함수: `f(0) ≠ f(1)`
*   **고전 알고리즘의 한계**: 
    -   어떤 고전 쿼리 알고리즘이든 이 문제를 풀기 위해서는 **최소 2번의 쿼리**가 필요합니다. `f(0)` 또는 `f(1)` 중 하나만 알아서는 함수의 특성(상수인지 균형인지)을 알 수 없기 때문입니다.
*   **Deutsch 알고리즘의 양자 우위**: 
    -   Deutsch 알고리즘은 **단 한 번의 쿼리**만으로 Deutsch 문제를 확실하게 해결합니다.
*   **작동 방식**:
    1.  두 큐비트를 `|0>|1>` 상태로 초기화합니다.
    2.  두 큐비트에 Hadamard 게이트를 적용합니다. 이로써 `|0>`은 `|+>`로, `|1>`은 `|->` 상태가 됩니다.
    3.  **양자 쿼리 게이트 `UF`**를 적용합니다. 여기서 **위상 킥백 (phase kickback)** 현상이 일어납니다. `UF` 게이트는 `f(x)` 값을 직접 출력하는 대신, `f(x)` 값을 위상(phase)으로 변환하여 첫 번째 큐비트에 "킥백"합니다. 이는 `|->` 상태가 X(NOT) 연산자의 고유 벡터(eigenvector)이기 때문에 가능합니다.
    4.  첫 번째 큐비트에 다시 Hadamard 게이트를 적용합니다.
    5.  첫 번째 큐비트를 측정합니다. 측정 결과는 `f(0)`과 `f(1)`의 **배타적 논리합**으로, 이는 함수가 상수인지 균형인지에 대한 답을 제공합니다.
*   **핵심 원리**: 
    -   Deutsch 알고리즘의 효율성은 **중첩**을 통해 `f(0)`과 `f(1)`을 동시에 계산하고, **위상 킥백**과 **간섭(interference)**을 통해 올바른 답에 대한 건설적 간섭(constructive interference)과 잘못된 답에 대한 파괴적 간섭(destructive interference)을 유도하여 단 한 번의 쿼리로 정답을 얻는 데 있습니다.

### **4. Grover 알고리즘: 비정형 탐색의 양자적 가속**

*   **비정형 탐색 문제**: 
    -   Grover 알고리즘은 정렬되지 않거나 유용하게 정돈되지 않은 항목들의 집합에서 원하는 항목(해답)을 찾는 문제인 **비정형 탐색 (unstructured search)** 문제를 해결합니다. 함수 `f`가 주어졌을 때 `f(x)=1`을 만족하는 `x`를 찾는 것이 목표입니다. 해답이 없으면 "해답 없음"을 보고합니다.
*   **고전 알고리즘의 한계**: 
    -   `n`비트 문자열의 총 개수가 `N = 2^n`일 때, 고전적인 결정론적 알고리즘은 최악의 경우 **O(N) 쿼리**를 필요로 합니다.
*   **Grover 알고리즘의 양자 우위**: 
    -   Grover 알고리즘은 **O(√N) 쿼리**만으로 해답을 찾을 수 있습니다. 이는 **제곱근 이점(quadratic advantage)**이라고 불리는 상당한 개선입니다.
*   **위상 쿼리 게이트 (Phase Query Gate, ZF)**: 
    -   Grover 알고리즘은 `UF` 게이트 대신, 함수의 출력값을 추가 큐비트에 XOR하는 대신 **위상(phase)**에 넣는 `ZF` 게이트를 주로 사용합니다. 이는 `UF` 게이트와 위상 킥백 현상을 활용하여 구현할 수 있습니다.
*   **Grover 알고리즘 단계**:
    1.  **초기화**: `n`개의 큐비트를 모두 `|+>` 상태로 초기화하여 모든 `n`비트 문자열의 **균일한 중첩(uniform superposition)** 상태(`|U>`)를 만듭니다.
    2.  **Grover 연산자 (Grover Operation, G)** 반복 적용: 알고리즘의 핵심인 Grover 연산자 `G`를 `t`번 반복 적용합니다. `G`는 다음과 같은 연산들의 조합입니다.
        *   입력 함수 `F`에 대한 **위상 쿼리 게이트 `ZF`**
        *   Hadamard 게이트 층
        *   `n`비트 OR 함수에 대한 위상 쿼리 게이트 `Z_OR` (이것은 `F`에 의존하지 않으므로 쿼리 없음)
        *   Hadamard 게이트 층
        *   `G`의 한 번의 적용은 `F`에 대한 **한 번의 쿼리**를 필요로 합니다.
    3.  **측정**: 최종적으로 표준 기저에서 큐비트를 측정하여 후보 해답 `x`를 얻습니다.
*   **기하학적 해석 (Geometric Interpretation)**: 
    -   Grover 연산자 `G`는 해답이 아닌 상태들의 균일 중첩(`|A0>`)과 해답 상태들의 균일 중첩(`|A1>`)으로 이루어진 **2차원 부분 공간 내에서의 회전(rotation)**으로 해석될 수 있습니다. `G`는 두 개의 반사(reflection) 연산의 합성으로, 두 반사선 사이 각도의 두 배만큼 벡터를 회전시킵니다.
    *   초기 상태 `|U>`는 `cosθ|A0> + sinθ|A1>`로 표현되며, `θ`는 해답의 수 `S`와 전체 공간의 크기 `N`에 따라 `arcsin(√(S/N))`으로 결정되는 중요한 각도입니다.
    *   `G`를 한 번 적용할 때마다 상태 벡터는 `2θ`만큼 회전합니다. 따라서 `t`번 적용 후 상태는 `cos((2t+1)θ)|A0> + sin((2t+1)θ)|A1>`이 됩니다.
*   **반복 횟수 `t`의 선택**: 
    -   성공 확률을 높이려면 상태 벡터가 해답 상태 `|A1>`에 최대한 가까워지도록 `t`를 선택해야 합니다. 이상적으로 `(2t+1)θ`가 `π/2`에 가까워지는 `t`를 선택하며, 이는 대략 `t ≈ (π/4)√(N/S)`입니다.
    *   **해답 수 `S`를 아는 경우**: `S`를 미리 알고 있다면 최적의 `t`를 선택하여 높은 확률로 해답을 찾을 수 있습니다. 예를 들어, `N=128`에서 해답이 1개인 경우 `t=8`로 약 0.5%의 실패율을, 해답이 4개인 경우 `t=4`로 99.9% 이상의 성공률을 보입니다.
    *   **해답 수 `S`를 모르는 경우**: `S`를 모를 때는 `t`를 `1`에서 `floor(π/4 * √N)` 사이에서 무작위로 선택하는 간단한 방법이 있습니다. 이 경우 최소 40%의 성공 확률을 보장하며, 알고리즘을 여러 번 반복하면 성공 확률을 크게 높일 수 있습니다. 또한, `t`를 점진적으로(예: 5/4배씩) 늘려가며 시도하는 더 정교한 접근 방식도 있습니다.
*   **Grover 알고리즘의 중요성**:
    *   **점근적 최적성 (Asymptotically Optimal)**: 쿼리 모델 내에서 Grover 알고리즘은 탐색 문제 해결에 필요한 쿼리 수의 이론적 하한(`Ω(√N)`)과 일치하는 **점근적으로 최적의 알고리즘**입니다.
    *   **광범위한 적용 가능성 (Broadly Applicable)**: 비정형 탐색 문제 외에도 다른 알고리즘 위에 겹쳐서 이차적 개선을 얻거나, 더 복잡한 양자 알고리즘의 서브루틴으로 자주 사용됩니다. Grover의 회전 기법은 더 일반적인 양자 기술의 대표적인 예시입니다.

Deutsch와 Grover 알고리즘은 양자 컴퓨터가 고전 컴퓨터보다 계산 문제를 해결하는 데 어떻게 잠재적인 이점을 가질 수 있는지 보여주는 중요한 출발점입니다. 특히 중첩, 위상 킥백, 간섭과 같은 양자 현상을 활용하여 쿼리 횟수에서 현저한 우위를 제공하는 방법을 명확히 보여줍니다. 

## 4. 양자 위상 추정(Phase Estimation)과 쇼어 알고리즘(Shor's Algorithm)

- 출처:[기초 양자 알고리즘 2부](https://www.youtube.com/watch?v=FedIoaTzaug&list=PLOFEBzvs-VvoIfbpOb_geVnwFmbW6ij0m&index=4)

**위상 추정 문제(Phase Estimation Problem)**와 양자 컴퓨터를 이용해 이 문제를 어떻게 해결하는지에 대해 다룹니다. 나아가, 위상 추정이 **정수 인수분해 문제(Integer Factorization Problem)**에 어떻게 적용되어 **쇼어 알고리즘**을 탄생시키는지 설명합니다. 쇼어 알고리즘은 고전 컴퓨터로는 효율적으로 해결하기 어려운 정수 인수분해를 양자 컴퓨터에서 효율적으로 가능하게 합니다.

### **1. 아이겐 벡터(Eigenvectors)와 아이겐 값(Eigenvalues)의 이해**

위상 추정의 핵심 개념을 이해하기 위해 먼저 **아이겐 벡터와 아이겐 값**을 알아야 합니다.
*   **정의**: 
    -   행렬 $M$에 벡터 $s$를 곱하는 것이 스칼라 $\lambda$를 $s$에 곱하는 것과 같은 효과를 낼 때, $s$를 $M$의 **아이겐 벡터**라고 하고, $\lambda$를 $s$에 해당하는 **아이겐 값**이라고 합니다.
*   **유니타리 행렬(Unitary Matrices)**: 위상 추정에서는 특히 **유니타리 행렬**에 초점을 맞춥니다. 유니타리 행렬은 다음과 같은 중요한 특성을 가집니다:
    *   모든 유니타리 행렬은 아이겐 벡터들의 **정규 직교 기저(orthonormal basis)**를 가집니다.
    *   모든 유니타리 행렬의 아이겐 값은 복소수 평면의 **단위 원(unit circle)** 위에 존재합니다. 즉, 아이겐 값 $\lambda$는 $e^{2\pi i \theta}$ 형태로 표현될 수 있으며, 여기서 $\theta$는 0과 1 사이의 실수입니다.

### **2. 양자 위상 추정 문제(Quantum Phase Estimation Problem)**

**위상 추정 문제**는 다음과 같이 정의됩니다:
*   **입력**:
    1.  $n$ 큐비트에 작용하는 유니타리 양자 회로 $U$에 대한 설명.
    2.  $U$의 아이겐 벡터 $s$의 단일 복사본인 $n$ 큐비트 양자 상태. 이 상태는 일반적인 고전적 입력과 달리 **양자 상태 입력**이라는 점이 독특합니다.
*   **약속 (Promise)**: 
    -   입력된 양자 상태 $s$는 주어진 유니타리 연산 $U$의 아이겐 벡터입니다.
*   **목표**: 
    -   이 아이겐 벡터 $s$에 해당하는 아이겐 값, 특히 실수 **$\theta$ 값($0 \le \theta < 1$)**을 찾아내거나 근사하는 것입니다. $\theta$의 근사는 보통 **$y/2^m$ 형태의 분수**로 이루어집니다.
*   **활용**: 
    -   위상 추정은 일반적으로 더 큰 계산의 **서브루틴(subroutine)**으로 사용됩니다.

### **3. 위상 추정의 기본 아이디어: 위상 킥백(Phase Kickback)**

위상 추정의 원리는 **위상 킥백 현상**을 활용합니다.
*   **제어 U 연산(Controlled-U Operation)**: 
    -   유니타리 연산 $U$를 제어 큐비트에 연결하여 제어 큐비트가 $\|1\rangle$일 때만 $U$가 적용되도록 합니다.
*   **초기 상태 및 작동**: 
    -   제어 큐비트를 Hadamard 게이트로 중첩 상태 $(\|0\rangle + \|1\rangle)/\sqrt{2}$로 만든 후, 제어 U 게이트를 아이겐 벡터 $s$에 적용합니다. 아이겐 벡터의 특성 때문에 아이겐 값 $e^{2\pi i \theta}$는 제어 큐비트의 위상으로 "킥백(kickback)"됩니다.
*   **정보 획득**: 
    -   마지막으로 제어 큐비트에 Hadamard 게이트를 다시 적용하고 측정하면, 측정 결과 $\|0\rangle$ 또는 $\|1\rangle$의 확률이 $\cos^2(\pi \theta)$ 및 $\sin^2(\pi \theta)$와 같이 $\theta$에 의존하게 됩니다. 이를 통해 $\theta$에 대한 **부분적인 정보**를 얻을 수 있습니다.
*   **반복을 통한 정보 증가**: 
    -   제어 U 연산을 $k$번 반복하면 아이겐 값이 $e^{2\pi i k \theta}$로 변하며, 이는 $\theta$를 $k\theta$로 효과적으로 바꾸는 것과 같습니다. 이를 통해 $\theta$에 대한 추가 정보를 얻을 수 있습니다.

### **4. 일반화된 위상 추정 절차**

정확한 $\theta$ 값을 얻기 위해, 위상 킥백 아이디어를 **여러 제어 큐비트**로 확장합니다.
*   **회로 구성**: 
    -   $m$개의 제어 큐비트 각각에 Hadamard 게이트를 적용하여 중첩 상태를 만듭니다. 각 제어 큐비트는 유니타리 연산 $U$의 다른 거듭제곱($U, U^2, U^4, \dots, U^{2^{m-1}}$)을 제어합니다.
*   **양자 푸리에 변환(Quantum Fourier Transform, QFT)**: 이 단계 후, 제어 큐비트들은 $\theta$에 대한 정보를 위상으로 인코딩한 상태가 됩니다. 이 정보를 표준 기저에서 측정할 수 있도록 변환하기 위해, 제어 큐비트들에 **역(Inverse) 양자 푸리에 변환(QFT$^\dagger$)**을 적용합니다.
    *   **QFT의 역할**: QFT는 고전적인 이산 푸리에 변환(Discrete Fourier Transform)의 양자 버전이며, 중첩된 양자 상태에 적용됩니다.
    *   **QFT 구현**: $N=2^m$ 차원의 QFT는 $m$ 큐비트에 대해 **$O(m^2)$ 게이트**를 사용하여 효율적으로 구현될 수 있습니다.
*   **측정**: 
    -   QFT$^\dagger$ 적용 후 제어 큐비트들을 표준 기저에서 측정하면, $\theta$의 근사값 $y/2^m$에 해당하는 $y$를 높은 확률로 얻을 수 있습니다.
*   **정확도 및 신뢰도**:
    *   **정밀도**: 제어 큐비트 $m$의 수를 늘릴수록 $\theta$의 근사값은 더욱 정확해집니다.
    *   **확률**: 가장 좋은 근사값을 얻을 확률은 **40% 이상**입니다. 이 절차를 여러 번 반복하여 가장 자주 나타나는 결과를 취함으로써 높은 신뢰도로 매우 정확한 $\theta$ 추정치를 얻을 수 있습니다.

### **5. 쇼어 알고리즘(Shor's Algorithm)과 정수 인수분해**

위상 추정은 **정수 인수분해** 문제를 해결하는 **쇼어 알고리즘**의 핵심 서브루틴입니다.
*   **중간 단계: 오더 찾기 문제(Order Finding Problem)**: 
    *   쇼어 알고리즘은 정수 인수분해를 **오더 찾기 문제**로 변환합니다.
    *   **정의**: 
        -   두 양의 정수 $a$와 $N$ ($gcd(a,N)=1$)이 주어졌을 때, $a^r \equiv 1 \pmod N$을 만족하는 가장 작은 양의 정수 $r$을 찾는 문제입니다. 이 $r$을 $a$의 **오더(order)**라고 합니다.
    *   **난이도**: 
        -   오더 찾기 문제는 고전 컴퓨터로는 효율적으로 풀 수 없다고 알려져 있으며, 이 문제를 효율적으로 풀 수 있다면 정수 인수분해도 효율적으로 해결할 수 있습니다.
*   **오더 찾기 문제를 위한 위상 추정**:
    *   **모듈러 지수 연산자 $M_a$**: 
        -   $x \mapsto ax \pmod N$으로 정의되는 유니타리 연산자 $M_a$를 구성합니다.
    *   **아이겐 값과 오더의 관계**: 
        -   $M_a$의 아이겐 값은 오더 $r$과 밀접하게 관련되어 있습니다. $M_a$의 아이겐 벡터에 해당하는 아이겐 값은 $\omega_r^j = e^{2\pi i j/r}$ 형태를 가지며, 여기서 $j$는 0부터 $r-1$ 사이의 정수입니다.
    *   **아이겐 벡터 준비의 어려움**: 
        -   직접 아이겐 벡터를 준비하기 어렵기 때문에, 대신 표준 기저 상태 $\|1\rangle$을 사용합니다. $\|1\rangle$은 여러 아이겐 벡터의 균일한 중첩 상태이므로, 위상 추정을 수행하면 임의의 $j$에 대해 $j/r$의 근사값을 얻게 됩니다.
    *   **고전 후처리**: 
        -   얻어진 $j/r$의 근사값으로부터 고전적인 **연분수 알고리즘(Continued Fraction Algorithm)**을 사용하여 오더 $r$을 효율적으로 복구할 수 있습니다.
*   **비용 문제 해결: 모듈러 지수화 트릭(Modular Exponentiation Trick)**:
    *   **문제**: 
        -   위상 추정 회로에서 $U^{2^k}$와 같은 높은 거듭제곱의 연산이 필요합니다. $U$를 단순히 반복하면 회로의 크기가 기하급수적으로 커져 비효율적입니다.
    *   **해결책**: 
        -   각 $k$에 대해 $a^{2^k} \pmod N$을 **고전 컴퓨터로 먼저 계산**하여 $b$라는 숫자를 얻습니다. 그리고 $U^{2^k}$ 대신 $M_b$ 회로를 사용합니다. 이 트릭 덕분에 제어된 유니타리 연산의 비용이 기하급수적으로 증가하는 것을 막을 수 있습니다.
*   **쇼어 알고리즘의 총 비용**: 
    -   $N$을 이진 표기법으로 나타내는 데 필요한 비트 수($n$)에 대해, 쇼어 알고리즘은 **$O(n^3)$의 다항식 시간 복잡도**를 가집니다. 이는 고전 알고리즘보다 훨씬 효율적입니다.


**결론**: 쇼어 알고리즘은 양자 위상 추정이라는 강력한 도구를 사용하여 정수 인수분해라는 난해한 문제를 효율적으로 해결하며, 양자 컴퓨터의 잠재력을 보여주는 중요한 예시입니다. 이 개념들을 이해하는 데 시간이 걸릴 수 있으니, 반복해서 학습하는 것이 도움이 될 것입니다.

## 5. IBM 양자 하드웨어의 진화와 미래

- 출처:[IBM 양자 하드웨어의 진화와 미래](https://www.youtube.com/watch?v=0eTmqj5nf7c&list=PLOFEBzvs-VvoIfbpOb_geVnwFmbW6ij0m&index=5)


**IBM 양자 하드웨어: 과거, 현재, 그리고 미래**
*   이 프레젠테이션은 IBM Quantum의 양자 컴퓨팅 하드웨어 개발 여정과 미래 계획을 다루고 있습니다. 특히, 양자 정보 전달자인 **큐비트(cubit)**의 종류, 지난 10년간의 **공학적 발전**, 그리고 **오류 보정 양자 컴퓨터**를 구축하기 위한 미래 로드맵에 초점을 맞춥니다.


### **1. 양자 정보와 큐비트의 기본 이해**

*   **고전 정보 vs. 양자 정보**: 
    -   고전 컴퓨터는 이진 상태(0 또는 1)를 가진 정보 캐리어(예: 전압)를 사용, 양자 컴퓨터는 **힐베르트 공간(Hilbert space)** 내의 모든 상태를 인코딩할 수 있는 정보 캐리어, 즉 **큐비트**를 필요로 함.
*   **유용한 양자 컴퓨터의 조건**: 
    -   큐비트 외에도, 다중 큐비트 상태를 인코딩하고, 보편적인 게이트 세트를 통해 임의의 연산을 수행하며, 양자 정보가 충분히 오래 유지(즉, **결맞음(coherence)** 유지)되어야 합니다. 또한, 큐비트 상태를 효율적으로 읽어낼 수 있어야 합니다. 이런 조건들은 **디빈첸조 기준(DiVincenzo criteria)**이라고 함.
*   **초전도 전기 회로 선택 이유**: IBM Quantum은 **초전도 전기 회로**를 사용하여 양자 컴퓨터를 구축합니다.
    *   **낮은 손실**: 
        -   초전도체는 저항이 없어 손실(dissipation)이 거의 없습니다.
    *   **설계 및 확장성**: 
        -   일반적인 전기 회로처럼 설계하고 제조, 큐비트를 추가하여 확장성이 좋음.
    *   **비선형 요소**: 
        -   고전 논리의 트랜지스터처럼, 초전도 회로에는 **조셉슨 접합(Josephson junction)**이라는 고유의 비선형 요소가 있어 큐비트의 핵심을 이룹니다.
    *   **단점**: 
        -   밀리켈빈(millikelvin) 온도에서 작동해야 하지만, 대부분의 양자 컴퓨팅 플랫폼도 냉각이 필요합니다.

*   **트랜스몬 큐비트(Transmon Qubit)**:
    *   **구성**: 
        -   약 20년 전 제안된 트랜스몬 큐비트는 **조셉슨 접합**과 **커패시터**로 이루어져 있습니다. IBM은 패들 모양의 커패시터와 그 사이에 얇은 비전도성 장벽을 가진 조셉슨 접합을 사용합니다.
    *   **작동 원리**: 
        -   이 구조는 **비선형 발진기(nonlinear oscillator)**처럼 작동하며, 에너지 준위 간 간격이 고르지 않습니다 (예: 0과 1 사이의 에너지 준위가 1과 2 사이와 다름). 이 비선형성 덕분에 마이크로파로 0-1 전이만 선택적으로 구동하여 양자 연산을 수행할 수 있습니다.
    *   **장점**: 
        -   환경의 전기적 전하 노이즈(charge noise) 변동에 **지수적으로 둔감하여** **긴 결맞음 시간(long coherence times)**을 가집니다.

### **2. 공명기(Resonators)의 역할**

*   **정의**: 
    -   공명기는 선형 인덕터와 커패시터로 구성된 공명 회로로, 트랜스몬과 달리 모든 에너지 준위 간 간격이 동일합니다.
*   **활용**:
    1.  **큐비트 상태 감지(Readout)**: 
        -   공명기를 트랜스몬 큐비트에 약하게 결합시키면, 트랜스몬 상태에 따라 공명기의 주파수가 미세하게 변합니다. 이를 이용해 큐비트 상태를 읽어낼 수 있습니다.
    2.  **큐비트 보호**: 
        -   공명기의 주파수를 트랜스몬과 비공명(off-resonant) 상태로 만들면, 트랜스몬이 광자를 공명기로 방출하는 것을 막아 붕괴를 방지할 수 있습니다.
    3.  **단일 큐비트 게이트 구동**: 
        -   공명기를 사용하여 트랜스몬과 공명 주파수로 고출력 마이크로파를 보내 단일 큐비트 게이트를 구동할 수 있습니다.


### **3. 10년 전 시스템과 엔지니어링 과제**

*   **초기 시스템 (10년 전)**:
    *   **규모**: 
        -   가정용 냉장고 크기의 랙에 가득 찬 마이크로파 전자 장비가 약 10개의 큐비트를 제어했습니다.
    *   **환경**: 
        -   희석 냉장고(dilution fridge) 안에서 양자 칩은 절대 영도에 가까운 20mK(밀리켈빈)에서 작동했으며, 동축 케이블을 통해 신호를 주고받았습니다.
    *   **큐비트 칩**: 
        -   인쇄 회로 기판(PCB)에 약 10개의 큐비트가 장착된 작은 칩이 있었습니다.
*   **엔지니어링 과제**: 
    -   오류 보정 양자 컴퓨터나 유틸리티 규모의 워크로드를 지원하기 위해서는 **패키징, 케이블링, 상온 전자 장비** 등 다양한 분야에서 스케일링을 위한 공학적 난제들을 해결해야 했습니다.


### **4. 지난 10년간의 발전: 엔지니어링 난제 극복**

IBM은 지난 10년간 다음 분야에서 상당한 발전을 이루었습니다.

*   **제어 전자 장비(Control Electronics)**:
    *   **소형화 및 비용 절감**: 과거에는 5개 큐비트 제어에 랙 하나가 필요했지만, 현재는 동일한 공간에 80배 더 많은 큐비트를 제어할 수 있는 하드웨어를 개발하여 공간과 비용을 크게 줄였습니다.
*   **배선(Wiring)**:
    *   **고밀도 냉동 유연 배선**: 기존 동축 케이블 대신 **극저온 유연 배선(cryogenic flexible wiring)**을 도입하여 신호 밀도를 70% 높이고, 부품 수를 줄여 시스템의 복잡성과 비용을 낮췄습니다.
*   **패키징(Packaging)**:
    *   **1세대 (와이어 본딩)**: 
        -   큐비트 칩을 PCB에 와이어 본딩하는 방식은 선형 또는 링 형태의 큐비트 토폴로지에만 적합했습니다.
    *   **2세대 (플립칩 기술)**: 
        -   큐비트 칩과 **인터포저 칩(interposer chip)**을 분리하고 초전도 범프 본드(bump bond)로 연결하는 방식입니다. 인터포저 칩은 신호 라우팅 및 리드아웃 공명기 배치에 사용되며, 최근 허밍버드(Hummingbird) 프로세서에 적용되었습니다. 이 방식은 근접 연결(nearest neighbor coupling) 아키텍처를 가능하게 했지만, 신호가 차폐되지 않아 혼선(crosstalk)이 발생할 수 있었습니다.
    *   **3세대 (다층 배선 기술)**: 
        -   인터포저 칩 하단에 **다층 금속 및 유전체 배선**을 도입하여 신호를 차폐된 방식으로 라우팅합니다. **실리콘 관통 전극(Through-Substrate Vias, TSVs)**을 사용하여 큐비트 위치로 신호를 전달하며, CMOS 패키징 기술을 활용하여 아키텍처 스케일링에 크게 기여했습니다. 이 기술 덕분에 큐비트 수가 2.5배 증가해도 큐비트 칩 면적은 1.7배만 증가했습니다 (예: Osprey에서 Condor 프로세서).
*   **양자 칩 성능 (큐비트 및 게이트)**:
    *   **큐비트 수 증가**: 
        -   팔콘(Falcon, 27 큐비트)에서 시작하여 이글(Eagle, 127 큐비트), 헤론(Heron, 133/156 큐비트)으로 큐비트 수가 지속적으로 증가했습니다.
    *   **오류율 감소**: 
        -   지난 7년간 큐비트 오류율을 10배 줄였으며, 현재 최고의 게이트는 10^-3 미만의 오류율을 달성하고 있습니다.
    *   **헤론 프로세서의 발전**: 
        -   **조절 가능한 커플러(tunable coupler) 아키텍처**를 도입하여 **혼선(crosstalk)을 크게 줄였고**, 게이트 시간을 5~6배 단축하여 게이트 오류율을 낮추고, 여러 게이트를 동시에 실행할 때 견고성을 높였습니다.


### **5. 미래 계획: 오류 보정 양자 컴퓨터를 향하여**

IBM의 미래 로드맵은 혁신 로드맵과 개발 로드맵으로 나뉘며, 각 "새 이름"의 프로세서가 특정 기술 개발을 목표로 합니다.

*   **새로운 오류 보정 코드**: IBM 팀은 **"Gross code"**라는 양자 오류 보정 코드군을 개발했습니다. 이 코드는 기존 표면 코드(surface code)와 동일한 오류 임계값을 달성하면서도 필요한 **물리적 큐비트 수를 90% 줄일 수 있습니다** (표면 코드 1,400개 대비 Gross code 144개).
    *   **과제**: Gross code는 **장거리 연결(long-range couplings)**을 필요로 하는데, 이는 기존의 근접 연결 위주 아키텍처에서 벗어나 "평면을 깨는(breaking the plane)" 복잡한 6방향 연결을 구현해야 함을 의미합니다.

*   **오류 보정 하드웨어 구현을 위한 4가지 노력**:
    1.  **연결성 증가**:    
        -   6방향으로 연결된 큐비트 노드를 구현하고, 결맞음 저하 없이 우수한 게이트 오류율을 유지하는 것을 목표로 합니다. 이미 7개 큐비트로 구성된 장치를 통해 100 마이크로초 이상의 결맞음 시간과 3x10^-3 ~ 5x10^-3 범위의 게이트 오류율을 달성했습니다.
    2.  **장거리 커플러 실현**:
        -    칩 내에서 멀리 떨어진 큐비트 간에 물리적으로 장거리 커플러를 구현하는 것입니다. 6mm에서 18mm 길이의 조절 가능한 커플러를 테스트하여 헤론 프로세서의 중앙값보다 더 나은 게이트 오류율을 보여주었습니다.
    3.  **커플러 교차**: 
        -   칩 내에서 커플러들이 서로 교차하는 것을 성능 저하 없이 구현하여 2D를 넘어서는 연결성을 가능하게 하는 핵심 기술입니다.
    4.  **자동화된 설계 도구 개발**: 
        -   회로의 복잡성이 증가함에 따라, 수동 설계가 불가능해지므로, 기존 CMOS 설계 기술을 활용한 자동화된 설계 워크플로우를 개발하고 있습니다.

*   **더 큰 양자 컴퓨터 (다중 칩 기술)**:
    *   **C-커플러**: 
        -   단일 칩 내의 장거리 커플러를 의미합니다.
    *   **M-커플러**: 
        -   나란히 배치된 여러 칩을 연결하는 기술입니다 (예: Crossbill 장치). 칩 간 게이트에서 1.5x10^-3의 낮은 오류율을 달성했습니다.
    *   **L-커플러**: 
        -   크기 제약으로 인해 동일한 패키지에 모든 칩을 넣을 수 없을 때, 동축 케이블과 같은 장거리 초전도 링크를 통해 칩을 연결하는 기술입니다 (예: Flamingo 장치). 60cm에서 1m 길이의 링크를 통해 연결된 큐비트에서 현재 6.7x10^-2의 오류율을 보이고 있으며, 이를 개선하기 위해 노력 중입니다.

이러한 기술들은 향후 **스털링(Starling)**, **블루 제이(Blue Jay)**와 같은 더 크고 많은 큐비트를 가진 프로세서에 통합될 예정입니다.

**결론적으로**, IBM Quantum은 지난 10년간 제어 전자 장비, 배선, 패키징, 그리고 양자 칩 성능 전반에 걸쳐 혁신적인 공학적 진전을 이루었습니다. 앞으로는 오류 보정 양자 컴퓨팅을 위해 장거리 칩 내 커플러, 새로운 설계 도구, 그리고 다중 칩 기술을 개발하는 데 주력하고 있습니다. 이는 미래 양자 컴퓨터의 가능성을 열어가는 매우 중요한 여정입니다.

## 6. 실용적인 양자 알고리즘: 변분 양자 알고리즘(VQA) 개요

- 출처:[실용 양자 알고리즘](https://www.youtube.com/watch?v=pWCiaE-9UGM&list=PLOFEBzvs-VvoIfbpOb_geVnwFmbW6ij0m&index=6)

이 세션에서는 **변분 양자 알고리즘(Variational Quantum Algorithms, VQAs)**이 무엇인지, 왜 중요한지, 그리고 어떻게 구성되며 어떤 예시들이 있는지, 마지막으로 현재 직면한 도전과제는 무엇인지 다룹니다.

### 1. 변분 양자 알고리즘(VQA)의 중요성 및 동기

현재 우리가 사용할 수 있는 **초기 양자 하드웨어(near-term quantum hardware)**는 다음과 같은 제약 사항을 가지고 있습니다:
*   **제한된 큐비트 수**: 
    -   IBM 장치는 100개 이상의 큐비트를 보유하지만, Shur의 알고리즘과 같은 복잡한 알고리즘을 완전히 구현하기에는 여전히 부족합니다.
*   **오류 수정 부재**: 
    -   잡음이 많은 장치에서 작동해야 하므로, 계산 결과에 잡음이 영향을 미칩니다.
*   **제한된 알고리즘 깊이**: 
    -   너무 많은 게이트는 알고리즘이 무작위 양자 잡음을 출력하게 할 수 있으므로, 알고리즘 깊이가 제한됩니다.
*   **제한된 큐비트 연결성**: 
    -   사용 중인 특정 장치의 토폴로지(예: IBM 장치의 헤비 헥스 토폴로지)에 맞춰야 합니다.

이러한 제약 사항 때문에 우리는 **잡음 내성(noise resilient)**이 있고, **얕으며(shallow)**, **적응 가능한(adaptable)** 알고리즘이 필요합니다. 이러한 요구 사항을 충족하는 좋은 아이디어는 **하이브리드 접근 방식(hybrid approach)**입니다.
*   **양자 처리 장치(QPU)**: 
    -   상태 준비, 얽힘 생성, 측정과 같은 양자 고유의 작업에 사용됩니다.
*   **고전 컴퓨터**: 
    -   매개변수 최적화(parameter optimization) 및 후처리(post-processing)와 같은 작업에 사용.

**변분 양자 알고리즘(VQAs)**은 이 하이브리드 접근 방식에 포함되며, 특히 **고전 컴퓨터를 매개변수 최적화에 활용**합니다. VQAs는 양자 컴퓨터를 활용하는 데 중요한 역할을 해왔지만, **확장성과 신뢰성 측면에서 여전히 도전 과제**를 안고 있습니다. VQAs는 다양한 분야에 적용될 수 있으며, 이 발표에서는 특히 다음 세 가지 주요 응용 분야에 초점을 맞춥니다:
*   **바닥 상태 찾기**: 
    -   양자 화학, 응집 물질, 고에너지 물리학과 같은 시스템의 해밀토니안(Hamiltonian)의 바닥 상태(ground state)를 찾는 데 사용됩니다. **VQE(Variational Quantum Eigensolver)**가 대표적인 예시입니다.
*   **조합 최적화 문제**: 
    -   **QAOA(Quantum Approximate Optimization Algorithm)**가 이 분야의 예시입니다.
*   **양자 머신러닝(QML)**: 
    -   변분 양자 분류기(Variational Quantum Classifiers)나 생성 모델(Generative Models)과 같은 알고리즘이 포함됩니다.

### 2. 일반적인 변분 양자 알고리즘의 구조

일반적인 VQA는 양자 처리 장치(QPU)와 고전 컴퓨터(classical computer) 간의 반복적인 루프를 통해 작동합니다.

1.  **QPU에서 양자 회로 실행 및 측정**:
    *   **매개변수화된 양자 회로(Parameterized Quantum Circuit)**: 
        -   `Ansatz`라고 불리며, 게이트의 종류와 배치를 정의합니다. `Ansatz`는 고전 매개변수(주로 회전 각도)에 따라 달라집니다. `Ansatz`의 선택은 알고리즘 성능에 큰 영향을 미칩니다.
    *   **초기 매개변수 선택**: 
        -   `Ansatz`에 대한 초기 각도를 정의하는 것으로 시작합니다. 매개변수는 종종 0에서 2π 사이로 제한될 수 있습니다.
    *   **트랜스파일링(Transpiling)**: 
        -   매개변수화된 양자 회로를 실제 양자 장치에서 실행할 수 있도록 변환하는 과정입니다. 이는 효율적인 큐비트 매핑, 스왑 게이트 삽입(연결성이 맞지 않을 경우), 백엔드 고유 게이트(native gates)로 변환하는 것을 포함합니다. 이 과정에서 회로 깊이가 증가할 수 있습니다.
    *   **측정(Measurement)**: 
        -   일반적으로 관측 가능한(observable) 값의 기댓값(expectation value)을 측정합니다. 이 관측값은 문제에 의해 주어집니다(예: 에너지 계산 시 해밀토니안). 기댓값을 계산하기 위해 회로를 여러 번 실행하며(shots), 이 데이터를 사용하여 기댓값을 재구성합니다. 복잡한 관측값의 경우, 폴리 스트링(Pauli strings)의 선형 중첩으로 표현되며, 측정 전략(예: 교환 가능한 항들을 그룹화)을 사용하여 회로 실행 횟수를 줄일 수 있습니다.

2.  **고전 컴퓨터에서 비용 함수 평가 및 매개변수 최적화**:
    *   **후처리(Post-processing)**: 
        -   측정 결과에 대해 오류 완화(error mitigation) 기법을 적용하여 잡음이 있는 장치에서 얻은 신호를 복구할 수 있습니다.
    *   **비용 함수(Cost Function) 평가**: 
        -   대부분의 경우, 측정된 관측값의 기댓값이 비용 함수가 되며, 이 값을 최소화하는 것이 목표입니다 (예: 바닥 상태 에너지 최소화).
    *   **매개변수 최적화(Parameter Optimization)**: 
        -   비용 함수를 최소화하기 위해 매개변수화된 양자 회로의 매개변수를 반복적으로 변경합니다. 다양한 고전 최적화 기법이 사용될 수 있습니다.
        *   **경사 기반(Gradient-based) 최적화**: 
            -   비용 함수의 기울기를 계산하여 최소값 방향으로 이동합니다 (예: 경사 하강법 Gradient Descent). 기울기를 계산하기 위해 추가적인 회로 실행이 필요할 수 있습니다. SPSA, Adam과 같은 개선된 방법도 있습니다.
        *   **경사 비의존적(Gradient-free) 최적화**: 
            -   기울기를 계산하지 않고 매개변수를 업데이트합니다 (예: 유전 알고리즘 Genetic Algorithms, 차분 진화 Differential Evolution).
        *   **지역 최적화(Local Optimizers) vs. 전역 최적화(Global Optimizers)**: 
            -   지역 최적화기는 현재 지점의 주변 영역만 탐색하여 지역 최소값에 갇힐 수 있습니다. 전역 최적화기는 전체 에너지 지형을 탐색하여 지역 최소값에 갇히는 것을 피할 수 있습니다.
    *   **하이퍼파라미터(Hyperparameters) 선택**: 
        -   최적화기 선택 외에도 반복 횟수, 스텝 크기, 수렴 조건 등 다양한 하이퍼파라미터를 결정해야.

이러한 단계들을 반복하여 원하는 솔루션으로 수렴할 때까지 루프를 실행합니다. VQAs는 많은 휴리스틱을 포함하지만, 이는 동시에 **적응성과 유연성**을 제공합니다.

### 3. 변분 양자 알고리즘의 예시

#### **3.1. 변분 양자 고유값 풀이(VQE: Variational Quantum Eigensolver)**
*   **목적**: 
    -   시스템의 **바닥 상태 에너지(ground state energy)의 상한선을 추정**하는 데 사용됩니다.
*   **기본 원리**: 
    -   **변분 원리(variational principle)**에 기반합니다. 임의의 양자 상태의 기댓값 에너지는 항상 바닥 상태 에너지보다 크거나 같으므로, 이 에너지를 최소화함으로써 바닥 상태에 수렴할 수 있습니다.
*   **적용 분야**: 
    -   양자 화학(분자의 바닥 상태 에너지 파악, 약물 발견), 재료 과학, 고에너지 물리학 등에 활용됩니다.
*   **도전 과제 (양자 화학 예시)**:
    *   **복잡한 해밀토니안**: 
        -   72 큐비트 분자의 해밀토니안은 수백만 개의 폴리 스트링으로 구성될 수 있습니다.
    *   **측정 병목 현상(Measurement Bottleneck)**: 
        -   화학적 정밀도(10^-7)를 달성하기 위해 엄청난 수의 회로 실행(예: 10^14회)이 필요하여, 수십 년이 걸릴 수 있습니다.
*   **Ansatz 선택 전략**:
    *   **하드웨어 효율적 Ansätze (Hardware-efficient Ansätze)**: 
        -   문제에 대한 물리적 통찰 없이 하드웨어에 잘 매핑되도록 설계됩니다. 충분한 얽힘을 생성하여 힐베르트 공간의 다양한 영역에 도달하기를 희망합니다 (예: Real Amplitudes Ansatz).
    *   **물리적으로 동기 부여된 Ansätze (Physically-motivated Ansätze)**: 
        -   문제의 물리적 특성을 고려하여 설계됩니다 (예: Unitary Coupled Clusters Singles and Doubles, UCC). 이는 정확한 해를 목표로 하지만, 회로 깊이가 매우 깊어질 수 있습니다.
    *   **하드웨어와 문제 간의 절충 (예: Local Unitary Coupled Cluster)**: 
        -   UCC의 아이디어를 가져오면서 하드웨어 연결성에 근접하도록 근사화합니다.
*   **Adapt-VQE**: 
    -   특히 물리적 직관이 부족한 경우 (예: Schwinger 모델), `Ansatz`를 점진적으로 구축합니다. 특정 대칭성을 존중하고 확장 가능한 연산자 풀을 정의한 다음, 비용 함수에 가장 큰 영향을 미치는 연산자를 추가하여 `Ansatz`를 최적화합니다. 이를 통해 매개변수 수를 적게 유지하고 회로 깊이를 줄일 수 있습니다.

#### **3.2. 양자 근사 최적화 알고리즘(QAOA: Quantum Approximate Optimization Algorithm)**
*   **목적**: 
    -   **조합 최적화 문제(combinatorial optimization problems)**를 해결하는 데 유용합니다 (예: MaxCut 문제).
*   **기본 원리**: 
    -   **단열 양자 컴퓨팅(adiabatic quantum computing)**과 **트로터화된 시간 진화(Trotterized time evolution)**의 원리를 결합합니다.
    *   단열 양자 컴퓨팅: 
        -   쉬운 해밀토니안의 바닥 상태에서 시작하여, 풀고자 하는 문제의 해밀토니안의 바닥 상태로 천천히 진화하여 최종 해를 얻습니다.
    *   트로터화된 시간 진화: 
        -   큰 진화 연산자를 작은 시간 간격의 게이트 시퀀스로 근사합니다.
*   **MaxCut 문제 예시**: 
    -   그래프에서 가장 많은 수의 에지를 자르는 이분할(bipartition)을 찾는 문제입니다. 이 문제는 Ising 해밀토니안의 바닥 상태를 찾는 문제로 인코딩될 수 있습니다.
*   **QAOA의 `Ansatz`**: 
    -   혼합 해밀토니안(mixing Hamiltonian)과 비용 해밀토니안(cost Hamiltonian)의 시간 진화 층으로 구성됩니다. 이 때, 시간 간격(delta t)이 변분 매개변수가 됩니다. 초기 상태는 혼합 해밀토니안의 쉬운 바닥 상태(예: 모든 큐비트가 중첩된 상태)로 설정됩니다.
*   **결과**: 
    -   해밀토니안의 기댓값 대신, 최종 상태에서 비트 문자열을 샘플링하여 가장 높은 확률을 가진 비트 문자열을 통해 해(예: MaxCut의 이분할)를 식별합니다.
*   **장점**: 
    -   매개변수(감마 및 베타)가 큐비트 수에 따라 증가하지 않습니다.
*   **개선 사항**: 
    -   초기화 지점 개선(warm-start QAOA), 혼합 해밀토니안 선택, 하드웨어 구현 최적화 등이 연구되고 있습니다.

#### **3.3. 양자 머신러닝(QML: Quantum Machine Learning) 예시**
*   **변분 양자 분류기(Variational Quantum Classifiers)**:
    *   목표: 주어진 데이터(대부분 고전 데이터)를 분류합니다.
    *   작동 방식: 데이터를 양자 상태로 인코딩(feature maps 사용)한 후, 매개변수화된 양자 회로를 적용하고 훈련시킵니다. 비용 함수는 원하는 레이블과 얻은 레이블 간의 차이입니다.
*   **생성 모델(Generative Models)**:
    *   목표: 기존 데이터 세트의 확률 분포로부터 새로운 데이터를 생성합니다.
    *   작동 방식: 데이터의 확률 분포를 양자 상태의 확률 분포로 인코딩한 다음, 모델이 이와 동일한 확률 분포를 출력하도록 매개변수화된 양자 회로를 훈련시킵니다.

### 4. 변분 양자 알고리즘의 도전 과제 및 미해결 문제

VQA의 각 단계에는 고유한 도전 과제와 미해결 질문들이 존재합니다.

1.  **매개변수 최적화(Parameter Optimization)**:
    *   **바렌 고원(Barren Plateaus)**: 
        -   힐베르트 공간의 차원이 매우 높기 때문에 대부분의 영역에서 기울기가 소실되는 현상입니다. 이는 최적화 방향을 찾기 어렵게 만듭니다.
    *   **지역 최소값(Local Minima)**: 
        -   에너지 지형이 복잡하여 최적화 과정에서 전역 최소값이 아닌 지역 최소값에 갇힐 수 있습니다.
    *   **잠재적 해결책**:
        *   **단계별 훈련(Layer-by-layer training)**: `Ansatz`의 각 층을 순차적으로 훈련합니다.
        *   **좋은 초기화**: 사전 고전 계산을 통해 좋은 초기 매개변수를 찾는 것이 매우 중요하고 효과적.
        *   **얕은 회로 및 지역 측정**: 특정 조건(얕은 회로, 지역 측정, 특정 대칭성 등)에서 바렌 고원이 나타나지 않는 모델이 있지만, 이들은 고전적으로 시뮬레이션 가능할 수 있어 양자 이점 측면에서 흥미롭지 않을 수 있습니다.

2.  **ISA 회로 실행 (하드웨어 제약)**:
    *   **잡음, 제한된 연결성, 제한된 큐비트 수**: 
        -   초기 양자 하드웨어의 근본적인 한계입니다.
    *   **잠재적 해결책**:
        *   **적응 가능한 `Ansatz`**: Adapt-VQE와 같이 하드웨어에 적응할 수 있는 `Ansatz`를 구축합니다.
        *   **하드웨어 인지 `Ansatz`**: 하드웨어 연결성 및 잡음 모델을 고려하여 `Ansatz`를 설계합니다 (예: 하드웨어 효율적 `Ansatz` 또는 Local UCC).
        *   **오류 완화 기법**: 잡음이 알고리즘 성능에 미치는 영향을 이해하고 이를 완화하는 기술을 적용합니다.

3.  **매개변수화된 양자 회로(`Ansatz`) 정의**:
    *   **표현력(Expressibility)과 깊이/훈련 가능성 간의 절충**: 
        -   `Ansatz`의 표현력(생성할 수 있는 상태의 수)을 높이려면 더 많은 게이트와 매개변수가 필요하지만, 이는 회로 깊이를 증가시켜 잡음이 있는 장치에서의 실행과 바렌 고원 문제에 영향을 미침.
    *   **문제 동기적 `Ansatz`와 하드웨어 동기적 `Ansatz` 간의 절충**: 
        -   문제의 물리적 특성에서 영감을 받은 `Ansatz`(예: UCC)와 하드웨어의 연결성 및 강점을 고려한 `Ansatz` 사이에서 균형을 찾아야 합니다. 두 접근 방식을 결합하는 것이 최선일 수 있습니다.
    *   **분수 게이트(Fractional gates)**: 
        -   특정 게이트를 하드웨어에서 직접 구현하여 트랜스파일링 시 게이트 분해를 피하고 회로 깊이를 낮게 유지할 수 있습니다.

4.  **측정 병목 현상(Measurement Bottleneck)**:
    *   **복잡한 해밀토니안**: 
        -   양자 화학 해밀토니안과 같이 관측값이 엄청나게 많은 폴리 스트링으로 구성될 때 발생합니다.
    *   **잠재적 해결책**:
        *   **연산자 그룹화(Operator grouping)**: 
            -   교환 가능한 폴리 항들을 그룹화하여 동시에 측정함으로써 회로 실행 횟수를 줄입니다. 또한, 계수가 큰 항에 더 많은 샷을 할당하는 등 측정 전략을 최적화할 수 있습니다.
        *   **기댓값 계산 회피**: 
            -   기댓값을 직접 계산하는 대신, 비트 문자열을 샘플링하고 고전 컴퓨터(또는 HPC)에서 후처리하여 연산자를 투영하고 대각화하는 **샘플 기반(sample-based) 알고리즘**이 유망한 대안으로 제시됩니다 (예: Sample-based Quantum Eigensolver).

변분 양자 알고리즘은 **잡음 내성(noise resilient), 얕은(shallow), 적응 가능한(adaptable)** 특성을 가지고 있어 **초기 양자 하드웨어(near-term quantum hardware)를 활용하는 데 핵심적인 역할**을 해왔습니다. 그러나 **확장성 및 신뢰성 측면에서 많은 미해결 과제**를 안고 있습니다.

미래에는 **하이브리드 양자-고전 접근 방식**이 더욱 중요해질 것이며, 매개변수 최적화를 넘어 특정 유형의 후처리에도 **고성능 컴퓨팅(HPC)**을 활용하는 방안이 모색될 것입니다. 이를 통해 양자 이점(quantum advantage)을 보여줄 수 있는 알고리즘으로 발전하기를 기대합니다.

## 7. 양자 컴퓨팅 실용 기술 소개

- 출처:[실용적인 양자 기술](https://www.youtube.com/watch?v=WlYJVrIq0ZY&list=PLOFEBzvs-VvoIfbpOb_geVnwFmbW6ij0m&index=7)

이 세션에서는 **근시일 내 양자 하드웨어에서 양자 알고리즘을 구현하는 방법**에 대해 설명합니다. 현재 사용 가능한 양자 장치의 성능을 최대한 활용하는 데 도움이 되는 **오류 완화(error mitigation) 및 오류 억제(error suppression) 기술**에 특히 중점을 둡니다.

### **1. 양자 컴퓨팅이 중요한 이유 (동기)**
양자 컴퓨팅은 단순히 고전 컴퓨팅보다 빠르거나 나은 버전이 아닙니다.
*   **고전 컴퓨터에게 어려운 문제**: 
    -   시스템 크기에 따라 기하급수적으로 또는 조합적으로 리소스가 증가하는 문제들(예: 소인수 분해).
*   **양자 컴퓨터의 장점**: 
    -   쇼어 알고리즘(Shor's algorithm)처럼 소인수 분해와 같은 문제에서 기하급수적인 속도 향상을 제공할 수 있습니다. 또한 양자 역학 시뮬레이션과 같은 문제는 양자 컴퓨터로 더 쉽게 접근할 수 있을 것으로 예상됩니다.
*   **스케일링의 중요성**: 
    -   20큐비트 이하의 시스템은 무차별 대입(brute force) 방식의 고전 기술로 시뮬레이션할 수 있으므로 새로운 이점을 제공하지 않습니다. IBM 양자 시스템은 이미 100큐비트 이상을 보유하고 있으며, 이러한 규모에서는 고전적인 무차별 대입 기술로는 양자 시스템의 작업을 재현할 수 없습니다.
*   **유틸리티(Utility) 영역**: 
    -   2023년 "유틸리티 논문"에서는 고전적인 무차별 대입 기술로는 계산할 수 없는 양자 컴퓨터 결과를 발표했습니다. 현재 우리는 고전 및 양자 기술 모두가 어려움을 겪고 있는 "유틸리티 영역"에 있으며, 양자 장치가 발전함에 따라 고전 컴퓨팅의 한계를 넘어설 것입니다.

**양자 컴퓨터의 흥미로운 활용 사례를 보려면 두 가지 발전이 필요합니다**:
1.  **알고리즘의 발전**: 
    -   실제 근시일 내 양자 하드웨어로 실행 가능한 회로 폭과 크기에 맞는 알고리즘이 필요합니다.
2.  **양자 하드웨어 및 소프트웨어의 발전**: 
    -   새로운 애플리케이션을 가능하게 해야 합니다. 이 발표는 **현재 사용 가능한 근시일 내 양자 하드웨어에 소프트웨어를 사용하는 방법**에 초점을 맞춥니다.

### **2. 양자 알고리즘 구현 단계 및 Qiskit 도구**
양자 알고리즘을 구현할 때 따라야 하는 4가지 주요 단계가 있으며, Qiskit은 각 단계에 유용한 도구와 애드온(add-ons)을 제공합니다.

1.  **문제 매핑 (Mapping the problem)**: 문제를 양자 회로 및 일련의 측정 가능한 값(observables)으로 매핑합니다.
    *   **Qiskit 도구**: 
        -   **Qiskit 회로 라이브러리(Circuit Library)**는 미리 준비된 회로와 게이트 집합을 제공합니다.
    *   **Qiskit 애드온**:
        *   **다중 곱 공식(Multiprod uct formulas)**: 
            -   회로의 깊이(depth)를 줄이기 위해 여러 트로터(trotter) 단계를 선형 조합으로 사용하여 전체 진화를 재현합니다.
        *   **AQC 텐서(AQC tensor)**: 
            -   회로의 첫 부분을 고전적으로 계산(예: 텐서 네트워크 알고리즘 사용)한 다음, 근사 양자 컴파일(Approximate Quantum Compiling)을 사용하여 이 상태를 더 적은 게이트로 회로에 매핑하여 깊이를 줄입니다.

2.  **회로 최적화 (Optimizing the circuit)**: 양자 실행을 위해 회로를 최적화하고 하드웨어에 맞게 변환(transpile)합니다.
    *   **Qiskit 도구**: 
        -   **트랜스파일러(transpiler)**는 회로를 대상 장치의 네이티브 게이트로 변환하고 최적화하여 회로 깊이가 너무 많이 증가하지 않도록 합니다.
    *   **Qiskit 애드온**:
        *   **회로 커팅(Circuit cutting)**: 너무 큰 회로를 더 작은 회로로 분할하여 하드웨어에서 더 잘 실행되도록 하지만, 재구성 오버헤드가 발생할 수 있습니다.
        *   **연산자 역전파(Operator backpropagation)**: 깊은 회로의 끝 부분을 측정 가능한 연산자에 흡수하여 회로 깊이를 줄입니다.

3.  **실행 (Execution)**: 회로를 실행하고 기대값(expectation values) 또는 샘플(samples)과 같은 출력을 얻습니다.
    *   **Qiskit 도구**: **프리미티브(Primitives)**인 샘플러(Sampler)와 추정기(Estimator)를 사용합니다.
        *   **샘플러**: 여러 번 측정하여 각 기저 상태의 확률을 얻고 히스토그램을 생성합니다.
        *   **추정기**: 연산자의 기대값을 직접 계산하며, 내부적으로는 샘플러를 사용하고 필요한 기저 변환을 수행합니다.
    *   **오류 억제 및 완화**: 이 단계에서 오류 억제 및 완화 기술을 지정할 수 있습니다.

4.  **사후 처리 (Post-processing)**: 양자 회로의 출력을 사후 처리하여 원하는 결과를 얻습니다.
    *   **Qiskit 도구**: 
        -   **quantum info 및 quantum visualization 패키지**를 제공합니다.
    *   **Qiskit 애드온**:
        *   **매트릭스 프리 측정 완화(Matrix-free measurement mitigation)**: 특정 문제 유형에 대해 측정 오류를 완화합니다.
        *   **SQD 알고리즘(Sample-based Quantum Dialization)**: 양자 컴퓨터에서 상태를 준비하고 샘플링한 다음, 고전 컴퓨터에서 이 샘플을 사용하여 해밀토니안을 투영하고 고전적인 대각화를 수행하여 분자의 바닥 상태 에너지를 얻습니다.

### **3. 노이즈가 많은 양자 하드웨어에서 실행**
현재의 양자 하드웨어는 노이즈가 많기 때문에 신뢰할 수 있는 결과를 얻기 위해서는 노이즈를 이해하고 다루는 것이 매우 중요합니다.

**노이즈의 유형**:
1.  **환경 노이즈(Environmental noise)**: 
-   깊고 희소한(sparse) 회로에 가장 중요하며, 큐비트가 오랫동안 유휴 상태일 때 발생합니다. (예: 큐비트의 환경과의 결합, 교차 간섭(cross-talk), 디코히어런스(decoherence)).
2.  **읽기 오류(Readout errors)**: 
-   불완전한 측정으로 인해 발생하며, 큐비트가 상태 1에 있는데 0으로 측정되거나 그 반대의 경우입니다. 얕은(shallow) 회로에 가장 중요합니다.
3.  **게이트 오류(Gate errors)**: 
-   큐비트에 대한 연산이 불완전하기 때문에 발생합니다. 깊고 밀도가 높은(dense) 회로에 더 중요하며, **2큐비트 게이트의 오류가 단일 큐비트 게이트보다 훨씬 큽니다 (약 10배)**. 대부분의 오류 완화/억제 기술은 2큐비트 게이트에 중점을 둡니다.

### **4. 오류 억제(Error Suppression) 및 오류 완화(Error Mitigation)**
오류 수정(error correction)이 아직 불가능하므로, 노이즈를 다루기 위해 이 두 가지 기술을 사용합니다.

*   **오류 억제**: 오류가 발생하지 않도록 방지하거나, 노이즈 유형을 수정하여 노이즈의 영향을 최소화합니다.
    *   **동적 디커플링(Dynamical decoupling)**: 
        -   유휴 큐비트를 바쁘게 유지하기 위해 단일 큐비트 게이트(예: X 게이트) 시퀀스를 삽입하여 교차 간섭과 같은 환경 노이즈를 줄입니다. Qiskit에서는 `options.dynamical_decoupling.enable=True`로 설정하고 시퀀스 유형을 정의하여 활성화할 수 있습니다.
    *   **폴리 트월링(Poly twirling)**: 
        -   임의의 노이즈 채널을 더 잘 제어할 수 있는 폴리 노이즈(Pauli noise)로 변환하는 것을 목표로 합니다. 게이트를 폴리 연산자(X, Y, Z) 사이에 끼워 넣고 무작위화하여 2큐비트 게이트에 연결된 노이즈를 폴리 채널로 바꿉니다. Qiskit에서는 `twirling.enable_gates=True`로 설정하여 활성화할 수 있으며, 오버헤드가 크지 않아 구현하는 것이 좋습니다.

*   **오류 완화**: 오류 발생을 허용하지만, 실행 중에 오류에 대해 학습하고 이를 보상하여 그 효과를 줄입니다. 이러한 기술은 **주로 기대값(Estimator)에만 유효**합니다.
    *   **T-Rex (Readout Error EXtraction)**: 
        -   읽기 오류의 영향을 되돌리려는 오류 완화 기술입니다. 측정값을 폴리 게이트 사이에 끼워 넣고 무작위화하여 전송 행렬을 대각화함으로써 읽기 오류를 완화합니다. Qiskit에서는 `measurement_mitigation.enable=True`로 설정하여 활성화할 수 있습니다.
    *   **제로 노이즈 외삽법(Zero Noise Extrapolation, ZNE)**: 
        -   원본 회로의 노이즈를 인위적으로 증폭시킨 다음, 이 증폭된 노이즈 인스턴스에서 회로를 실행하고, 노이즈 수준이 0일 때의 값을 외삽하여 얻는 기술입니다.
        *   **노이즈 증폭 방법**:
            *   **게이트 폴딩(Gate folding)**: 2큐비트 게이트를 여러 번 곱하여 노이즈 인자를 증가시킵니다.
            *   **확률적 오류 증폭(Probabilistic error amplification, PA)**: 노이즈 학습기(noise learner)를 사용하여 회로의 노이즈를 학습한 후, 목표 방식으로 노이즈를 주입하여 증폭합니다. 노이즈 학습기는 폴리 트월링이 필요하며, 장치의 노이즈 모델 파라미터를 학습합니다.
        *   **외삽(Extrapolation)**: 
            -   증폭된 노이즈 값들을 사용하여 선형, 지수 또는 다항식으로 0 노이즈 지점으로 외삽합니다. Qiskit에서는 `resilience.mitigation_zne.enable=True`로 설정하고, 노이즈 인자(noise factors)와 증폭기(amplifier) 및 외삽기(extrapolator)를 선택하여 활성화할 수 있습니다. ZNE는 강력하지만 외삽기 선택이 어려워 불안정할 수 있습니다.
    *   **확률적 오류 제거(Probabilistic Error Cancellation, PEC)**: 
        -   노이즈를 학습하고 이를 상쇄하기 위해 노이즈의 역함수를 구현하려는 아이디어에 기반합니다. 이론적으로는 매우 유망하지만, 노이즈의 역함수를 계산하는 것이 기하급수적으로 스케일링되어 구현 오버헤드가 큽니다. Qiskit에서는 `resilience.mitigation_pec.enable=True`로 설정하고 최대 오버헤드를 선택하여 활성화할 수 있습니다.

### **5. 기타 노이즈 처리 전략**
*   **검증 전략(Validation strategies)**: 대규모 큐비트에서 실행되는 양자 회로의 출력이 올바른지 확인할 고전적인 대안이 없을 때 유용합니다.
    *   **클리포드 회로(Clifford circuits)**: 
        -   비클리포드 회로를 클리포드화하여 고전적으로 계산 가능한 버전과 비교하여 회로가 잘 작동하는지에 대한 힌트를 얻습니다.
    *   **미러 회로(Mirror circuits)**: 
        -   회로와 그 역회로를 구현하여 초기 상태(예: 0000 상태)로 돌아가는지 확인하고, 이를 통해 오류 전파 방식을 이해합니다.
*   **사후 선택(Post-selection) 및 구성 복구(Configuration recovery)**: 비트 플립 오류를 감지하고 수정하는 데 사용됩니다.
    *   **구성 복구**: 
        -   양자 상태가 특정 대칭(예: 전자의 수 보존)을 만족해야 한다는 지식을 사용하여, 대칭을 만족하지 않는 비트 문자열(bit strings)을 수정하여 올바른 대칭 영역으로 되돌립니다.
    *   **사후 선택**: 
        -   올바른 대칭을 갖지 않는 비트 문자열을 단순히 버립니다.


양자 장치에는 환경 노이즈, 게이트 오류, SPAM(상태 준비 및 측정) 오류, 읽기 오류 등 다양한 유형의 노이즈가 있습니다. 이러한 **다양한 노이즈 유형을 대상으로 하는 오류 완화, 오류 억제 기술, 검증 전략, 사후 선택 및 구성 복구와 같은 기술들을 적절히 조합하고 언제 구현해야 하는지를 아는 것**이 알고리즘을 실행하고 신뢰할 수 있는 결과를 얻는 데 매우 중요합니다. 또한, **벤치마킹 및 장치 보정**을 통해 장치가 어떻게 작동하는지 이해하고 최상의 방식으로 회로를 실행하는 것이 중요합니다.

## 8. IBM 양자 컴퓨터의 성능 측정: 퀀텀 벤치마킹 소개

- 출처:[Quantum Benchmarking](https://www.youtube.com/watch?v=ew9vJ6b5x5E&list=PLOFEBzvs-VvoIfbpOb_geVnwFmbW6ij0m&index=8)


### 1. 양자 컴퓨팅의 기본 배경
양자 컴퓨터를 이해하기 위해서는 몇 가지 기본 개념을 알아야 합니다.
*   **큐비트(Qubits):** 
    -   기존 컴퓨터의 비트(0 또는 1)와 달리, 큐비트는 0과 1 상태의 중첩(superposition)으로 존재할 수 있습니다. 이러한 큐비트의 상태는 복소수 진폭을 가진 파동 함수로 설명되며, **블록 구(Bloch sphere)**라는 시각적인 도구를 사용해 표현할 수 있습니다. 블록 구 위에서 큐비트의 상태는 벡터로 나타납니다.
*   **양자 게이트(Quantum Gates):** 
    -   양자 게이트는 큐비트 상태에 작용하는 연산으로, 블록 구 상에서 상태 벡터를 회전시키는 **유니타리 연산(unitary operations)**입니다. 이상적인 게이트는 상태 벡터의 길이를 보존하고 정확한 양만큼 회전시킵니다.
*   **양자 잡음(Quantum Noise):** 
    -   실제 양자 시스템에서는 이상적인 게이트 연산이 어렵고, 다양한 잡음(noise)이 발생하여 큐비트의 상태를 손상시킵니다.
    *   **게이트 오작동(Gate Miscalibration):** 
        -   펄스(pulse)의 회전 축이 잘못 설정되거나 동작이 부정확해지는 경우.
    *   **상태 준비 오류(State Preparation Errors):** 
        -   큐비트를 특정 상태(예: 0 상태)로 초기화하는 데 실패하는 경우.
    *   **디페이징 잡음(Dephasing Noise):** 
        -   양자 일관성(coherence)을 잃지만 에너지 손실은 없는 양자적 형태의 잡음으로, 블록 벡터의 횡단(transverse) 성분을 Z축으로 축소시킵니다.
    *   **진폭 감쇠 잡음(Amplitude Damping Noise):** 
        -   여기 상태(excited state)에서 바닥 상태(ground state)로 전이되는 등 에너지 이완을 모델링하며, 블록 벡터가 구의 남극으로 붕괴되는 것처럼 보입니다.
    *   **누설(Leakage):** 
        -   큐비트 상태가 계산 매니폴드(computational manifold)를 벗어나는 오류.
    *   **누화(Crosstalk):** 
        -   여러 큐비트 간에 상관 관계가 있는 오류.
    *   이러한 양자 연산은 **CPTP(Completely Positive Trace Preserving) 맵**으로 설명됩니다.
    *   **양자 잡음의 유형:** 
        -   비트 플립(bit flips, X 에러), 위상 플립(phase flips, Z 에러), 비트-위상 플립(bit-phase flips, Y 에러) 등이 있으며, 이들이 함께 작용하는 예시로는 **탈편광 잡음(depolarizing noise)**이 있습니다. 이는 양자 상태를 일정 확률로 완전히 혼합된 상태(maximally mixed state)로 대체하며, 블록 벡터를 원점 방향으로 균일하게 축소시킵니다.

### 2. 왜 잡음 특성화를 해야 하는가?
잡음을 특성화하는 것은 매우 중요합니다.
*   **알고리즘 성능 제한:** 
    -   잡음은 양자 알고리즘의 성능을 제한합니다.
*   **하드웨어 특화:** 
    -   잡음은 하드웨어마다 다르므로, 경험적으로 특성화되어야 합니다.
*   **시간에 따른 변화:** 
    -   잡음은 시간이 지남에 따라 변하므로, 양자 장치의 잡음 변화를 추적하기 위해 지속적인 벤치마킹이 필요합니다.
*   **오류 완화(Error Mitigation):** 
    -   정확한 잡음 모델은 **영 잡음 외삽법(zero noise extrapolation)**과 같은 근시일 장치에서의 오류 완화 기법을 가능하게 합니다.
*   **알고리즘 검증:** 
    -   실제 장치에서 알고리즘을 실행하기 전에 현실적인 장치 시뮬레이션을 통해 알고리즘을 검증할 수 있습니다.
*   **큐비트 레이아웃 선택:** 
    -   근시일 양자 알고리즘에 가장 적합한 큐비트를 선택하는 데 중요합니다.

### 3. IBM 양자 시스템 벤치마킹
IBM은 벤치마킹을 계층적으로 분류합니다.
*   **장치 수준 벤치마크(Device-level Benchmarks):** 
    -   큐비트 아키텍처, 장치 설계, 제작 과정 및 제어 전자기기에 의해 결정되는 장치의 물리적 특성을 측정합니다.
*   **서브시스템 수준 벤치마크(Subsystem-level Benchmarks):** 
    -   큐비트 제어를 보정(calibration)한 후 게이트 성능과 관련된 특성을 측정합니다.
*   **총체적 벤치마크(Holistic Benchmarks):** 
    -   대규모 및 유틸리티 규모의 워크로드에서 양자 컴퓨터가 전체적으로 어떻게 작동하는지에 대한 아이디어를 제공합니다.


#### 3.1 **장치 수준 벤치마크 (Device-level Benchmarks)**

장치 수준 벤치마크는 큐비트의 기본 물리적 특성을 측정합니다.

*   **T1 (에너지 이완 시간, Energy Relaxation Time):**
    *   **목표:** 
        -   여기 상태(1 상태)에 있는 큐비트가 바닥 상태(0 상태)로 얼마나 빨리 이완되는지 측정합니다.
    *   **프로토콜:** 
        -   큐비트를 X 게이트를 사용하여 여기 상태로 준비하고, 시간 t 동안 기다린 후, 계산 기저에서 측정합니다. 여러 지연 시간 t에 대해 반복하고, 1 상태로 측정될 확률 P1을 수집하여 지수 모델에 피팅하여 T1 값을 추출합니다.
    *   **시각화:** 
        -   블록 벡터가 구의 남극(0 상태)으로 붕괴되는 것처럼 보입니다.

*   **T2 (탈위상 시간, Dephasing Time):**
    *   **목표:** 
        -   위상 일관성(phase coherence)이 얼마나 빨리 붕괴되는지 측정합니다.
    *   **프로토콜:** 
        -   IBM에서는 한 에코(Han echo) 실험 변형을 사용합니다. 큐비트를 pi/2 게이트로 xy 평면에 놓은 후, 지연-파이 펄스-지연으로 구성된 에코 시퀀스를 N번 반복하고, 다시 pi/2 게이트를 적용하여 계산 기저로 되돌린 후 측정합니다. T1과 유사하게 여러 지연 시간 t에 대해 P0(t)를 수집하여 지수 모델에 피팅하고 T2 값을 추출합니다.
    *   **T1과의 차이점:** 
        -   T1은 에너지 손실을, T2는 양자 일관성 손실을 나타냅니다. T2 실험에서는 큐비트가 궁극적으로 완전히 혼합된 상태(maximally mixed state)로 탈위상되어, 0과 1 상태가 동등하게 중첩된 상태(0.5 확률)로 측정됩니다.

*   **판독 오류(Readout Errors):**
    *   **목표:** 
        -   알려진 상태의 측정 결과를 잘못 식별할 확률을 추정합니다. 예를 들어, 0 상태로 준비했을 때 0으로 측정될 확률과 1로 잘못 측정될 확률을 파악합니다.
    *   **프로토콜:** 
        -   모든 가능한 비트 문자열 조합으로 큐비트를 준비한 다음, 계산 기저에서 측정합니다. 이를 반복하여 통계를 수집하고 **할당 행렬(assignment matrix)**을 만듭니다. 대각선 요소는 각 상태의 측정 충실도(fidelity)를 나타내고, 비대각선 요소는 오류를 나타냅니다.
    *   **도전 과제:** 
        -   측정해야 하는 상태 수가 큐비트 수에 따라 기하급수적으로 증가하여, 많은 큐비트에 대해서는 비실용적입니다.

*   **판독 오류 완화(Readout Error Mitigation):**
    *   **행렬 역전(Matrix Inversion):** 
        -   측정된 잡음 행렬을 사용하여 노이즈가 있는 측정 결과로부터 실제 측정 값을 추정하는 방법입니다. 그러나 이는 큐비트 수에 따라 기하급수적으로 증가하므로 확장성이 좋지 않습니다.
    *   **유사 확률 역전(Quasi-probability Inversion):** 
        -   일반적으로 큐비트별로 오류 완화가 수행되며, 이러한 작은 국부(local) 혼동 행렬(confusion matrices)의 텐서곱을 사용하여 전체 완화 행렬을 구성합니다. 국부 잡음 가정을 통해 확장 가능한 추정기를 구축할 수 있습니다. 각 측정 결과는 음수이거나 1보다 클 수 있는 가중치로 샘플링되지만, 관측 가능한 값에 대해 평균을 내면 올바른 결과가 나옵니다.

#### 3.2 **서브시스템 수준 벤치마크 (Subsystem-level Benchmarks)**

서브시스템 수준 벤치마크는 보정된 큐비트 제어 후 양자 게이트의 성능을 측정합니다.

*   **양자 상태 단층 촬영술 (Quantum State Tomography, QST):**
    *   **목표:** 
        -   양자 상태를 여러 번 준비하고 완전한 기저에서 측정하여 해당 양자 상태의 **밀도 행렬(density matrix)**을 재구성합니다.
    *   **프로토콜:** 
        -   관심 있는 상태로 큐비트를 준비하고, 완전한 기저 상태 세트를 사용하여 상태를 측정합니다.
    *   **도전 과제:** 
        -   측정해야 하는 기저 상태 수가 큐비트 수에 따라 기하급수적으로 증가하여 비용이 많이 듭니다.

*   **양자 프로세스 단층 촬영술 (Quantum Process Tomography, QPT):**
    *   **목표:** 
        -   완전한 입력 세트에 대한 효과로부터 양자 연산(quantum operation)을 재구성합니다.
    *   **프로토콜:** 
        -   완전한 입력 상태 세트를 준비하고, 관심 있는 프로세스 회로(예: 알고리즘의 블록)를 적용한 다음, 출력에 대해 양자 상태 단층 촬영술을 수행하여 프로세스를 재구성합니다.
    *   **도전 과제:** 
        -   QST와 마찬가지로 필요한 회로 및 측정 횟수가 시스템 크기에 따라 기하급수적으로 증가하여 비효율적입니다.

*   **랜덤화 벤치마킹 (Randomized Benchmarking, RB):**
    *   QST 및 QPT의 비효율성을 개선하기 위해, RB는 **랜덤화(randomization)**의 편리한 속성을 활용하여 평균 게이트 충실도(average gate fidelities)를 효율적으로 얻는 방법입니다.
    *   **단일 큐비트 RB:**
        *   **목표:** 
            -   양자 게이트의 평균 오류율을 정량화합니다.
        *   **프로토콜:** 
            -   일련의 무작위 **클리포드 게이트(Clifford gates)**를 생성합니다. 클리포드 게이트는 고전적으로 효율적으로 계산할 수 있는 특성이 있어, 전체 클리포드 게이트 문자열을 반전시키는 게이트를 효율적으로 계산하여 회로 끝에 추가할 수 있습니다. 이상적으로는 큐비트가 0 상태로 돌아와야 하지만, 잡음으로 인해 순수한 0 상태만 측정되지는 않습니다. 여러 시퀀스 길이에 대해 이 과정을 반복하고 많은 무작위 시퀀스에 대해 평균을 낸 후, 붕괴하는 데이터에 지수 모델을 피팅하여 게이트의 충실도를 특성화하는 평균 오류율을 추출합니다.
    *   **두 큐비트 RB:**
        *   단일 큐비트 RB와 동일한 과정이지만, 두 큐비트 클리포드 그룹을 사용합니다. 이 경우, 클리포드 그룹에는 단일 큐비트 및 두 큐비트 게이트가 모두 포함되므로, 실험으로 얻은 클리포드당 오류 값은 단일 큐비트 및 두 큐비트 오류의 조합을 나타냅니다. 따라서 어떤 오류를 특성화하는지 주의해야 합니다.
        *   **확장성 도전 과제:** 
            -   클리포드 그룹의 크기가 큐비트 수에 따라 빠르게 증가하므로, RB를 임의의 N 큐비트 게이트 세트로 확장하는 것은 비용이 많이 들 수 있습니다.

*   **벨 상태의 헬링거 충실도 (Hellinger Fidelity of a Bell State):**
    *   **목표:** 
        -   시스템에서 **얽힘 게이트(entangling gates)**, 특히 CNOT 게이트의 성능을 벤치마킹합니다.
    *   **프로토콜:** 
        -   이상적인 벨 상태(두 큐비트의 최대로 얽힌 양자 상태)가 측정된 벨 상태와 얼마나 잘 일치하는지 측정합니다. CNOT 게이트를 적용하여 특정 벨 상태를 생성한 후, 측정 결과 분포와 이상적인 분포 간의 **헬링거 충실도(Hellinger fidelity)**를 추정합니다.
    *   **민감도:** 
        -   큐비트 초기화, 단일 큐비트 및 두 큐비트 오류, 판독 오류에 민감합니다.


#### 3.3 **총체적 벤치마크 (Holistic Benchmarks)**

총체적 벤치마크는 전체 시스템의 성능을 종합적으로 평가합니다.

*   **미러 회로(Mirror Circuit):**
    *   **목표:** 
        -   유틸리티 규모 회로(약 5,000개 게이트)의 관측 가능한 값 또는 기대 값의 정확도를 테스트하는 기본적인 품질 벤치마크입니다.
    *   **프로토콜:** 
        -   회로를 실행한 다음, 그 역회로(inverse circuit)를 실행하고 관측 가능한 값을 이상적인 값과 비교합니다. 이는 본질적으로 항등(identity) 연산과 동일하게 작동하므로, 오류 완화 기술을 테스트하고 실험 결과를 이상적인 값과 비교하는 데 유용합니다.
    *   **예시:** 
        -   1차원 이징(Ising) 체인의 진화와 그 역과정.

*   **퀀텀 볼륨 (Quantum Volume, QV):**
    *   **목표:** 
        -   **깊이(depth) V의 정방형 양자 회로**를 얼마나 충실하게 구현할 수 있는지를 나타내는 단일 숫자 지표입니다.
    *   **특징:**
        *   **통과/실패 테스트(Pass/Fail Test):** 
            -   양자 컴퓨터 아키텍처에 독립적으로 설계되어 다른 유형의 아키텍처를 비교할 수 있습니다.
        *   **최고 성능 큐비트 서브셋:** 
            -   장치에서 연결된 큐비트의 최적 서브셋 성능을 포착하며, `2^d`로 주어지는데, 여기서 `d`는 사용된 큐비트 서브셋의 크기이자 실행된 회로의 최대 깊이입니다.
        *   **민감도:** 
            -   일관성, 게이트 충실도, 누화, 측정 충실도, 연결성, 컴파일러에 영향을 받습니다.
        *   **총체적 지표:** 
            -   시스템의 한 부분만 개선해서는 향상될 수 없으며, 모든 부분이 시너지 효과를 내어 개선되어야 합니다.
    *   **프로토콜:**
        1.  깊이 `d`의 퀀텀 볼륨 회로(무작위 단일 큐비트 레이블 순열과 임의의 두 큐비트 게이트 적용으로 구성된 레이어)를 정의합니다.
        2.  클래식으로 이상적인 결과를 시뮬레이션하여 기준선을 설정합니다.
        3.  **무거운 출력 상태(Heavy Output States)**(발생 확률이 출력 확률 세트의 중앙값보다 높은 상태)를 식별합니다.
        4.  양자 컴퓨터에서 퀀텀 볼륨 회로를 실행하고 실험적 결과를 통해 무거운 출력 상태를 얻습니다.
        5.  이상적인 무거운 출력의 2/3 이상이 생성되면 장치가 테스트를 **통과(passed)**했다고 판단하고, 큐비트 수와 레이어를 1씩 늘려(`d+1`) 새로운 깊이로 다시 테스트합니다.
        6.  2/3 미만이 생성되면 장치가 **실패(failed)**했다고 판단합니다.
        7.  퀀텀 볼륨은 성공적으로 2/3 이상의 이상적인 무거운 출력 상태를 생성한 최대 정방형 회로 크기 `d`에 대해 `2^d`로 정의됩니다.
    *   **한계점:**
        *   **이산적(Discrete) 통과/실패 테스트:** 
            -   연속적인 게이트 개선을 나타내지 않습니다.
        *   **클래식 시뮬레이션 의존성:** 
            -   충분히 큰 시스템에서는 클래식 시뮬레이션이 불가능하여 테스트 통과 여부를 알 수 없습니다.
        *   **개별 게이트 정보 부족:** 
            -   개별 게이트 성능에 대한 정보를 제공하지 않습니다.
        *   **최고 성능 서브셋 벤치마크:** 
            -   전체 장치의 품질을 대표하지 않고, 장치 내 최고 성능 큐비트의 서브셋에 대한 성능을 보고합니다.
        *   **2D 토폴로지에서의 비효율성:** 
            -   모든 큐비트가 상호 연결되지 않은 2D 토폴로지에서는 정보를 이동하기 위해 많은 스왑(swap) 게이트(각각 3개의 CNOT 게이트 필요)가 필요하여 충실도와 게이트 수에 부담을 줍니다.

*   **레이어 충실도 (Layer Fidelity):**
    *   **목표:** 
        -   퀀텀 볼륨의 한계를 보완하기 위해 100개 이상의 큐비트를 가진 장치에서 지속적인 개선을 추적하고, 대규모 오류 완화 알고리즘 실행 능력을 평가하는 새로운 지표입니다.
    *   **특징:**
        *   **전체 프로세서 성능:** 
            -   전체 프로세서의 회로 실행 능력을 캡슐화하며, 개별 큐비트, 게이트 및 누화에 대한 정보를 제공합니다.
        *   **SPAM 오류에 둔감:** 
            -   상태 준비 및 측정(SPAM) 오류에 둔감합니다.
        *   **유연한 N 큐비트:** 
            -   장치 크기와 유사한 N개의 큐비트 세트를 선택하여 장치 전체 성능을 포착할 수 있습니다.
    *   **프로토콜:**
        1.  완전히 연결된 큐비트 세트를 M개의 **분리된 레이어(disjoint layers)**로 분할합니다. 각 레이어의 큐비트는 최대 하나의 두 큐비트 게이트만 가집니다.
        2.  각 분리된 레이어에서 **동시 직접 랜덤화 벤치마킹(simultaneous direct randomized benchmarking)**을 타이밍 장벽 및 무작위 단일 큐비트 클리포드 그룹을 통한 트월링(twirling)과 함께 실행합니다. 동시 RB는 **누화(crosstalk)**를 포착할 수 있습니다.
        3.  개별 프로세스 충실도를 추출하고, 이를 곱하여 현재 레이어의 충실도를 얻습니다.
        4.  각 레이어의 충실도를 최종적인 단일 값인 **레이어 충실도**로 곱합니다.
    *   **레이어당 게이트 오류 (Error Per Layered Gate, EPLG):** 
        -   레이어 충실도와 함께 정의되는 크기 독립적인 값으로, 이러한 레이어드 회로의 각 게이트에 대한 평균 오류율을 나타냅니다.
    *   **장점:** 
        -   장치 전체 성능을 단일 크기 독립적 품질(EPLG)로 포착하고, 개별 큐비트 게이트 및 누화에 대한 정보를 드러내며, 고성능 큐비트의 작은 서브셋이 아닌 전체 장치의 성능을 보고할 수 있습니다.

*   **CLOPS (Circuit Layer Operations Per Second):**
    *   **목표:** 
        -   속도를 측정하는 벤치마크로, 단위 시간당 실행할 수 있는 레이어 수를 측정합니다.
    *   **개념:** 
        -   레이어 충실도 벤치마크에서 도입된 레이어 개념을 차용하여 실제 시나리오를 모방합니다.
    *   **계산 요소:**
        *   **회로 실행 시간:** 장치에서 회로를 실행하는 데 걸리는 시간.
        *   **회로 간 지연 시간:** 여러 샷(shot)을 수집할 때 회로 간에 필요한 지연 시간.
        *   **런타임 컴파일 및 데이터 전송 시간:** 회로 준비, 백엔드로 회로 제출, 장비 초기화, 실험 결과 반환에 걸리는 시간.
    *   **프로토콜:** 
        -   유틸리티 규모 애플리케이션에 적합하다고 판단되는 100x100과 같은 크기로, 매개변수화된(parameterized) 레이어의 여러 인스턴스를 측정합니다. 이 레이어들은 가능한 한 많은 큐비트에 걸쳐 병렬로 실행되는 두 큐비트 게이트와 모든 큐비트에 대한 단일 큐비트 회전으로 구성됩니다.
    *   **결과:** 
        -   IBM의 Heron 프로세서는 높은 CLOPS 값을 보여주며, 이는 소프트웨어와 하드웨어가 유틸리티 규모 회로를 효율적으로 실행할 수 있음을 나타냅니다.


이러한 벤치마크들은 IBM Quantum이 양자 컴퓨터의 성능을 이해하고 개선하며, 사용자에게 투명한 정보를 제공하는 데 필수적인 도구입니다. 여러분도 Qiskit Experiments 라이브러리(Python 코드)를 통해 T1 측정부터 랜덤화 벤치마킹에 이르는 다양한 실험을 직접 실행해보고 IBM 양자 장치의 성능을 벤치마킹할 수 있습니다.

## 9. 시공간 코드를 이용한 로우 오버헤드 오류 감지

- 출처:[시공간 코드를 이용한 로우 오버헤드 오류 감지](https://www.youtube.com/watch?v=3Wpeo3Lv7Pw&list=PLOFEBzvs-VvoIfbpOb_geVnwFmbW6ij0m&index=9)

### **1. 양자 컴퓨터의 노이즈 문제와 기존 해결책**

양자 컴퓨터는 노이즈에 매우 취약합니다. 이 노이즈를 극복하고 안정적인 연산을 수행하기 위해 크게 두 가지 접근 방식이 있습니다:

*   **양자 오류 완화(Quantum Error Mitigation, QEM)**:
    *   아이디어: 
        -   양자 회로가 노이즈가 있는 양자 컴퓨터에서 실행될 때 발생하는 노이즈를 정확하게 학습한 후, 많은 샘플을 수집하여 **후처리 과정에서 노이즈를 역변환하여 상쇄**시키는 방법입니다.
    *   장점: 
        -   **추가적인 회로 또는 큐비트가 필요 없어** 현재의 하드웨어에 매우 적합합니다.
    *   단점: 
        -   회로의 크기가 커질수록 수집해야 하는 **샘플 수가 기하급수적으로 증가**하여 큰 규모의 계산에는 한계가 있습니다. 또한, **기대값(expectation values)만 제공**합니다.
    *   예시: 
        -   확률적 오류 상쇄(Probabilistic Error Cancellation, PEC), 제로 노이즈 외삽(Zero Noise Extrapolation, ZNE), 회로 절단(Circuit Cutting).

*   **양자 오류 정정(Quantum Error Correction, QEC)**:
    *   아이디어: 
        -   물리적 큐비트에 논리적 정보를 인코딩하여 **여분성(redundancy)을 통해 노이즈로부터 정보를 보호**하는 방법입니다. 노이즈 수준이 특정 임계값 이하라면 오류를 정정할 수 있습니다.
    *   장점: 
        -   **추가 샘플이 필요 없으며(one-shot computation)**, 훨씬 더 큰 규모의 계산(수백만 게이트)에 접근할 수 있도록 해줍니다.
    *   단점: 
        -   **매우 많은 큐비트가 필요**하고, 큐비트 간 복잡한 연결, 실시간 디코더 등 **복잡한 하드웨어 구축이 필수적**입니다. 현재 기술로는 구현하기 매우 어렵습니다.

### **2. 양자 오류 감지(Quantum Error Detection, QED): 중간 단계의 해결책**

주요 질문은 QEM과 QEC 사이의 "부드러운 경로"가 있는지 여부입니다. 바로 여기에 **양자 오류 감지(Quantum Error Detection, QED)**가 위치합니다.

*   **아이디어**: 
    -   **추가 큐비트를 사용하지만, 오류를 감지할 뿐 정정하지는 않습니다**. 감지된 오류가 있는 결과는 버리고, 오류가 감지되지 않은 결과만 사용합니다.
*   장점: 
    -   QEM에 비해 **샘플링 비용을 줄여주며**, QEC만큼 많은 큐비트를 요구하지 않습니다. QEC와 마찬가지로 양자 정보에 **단일샷(single-shot) 접근**을 제공하여 노이즈가 감소된 상태를 얻을 수 있습니다.
*   목표: 
    -   QEM의 지수적인 샘플링 비용 문제를 완화하고, QEC의 막대한 큐비트 요구 사항을 줄여, 현재 하드웨어에서 더 큰 계산을 가능하게 하는 것입니다.

### **3. 오류 감지 방법**

오류를 감지하는 몇 가지 방법이 있습니다:

*   **문제 의존적 방식(Problem-dependent ways)**: 
    -   계산 중인 물리 시스템의 **보존되는 특성(예: 스핀 패리티, 페르미온 입자 수)**을 측정하여 위반이 발생하면 오류가 발생했음을 추론합니다. 오류의 종류는 알 수 없지만, 오류가 있는 샷을 버릴 수 있습니다.
*   **오류 감지 코드(Error-detecting codes)**: 
    -   QEC와 유사하게 논리적 큐비트를 물리적 큐비트에 인코딩하지만, **오류를 정정할 능력은 없이 감지만 하는 약한 코드**를 사용합니다. (예: Daniel Gottisman의 2m, 2m-2, 2 코드)
*   **코히어런트 폴리 검사(Coherent Pauli Checks)**:
    *   클리포드 회로나 클리포드 중심 회로의 **대칭성**을 활용하는 방법입니다.
    *   클리포드 그룹은 폴리 연산자를 다른 폴리 연산자로 매핑하므로, 회로가 이 매핑을 올바르게 수행하는지 확인함으로써 오류를 감지할 수 있습니다.
    *   동작 원리:
        1.  **추가적인 "체크 큐비트(check qubit)"** (안실라 큐비트)를 준비합니다 (예: $\|+>$ 상태).
        2.  데이터 큐비트와 체크 큐비트 사이에 **제어된 폴리 연산(Controlled Pauli)**을 수행합니다 (U 연산 전후에 L과 R 폴리).
        3.  체크 큐비트를 측정하여 **증후군(syndrome) 비트**를 얻습니다.
        4.  오류가 없으면 증후군은 0이 됩니다. **오류가 발생하면 "위상 피드백(phase kickback)" 효과로 인해 증후군이 1이 되어 오류를 감지**할 수 있습니다.
        5.  이 과정은 데이터 큐비트의 계산에 영향을 주지 않으면서 오류 발생 여부를 알려줍니다.
        6.  더 많은 안실라 큐비트를 추가하여 더 많은 오류를 감지할 수 있습니다.
    *   **문제점**: 
        -   추가되는 체크 회로 자체도 노이즈가 있으며, 게이트 수가 많고 연결성이 제한된 하드웨어에서는 오버헤드가 매우 커져 오류 감지의 이점을 상쇄할 수 있습니다.

### **4. 저오버헤드 오류 감지를 위한 시공간 코드(Spacetime Codes)**

기존 코히어런트 폴리 검사의 높은 오버헤드를 해결하기 위해 제안된 방법이 **시공간 코드(Spacetime Codes) 기반의 저오버헤드 오류 감지**입니다.

*   **핵심 아이디어**: 
    -   체크 큐비트를 회로의 시작이나 끝에만 두는 대신, **회로 전체에 걸쳐 시간과 공간적으로 분산 배치**합니다. 이를 통해 체크 회로의 오버헤드를 크게 줄일 수 있습니다.
*   **장점**:
    *   기존 방법에 비해 **오버헤드가 훨씬 작습니다**.
    *   **"사후 선택률(post-selection rate)" (남아있는 샷의 비율)**과 **"충실도(fidelity)" (정확도)**를 크게 향상시킵니다. 시공간 접근 방식은 3배 더 나은 사후 선택률과 70% 더 나은 충실도를 보일 수 있습니다.
    *   오버헤드가 완만하게 증가하므로 더 많은 체크 라운드를 추가해도 이점을 유지할 수 있습니다.
*   **시공간 체크 구성 방법**:
    1.  **접근 가능한 와이어 식별**: 
        -   안실라 큐비트에 공간적으로 인접한 데이터 큐비트의 "와이어(wire)" (시공간 위치)를 식별.
    2.  **유효한 체크 찾기**: 
        -   이 와이어들에 지원되는 **낮은 가중치(low-weight) 폴리 연산자 세트**를 찾습니다. 이 폴리 연산자들은 회로를 통해 **역전파(back-propagated)될 때 서로 상쇄되어 항등 연산자(identity)**가 되어야 합니다. 이는 부울 인코딩(Boolean encoding)을 사용해 디코딩 문제로 해결할 수 있다.
    3.  **체크 품질 평가**: 
        -   찾아낸 각 체크 후보에 대해 **"백 누적자(back-cumulant)"**라는 연산자를 사용하여 **논리적 오류율(logical error rate)을 추정**하여 오류 감지 능력을 평가하고 최적의 체크를 선택합니다.
    4.  **구현**: 
        -   선택된 체크를 안실라 큐비트에 제어된 폴리 게이트를 구현하고 측정합니다.
*   **결과**: 
    -   매우 낮은 오버헤드의 체크로도 회로의 넓은 영역에서 오류를 감지할 수 있습니다. 이 방법은 어떤 큐비트 연결성에서도 적용 가능합니다.

### **5. 비-클리포드 회로에서의 적용**

이 방법은 **클리포드 회로나 클리포드 중심(Clifford-dominated) 회로에 가장 적합**합니다. 회로에 **비-클리포드 게이트(예: 폴리 회전)**가 도입되면, 유효한 체크를 찾을 수 있는 공간이 기하급수적으로 감소하여 오류 감지 능력이 떨어질 수 있습니다. 하지만 여전히 어느 정도의 비-클리포드성을 허용할 수 있습니다.

### **6. 실험 결과 및 응용**

이 저오버헤드 오류 감지 방법은 현재의 양자 하드웨어에서도 실험적으로 검증되었습니다.

*   **IBM Heron 프로세서 (IBM Kingston)**에서 14큐비트부터 50큐비트까지 다양한 안정자 상태(stabilizer states) 또는 그래프 상태(graph states)를 준비하는 실험을 수행했습니다.
    *   가장 큰 실험은 50큐비트, 깊이 100, 약 2,500개의 2큐비트 게이트를 포함하는 매우 복잡한 회로.
    *   체크 라운드를 추가할수록 **충실도(fidelity)가 크게 향상**되었고, 노이즈가 심한 실험일수록 사후 선택률은 감소했지만, 이는 오류를 성공적으로 감지하고 버렸다는 의미입니다.
    *   특히, 시작 충실도가 거의 0에 가까운 대규모 회로에서도 이 방법을 통해 **충실도를 2배 이상 증가**시키는 등 의미 있는 신호를 얻을 수 있었습니다.
    *   이러한 충실도 향상을 위해 요구되는 **큐비트 오버헤드와 샘플링 오버헤드는 QEC나 QEM(PEC)에 비해 훨씬 적었습니다** (예: PEC에 비해 5배 적은 샘플링 비용으로 동일한 충실도 향상).
*   **GHZ 상태(Greenberger-Horne-Zeilinger state) 준비**: 
    -   100큐비트 이상의 GHZ 상태를 준비하는 데도 적용되었습니다. GHZ 상태는 구조가 간단하고 대칭성이 높아 체크를 쉽게 찾을 수 있는 장점이 있습니다.
    *   GHZ 상태 준비를 위한 전략: 큐비트 그래프에서 일부 큐비트를 체크 안실라로 남겨두고, 나머지 큐비트를 사용하여 GHZ 상태를 구성한 후, 남은 안실라로 최적의 체크를 찾아 적용합니다.
    *   이를 통해 **역대 최대 규모의 100큐비트 이상 GHZ 상태를 성공적으로 준비**했음을 보고했습니다.


**오류 감지**는 양자 오류 완화와 양자 오류 정정 사이의 **유망한 중간 접근 방식**입니다. 이는 **양자 자원(큐비트)을 더 많이 사용하여 고전적 자원(샘플 수)을 줄이는 방법**으로 볼 수 있습니다.

향후 과제로는 시공간 코드를 활용하여 **오류를 감지할 뿐만 아니라 그 위치를 파악하고 정정할 수 있는 방법**에 대한 연구와, 클리포드 회로를 넘어 **구조화된 비-클리포드 회로를 위한 더 나은 체크 설계** 등이 있습니다.
