---
title: 6차시 6:Fundamentals of quantum algorithms (Measuring computational cost)
layout: single
classes: wide
categories:
  - Fundamentals of quantum algorithms
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

# **계산 비용 측정**
- 출처: [Measuring computational cost](https://quantum.cloud.ibm.com/learning/en/courses/fundamentals-of-quantum-algorithms/quantum-algorithmic-foundations/measuring-computational-cost)


다음으로, 이 과정의 필요에 좁게 초점을 맞춰, 계산 비용을 측정할 수 있는 **수학적 프레임워크**를 논의하겠습니다.
**알고리즘 분석**과 **계산 복잡성**은 그 자체로 완전한 주제이며, 이러한 개념들에 대해 훨씬 더 많은 것을 이야기합니다.

시작점으로, 이전 수업의 다음 그림을 고려해 봅시다. 이 그림은 계산에 대한 매우 높은 수준의 추상화를 나타냅니다.

<img src="{{site.url}}{{site.baseurl}}/assets/images/QC2/standard-computation.svg" alt="Example of a Boolean circuit" style="width: 50%;" />

계산 자체는 **파이썬으로 작성된 컴퓨터 프로그램, 튜링 머신, 불 회로, 또는 양자 회로**와 같은 다양한 방식으로 모델링되거나 설명될 수 있습니다.
우리의 초점은 (불 회로와 양자 회로 모두) **회로**에 있을 것입니다.

## 1. 인코딩과 입력 길이

계산 문제의 **입력과 출력**부터 시작하겠습니다. 이것들은 **이진 문자열**이라고 가정합니다.
다른 기호들이 사용될 수 있지만, 이 논의를 위해 **이진 문자열 입력 및 출력**으로 제한함으로써 간단하게 유지하겠습니다.
**이진 문자열**을 통해, 우리가 해결하고자 하는 문제들이 다룰 수 있는 **숫자, 벡터, 행렬, 그래프**, 그리고 이러한 것들과 다른 객체들의 **목록**과 같은 다양한 흥미로운 객체들을 **인코딩**할 수 있습니다.

예를 들어, **음이 아닌 정수**를 인코딩하기 위해 **이진 표기법**을 사용할 수 있습니다.
다음 표는 처음 아홉 개의 음이 아닌 정수의 **이진 인코딩**과 각 인코딩의 **길이** (총 비트 수를 의미함)를 나열합니다.

| 숫자 | 이진 인코딩 | 길이 |
| :----- | :-------------- | :----- |
| 0 | 0 | 1 |
| 1 | 1 | 1 |
| 2 | 10 | 2 |
| 3 | 11 | 2 |
| 4 | 100 | 3 |
| 5 | 101 | 3 |
| 6 | 110 | 3 |
| 7 | 111 | 3 |
| 8 | 1000 | 4 |

원한다면 표현에 **부호 비트**를 추가함으로써 양의 정수와 음의 정수 모두를 처리하도록 이 인코딩을 쉽게 확장할 수 있습니다.
때로는 **음이 아닌 정수의 이진 표현이 선행 0을 가질 수 있도록 허용하는 것도 편리**합니다. 이는 인코딩되는 값을 변경하지 않지만, 고정된 크기의 문자열이나 단어를 채울 수 있게 합니다.

**이진 표기법**을 사용하여 음이 아닌 정수를 표현하는 것은 **흔하고 효율적**이지만, 원한다면 다음 표에서 제안하는 것과 같이 이진 문자열을 사용하여 음이 아닌 정수를 표현하는 다른 방법을 선택할 수도 있습니다.
이러한 대안의 세부 사항은 이 논의에서 중요하지 않습니다 — 요점은 우리가 사용하는 **인코딩에 대한 선택권이 있다는 것을 명확히 하는 것**입니다.

| 숫자 | 단항 인코딩 | 사전식 인코딩 |
| :----- | :------------- | :--------------------- |
| 0 | $\varepsilon$ | $\varepsilon$ |
| 1 | 0 | 0 |
| 2 | 00 | 1 |
| 3 | 000 | 00 |
| 4 | 0000 | 01 |
| 5 | 00000 | 10 |
| 6 | 000000 | 11 |
| 7 | 0000000 | 000 |
| 8 | 00000000 | 001 |

(이 표에서 기호 $\varepsilon$는 **빈 문자열**을 나타냅니다. 빈 문자열은 기호가 없고 길이가 0입니다. 당연히 명백한 혼동의 원인을 피하기 위해, 빈 문자열을 나타내기 위해 단순히 아무것도 쓰지 않고 $\varepsilon$와 같은 특수 기호를 사용합니다.)

**벡터 및 행렬**과 같은 다른 유형의 입력이나 분자 설명과 같은 더 복잡한 객체들도 이진 문자열로 인코딩될 수 있습니다.
음이 아닌 정수에 대해 그랬듯이, 다양한 인코딩 방식을 선택하거나 고안할 수 있습니다.
주어진 문제에 대한 입력을 인코딩하기 위해 어떤 방식을 고안하든지, 우리는 **입력 문자열의 길이**를 **해결되는 문제 인스턴스의 크기**로 해석합니다.

예를 들어, **이진 표기법으로 음이 아닌 정수 $N$을 표현하는 데 필요한 비트 수**는 때때로 $\operatorname{lg}(N)$으로 표기되며, 다음 공식으로 주어집니다.

<br>
$$
\operatorname{lg}(N) =
\begin{cases}
1 & N = 0\\
1 + \lfloor \log_2 (N) \rfloor & N \geq 1
\end{cases}
$$

정수 인수분해 문제에 대한 입력을 인코딩하기 위해 이진 표기법을 사용한다고 가정하면, 숫자 $N$에 대한 **입력 길이**는 따라서 $\operatorname{lg}(N)$입니다.
특히, 입력 $N$의 길이 (또는 크기)는 $N$ 자체가 아닙니다; $N$이 클 때 이진 표기법으로 $N$을 표현하는 데는 이만큼 많은 비트가 필요하지 않습니다.

엄격하게 형식적인 관점에서, **계산 문제 또는 작업**을 고려할 때마다, 입력으로 주어지거나 출력으로 생성되는 객체를 인코딩하기 위한 **특정 방식이 선택되었다고 이해**해야 합니다.
이는 흥미로운 문제를 해결하는 계산이 **이진 문자열 입력에서 이진 문자열 출력으로의 변환**으로 추상적으로 간주될 수 있도록 합니다.

객체가 이진 문자열로 인코딩되는 방식의 세부 사항은 어떤 수준에서는 이러한 계산에 반드시 중요할 것입니다.
그러나 일반적으로 **계산 비용을 분석할 때는 이러한 세부 사항에 대해 그다지 신경 쓰지 않습니다**. 이는 중요성이 덜한 세부 사항에 얽매이는 것을 피하기 위함입니다.
기본적인 추론은 "합리적인" 인코딩 방식들 사이를 변환하는 계산 비용이 실제 문제를 해결하는 비용에 비해 **미미할 것으로 예상**한다는 것입니다.
그렇지 않은 상황에서는 세부 사항이 명확히 되어야 합니다 (그리고 그래야 합니다).

예를 들어, 음이 아닌 정수의 이진 표현과 그 사전식 인코딩 사이를 변환하는 것은 매우 간단한 계산입니다 (우리는 자세히 설명하지 않았지만, 위 표에서 유추할 수 있습니다). 이러한 이유로, 입력 $N$에 대해 이 인코딩 중 하나에서 다른 인코딩으로 전환하기로 결정하더라도 **정수 인수분해의 계산 비용은 크게 다르지 않을 것**입니다.
반면에, **음이 아닌 정수를 단항 표기법으로 인코딩하는 것은 필요한 총 기호 수에서 기하급수적인 증가를 초래**하며, 이러한 이유로 우리는 이것을 "합리적인" 인코딩 방식으로 간주하지 않을 것입니다.

## 2. 기본 연산

이제 계산 자체를 고려해 봅시다. 이것은 위 그림의 파란색 사각형으로 표현됩니다.
우리가 계산 비용을 측정하는 방식은 각 계산이 요구하는 **기본 연산의 수**를 세는 것입니다.
직관적으로 말하자면, **기본 연산**은 두 비트의 AND를 계산하는 것과 같이 **작고 고정된 수의 비트 또는 큐비트를 포함하고, 빠르고 쉽게 수행될 수 있는 연산**입니다.
대조적으로, `factorint` 함수를 실행하는 것은 합리적으로 기본 연산으로 간주되지 않습니다.

형식적으로 말하자면, 사용되는 계산 모델에 따라 **무엇이 기본 연산을 구성하는지에 대한 다른 선택지**가 있습니다.
우리의 초점은 **회로 모델**, 특히 양자 및 불 회로에 있을 것입니다.

### 2.1 범용 게이트 세트

회로 기반 계산 모델의 경우, **각 게이트가 기본 연산으로 간주되는 것이 일반적**입니다.
이는 우리 회로에서 정확히 어떤 게이트를 허용할 것인지에 대한 질문으로 이어집니다.
일단 양자 회로에 초점을 맞추면, 우리는 이 시리즈에서 **$X, Y, Z, H, S,$ 및 $T$ 게이트, 스왑 게이트, 제어된 버전의 게이트 (제어-NOT, 토폴리, 프레드킨 게이트 포함), 그리고 표준 기저 측정**을 나타내는 게이트를 포함하여 지금까지 여러 게이트를 보았습니다.
CHSH 게임의 맥락에서 우리는 몇 가지 추가 **회전 게이트**도 보았습니다.

우리는 또한 쿼리 모델의 맥락에서 **쿼리 게이트**를 논의했으며, 또한 임의의 큐비트 수에 작용하는 임의의 유니터리 연산 $U$도 원한다면 게이트로 간주될 수 있음을 보았습니다 — 그러나 이 논의를 위해 이 두 가지 옵션은 무시할 것입니다.
우리는 쿼리 모델에서 작업하지 않을 것이며 (비록 기본 연산을 사용한 쿼리 게이트의 구현은 이 수업 후반에 논의되지만), 잠재적으로 수백만 개의 큐비트에 작용하는 임의의 유니터리 게이트를 기본 연산으로 간주하는 것은 의미 있거나 현실적인 계산 비용 개념으로 이어지지 않습니다.

소수의 큐비트에 대해 작동하는 양자 게이트를 고수하면서, 어떤 게이트를 기본으로 간주할지 결정하는 한 가지 접근 방식은 정확한 기준을 찾아내는 것이지만 — 이것은 표준적인 접근 방식도, 우리가 취할 접근 방식도 아닙니다.
오히려, 우리는 단순히 선택을 합니다.

양자 회로의 **기본 게이트 세트**로 채택할 표준 선택은 다음과 같습니다:
*   **이 목록의 단일 큐비트 유니터리 게이트: $X, Y, Z, H, S, S^{\dagger}, T,$ 및 $T^{\dagger}$**
*   **제어-NOT 게이트**
*   **단일 큐비트 표준 기저 측정**

일반적인 대안은 **토폴리, 하다마르, S 게이트**를 표준 기저 측정과 더불어 기본으로 간주하는 것입니다.
때로는 **모든 단일 큐비트 게이트가 기본으로 간주**되기도 하지만, 이는 게이트가 수행되는 정확도가 제대로 고려되지 않을 경우 **비현실적으로 강력한 모델**로 이어집니다.

우리 기본 컬렉션의 유니터리 게이트는 **범용 게이트 세트**라고 불리는 것을 형성합니다.
이는 우리가 **이 게이트들만으로 구성된 회로를 사용하여 임의의 큐비트 수에 대한 임의의 유니터리 연산을 원하는 정확도만큼 근사할 수 있음**을 의미합니다.
명확히 하자면, **범용성의 정의는 이러한 근사의 비용, 즉 필요한 우리 세트의 게이트 수에 대한 요구 사항을 두지 않습니다**.
실제로, 측정의 수학적 개념에 기반한 상당히 간단한 논증은 대부분의 유니터리 연산이 극도로 높은 비용을 가질 것임을 밝힙니다.
양자 게이트 세트의 범용성을 증명하는 것은 간단한 문제가 아니며 이 과정에서는 다루지 않을 것입니다.

불 회로의 경우, 우리는 **AND, OR, NOT, 그리고 FANOUT 게이트**를 기본 연산을 나타내는 것으로 간주할 것입니다.
우리는 사실 AND 게이트와 OR 게이트 둘 다를 필요로 하지는 않습니다 — **드 모르간의 법칙**을 사용하여 모든 세 개의 입력/출력 와이어에 NOT 게이트를 배치함으로써 서로 변환할 수 있습니다 — 그러나 그럼에도 불구하고 AND 및 OR 게이트를 모두 허용하는 것이 일반적이고 편리합니다.

AND, OR, NOT, 그리고 FANOUT 게이트는 **결정론적 계산을 위한 범용 세트**를 형성합니다. 즉, **임의의 고정된 수의 입력 비트에서 임의의 고정된 수의 출력 비트로의 모든 함수**는 이 게이트들로 구현될 수 있습니다.

### 2.2 지연 측정의 원리

**표준 기저 측정 게이트는 양자 회로 내에 나타날 수 있지만, 때로는 이를 끝까지 지연시키는 것이 편리**합니다.
이를 통해 양자 계산을 (계산 자체를 나타내는) **유니터리 부분**과 큐비트가 측정되고 결과가 출력되는 **간단한 판독 단계**로 구성된 것으로 볼 수 있습니다.
이는 각 표준 기저 측정에 대해 추가 큐비트를 추가할 의향이 있다면 항상 수행할 수 있습니다.
다음 그림에서 오른쪽 회로는 이것이 어떻게 수행될 수 있는지를 왼쪽에 있는 게이트에 대해 보여줍니다.

<img src="{{site.url}}{{site.baseurl}}/assets/images/QC2/deferred-measurement.svg" alt="Example of a Boolean circuit" style="width: 50%;" />

구체적으로, 왼쪽 회로의 **고전 비트는 오른쪽의 큐비트 ( $\|0\rangle$ 상태로 초기화됨)로 대체**되고, **표준 기저 측정은 제어-NOT 게이트와 그 뒤에 오는 하단 큐비트의 표준 기저 측정으로 대체**됩니다.

요점은 오른쪽 회로의 표준 기저 측정을 회로의 맨 끝까지 밀어낼 수 있다는 것입니다.
왼쪽 회로의 고전 비트가 나중에 제어 비트로 사용되는 경우, 오른쪽 회로의 하단 큐비트를 대신 제어로 사용할 수 있으며, 전체 효과는 동일할 것입니다.
(우리는 왼쪽 회로의 고전 비트가 측정 후 다른 측정에 의해 덮어쓰여지지 않는다고 가정합니다 — 그러나 그렇게 된다면 이전 측정에 사용되었던 비트를 덮어쓰는 대신 항상 새로운 고전 비트를 사용할 수 있습니다.)

## 3. 회로 크기와 깊이

### 3.1 회로 크기
회로의 총 게이트 수는 해당 회로의 **크기**라고 불립니다.
따라서 우리 회로의 게이트가 기본 연산을 나타낸다고 가정하면, 회로의 크기는 해당 회로가 요구하는 **기본 연산의 수**, 즉 **계산 비용**을 나타냅니다.
주어진 회로 $C$의 크기를 나타내기 위해 $\operatorname{size}(C)$라고 씁니다.

예를 들어, 두 비트의 XOR을 계산하기 위한 다음 불 회로를 고려해 봅시다.

<img src="{{site.url}}{{site.baseurl}}/assets/images/QC2/Boolean-circuit-XOR.svg" alt="Example of a Boolean circuit" style="width: 50%;" />

이 회로의 크기는 총 7개의 게이트가 있기 때문에 7입니다.
(팬아웃 연산은 항상 게이트로 간주되는 것은 아니지만, 이 수업의 목적을 위해 우리는 그것들을 게이트로 간주할 것입니다.)

### 3.2 시간, 비용, 그리고 회로 깊이

**시간**은 계산에 있어 **매우 중요한 자원 또는 제한 제약**입니다.
RSA1024 인수분해와 같은 위의 예시들은 이러한 관점을 강화합니다.
`factorint` 함수는 RSA1024를 인수분해하는 데 실패하는 것이 아니라, 단순히 **우리가 그것이 끝날 때까지 기다릴 충분한 시간이 없다**는 것입니다.

**계산 비용**이라는 개념은 계산을 수행하는 데 필요한 **기본 연산의 수**로서, **계산을 구현하는 데 필요한 시간의 추상적인 대리 역할**을 하도록 의도되었습니다.
각 기본 연산은 수행하는 데 일정한 양의 시간을 요구하며, 계산에 더 많은 연산이 필요할수록, 일반적으로 더 오래 걸립니다.
간단함을 위해, 우리는 계산 비용과 알고리즘 실행에 필요한 시간 사이의 이러한 연관성을 계속 유지할 것입니다.

그러나 **회로의 크기가 반드시 실행하는 데 걸리는 시간과 직접적으로 일치하지는 않는다는 점**에 유의하십시오.
예를 들어, 두 비트의 XOR을 계산하기 위한 불 회로에서는 두 개의 FANOUT 게이트가 동시에 수행될 수 있고, 두 개의 NOT 게이트도 마찬가지이며, 두 개의 AND 게이트도 마찬가지입니다.
**회로의 효율성을 측정하는 다른 방법**은 이러한 **병렬화** 가능성을 고려하는 것으로, **깊이**에 의해 측정됩니다.
이것은 회로 내에서 필요한 **최소 게이트 레이어 수**이며, 각 레이어 내의 게이트는 서로 다른 와이어에서 작동합니다.
동등하게, **회로의 깊이**는 **입력 와이어에서 출력 와이어로 가는 모든 경로에서 만나는 최대 게이트 수**입니다.
예를 들어, 위 회로의 경우 깊이는 4입니다.

**회로 깊이**는 **병렬 계산의 실행 시간을 형식화하는 한 가지 방법**입니다.
이것은 고급 주제이며, 특정 계산에 필요한 깊이를 최소화하는 것으로 알려진 매우 정교한 회로 구성이 존재합니다.
회로 깊이와 관련된 몇 가지 흥미로운 미해결 질문도 있습니다.
(예를 들어, GCD를 계산하는 데 필요한 회로 깊이에 대해서는 여전히 많은 것이 알려져 있지 않습니다.)

우리는 이 시리즈에서 회로 깊이에 대해 더 이상 많은 것을 말하지 않을 것입니다. 단, 진행하면서 회로 깊이에 대한 몇 가지 흥미로운 사실을 포함할 것이지만, **병렬화가 계산 이점의 잠재적 원천임은 명확히 인정**되어야 합니다.

### 3.3 다른 게이트에 비용 할당하기

회로 크기와 계산 비용에 관한 마지막 한 가지는, 모든 게이트가 총 비용에 동일하게 기여한다고 보는 대신, **게이트에 다른 비용을 할당하는 것이 가능**하다는 것입니다.

예를 들어, 이미 언급했듯이, FANOUT 게이트는 종종 불 회로의 경우 **무료**로 간주됩니다 — 즉, FANOUT 게이트의 비용을 0으로 선택할 수 있다는 것입니다.
다른 예로, 쿼리 모델에서 작업할 때 회로가 입력 함수에 대해 수행하는 쿼리 수를 셀 경우 (블랙박스 형태로), 우리는 효과적으로 쿼리 게이트에는 단위 비용을, 하다마르 게이트와 같은 다른 게이트에는 0 비용을 할당하는 것입니다.
마지막 예는 때때로 **게이트를 구현하기 얼마나 어려운지에 따라 다른 비용을 할당**하기도 하는데, 이는 고려되는 하드웨어에 따라 다를 수 있습니다.

이러한 모든 옵션은 다른 맥락에서 합리적이지만, 이 수업에서는 간단하게 유지하고 **계산 비용의 표현으로 회로 크기를 고수**할 것입니다.

## 4. 입력 길이에 따른 비용 함수

우리는 주로 **입력이 점점 더 커짐에 따라 계산 비용이 어떻게 확장되는지**에 관심이 있습니다.
이는 알고리즘의 비용을 **입력 길이의 함수**로 나타내게 합니다.

### 4.1 회로 패밀리

주어진 계산 문제에 대한 입력은 길이가 다를 수 있으며, 잠재적으로 **임의로 커질 수 있습니다**.
반면에 모든 회로는 **고정된 수의 게이트와 와이어**를 가집니다.
이러한 이유로, 회로 측면에서 알고리즘을 생각할 때, 일반적으로 **알고리즘을 나타내기 위해 무한히 큰 회로 패밀리가 필요**합니다.
**회로 패밀리**란, **점점 더 큰 입력을 수용할 수 있도록 크기가 커지는 회로의 시퀀스**를 의미합니다.

예를 들어, `factorint`에서 사용되는 것과 같은 고전적인 정수 인수분해 알고리즘이 있다고 상상해 봅시다.
모든 고전 알고리즘과 마찬가지로, 이 알고리즘은 불 회로를 사용하여 구현될 수 있습니다 — 하지만 이를 위해서는 **가능한 각 입력 길이에 대해 별도의 회로**가 필요할 것입니다.
다른 입력 길이에 대한 결과 회로를 살펴보면, **입력 길이가 증가함에 따라 회로의 크기가 자연스럽게 증가**하는 것을 볼 수 있습니다 — 예를 들어, 4비트 정수를 인수분해하는 것이 1024비트 정수를 인수분해하는 것보다 훨씬 쉽고 훨씬 적은 기본 연산을 필요로 한다는 사실을 반영합니다.

이는 알고리즘의 **계산 비용**을 **$n$ 비트 입력에 대한 알고리즘을 구현하는 회로의 게이트 수로 정의되는 함수 $t$로 나타내게** 합니다.
더 형식적인 용어로, **불 회로 모델의 알고리즘**은 회로의 시퀀스 **$\{C_1, C_2, C_3,\ldots\}$로 설명**됩니다. 여기서 $C_n$은 $n$-비트 입력 (또는 더 일반적으로, 크기가 $n$으로 어떤 식으로든 매개변수화된 입력)에 대해 우리가 이야기하는 모든 문제를 해결하며, 이 알고리즘의 비용을 나타내는 함수 $t$는 다음과 같이 정의됩니다.
\[t(n) = \operatorname{size}(C_n).\]

**양자 회로**의 경우에도 상황은 비슷하며, **점점 더 긴 입력 문자열을 수용하기 위해 점점 더 큰 회로가 필요**합니다.

### 4.2 예시: 정수 덧셈

더 자세히 설명하기 위해, 정수 인수분해나 심지어 GCD 계산보다 훨씬 간단한 **정수 덧셈 문제**를 잠시 살펴보겠습니다.

> **정수 덧셈**\
> 입력: 정수 $N$과 $M$\
> 출력: $N+M$

이 문제를 해결하기 위한 불 회로를 어떻게 설계할 수 있을까요?

간단하게 유지하기 위해, $N$과 $M$이 모두 이진 표기법을 사용하여 $n$-비트 문자열로 표현된 **음이 아닌 정수**인 경우로 제한합시다.
우리는 이러한 인코딩에서 **선행 0의 개수를 허용**하여, 
\[0\leq N,M\leq 2^n - 1\]이 되도록 합니다.
출력은 합을 나타내는 $(n+1)$-비트 이진 문자열이 될 것입니다. 이는 결과를 표현하는 데 필요한 최대 비트 수입니다.

우리는 알고리즘, 즉 **이진 표현 덧셈을 위한 표준 알고리즘**으로 시작합니다. 이 알고리즘은 전 세계 초등학교에서 덧셈을 가르치는 방식의 **2진 아날로그**입니다.
이 알고리즘은 다음과 같이 불 회로로 구현될 수 있습니다.

최하위 비트부터 시작하여, 우리는 그것들의 XOR을 계산하여 합의 최하위 비트를 결정할 수 있습니다.
그 다음 우리는 올림 비트를 계산합니다. 이것은 $N$과 $M$의 두 최하위 비트의 AND입니다.
때때로 이 두 연산이 합쳐져 **하프 가산기**로 알려져 있습니다.

<img src="{{site.url}}{{site.baseurl}}/assets/images/QC2/half-adder.svg" alt="Example of a Boolean circuit" style="width: 50%;" />


이제 몇 번 보았던 XOR 회로를 AND 게이트와 두 개의 FANOUT 게이트와 함께 사용하여 10개의 게이트로 하프 가산기를 만들 수 있습니다.
만약 어떤 이유로 우리가 마음을 바꿔 XOR 게이트를 기본 연산 세트에 포함시키기로 결정했다면, 하프 가산기를 만드는 데 1개의 AND 게이트, 1개의 XOR 게이트, 그리고 2개의 FANOUT 게이트가 필요했을 것입니다.

더 상위 비트로 이동하여, 유사한 절차를 사용할 수 있지만, 이번에는 이전 위치에서 온 올림 비트를 계산에 포함시킵니다.
두 개의 하프 가산기를 **캐스케이드**하고 그것들이 생성하는 올림 비트의 OR을 취함으로써, 우리는 **전가산기**라고 알려진 것을 만들 수 있습니다.

<img src="{{site.url}}{{site.baseurl}}/assets/images/QC2/full-adder.svg" alt="Example of a Boolean circuit" style="width: 50%;" />

이것은 총 21개의 게이트를 필요로 합니다: 2개의 AND 게이트, 2개의 XOR 게이트 (각각 7개의 게이트 구현 필요), 1개의 OR 게이트, 그리고 4개의 FANOUT 게이트.

마지막으로, **전가산기들을 캐스케이드**함으로써, 우리는 음이 아닌 정수 덧셈을 위한 불 회로를 얻습니다. 예를 들어, 다음 회로는 두 개의 4비트 정수의 합을 계산합니다.

<img src="{{site.url}}{{site.baseurl}}/assets/images/QC2/addition-circuit.svg" alt="Example of a Boolean circuit" style="width: 50%;" />

일반적으로, 이것은 $21 (n-1) + 10 = 21 n - 11$개의 게이트를 필요로 합니다.

만약 우리가 XOR 게이트를 기본 연산 세트에 포함시키기로 결정했다면, 우리는 $2n-1$개의 AND 게이트, $2n-1$개의 XOR 게이트, $n-1$개의 OR 게이트, 그리고 $4n-2$개의 FANOUT 게이트를 필요로 했을 것이며, 총 $9n-5$개의 게이트가 됩니다.
추가적으로 FANOUT 게이트를 세지 않기로 결정했다면, $5n-3$개의 게이트가 됩니다.

### 4.3 점근 표기법

한 편으로는, 위 정수 덧셈 예시처럼 다양한 계산을 수행하는 데 정확히 몇 개의 게이트가 필요한지 아는 것이 좋습니다.
이러한 세부 사항은 실제로 회로를 구축하는 데 중요합니다.

다른 한편으로는, 덧셈보다 훨씬 복잡한 작업을 포함하여 우리가 관심 있는 모든 계산에 대해 이 수준의 세부 사항으로 분석을 수행한다면, 우리는 매우 빠르게 세부 사항에 파묻히게 될 것입니다.
관리를 용이하게 하고, 중요성이 덜한 세부 사항을 의도적으로 억제하기 위해, 우리는 일반적으로 알고리즘을 분석할 때 **빅-O 표기법**을 사용합니다.
이 표기법을 통해 우리는 함수가 성장하는 **차수**를 표현할 수 있습니다.

형식적으로 말하자면, 두 함수 $g(n)$과 $h(n)$이 있을 때, 어떤 양의 실수 $c > 0$와 양의 정수 $n_0$가 존재하여 모든 $n \geq n_0$에 대해 \[g(n) \leq c\cdot h(n)\]이면 **$g(n) = O(h(n))$이라고 씁니다**.
일반적으로 $h(n)$은 가능한 한 간단한 표현식으로 선택되어, 이 표기법이 함수의 **제한적 동작**을 간단한 용어로 나타낼 수 있도록 합니다.
예를 들어, $17 n^3 - 257 n^2 + 65537 = O(n^3)$입니다.

이 표기법은 여러 인수를 가지는 함수로 상당히 직접적인 방식으로 확장될 수 있습니다.
예를 들어, 양의 정수 $n$과 $m$에 대해 정의된 두 함수 $g(n,m)$과 $h(n,m)$이 있을 때, $n+m \geq k_0$일 때마다 \[g(n,m) \leq c\cdot h(n,m)\]이 되도록 하는 양의 실수 $c > 0$와 양의 정수 $k_0$가 존재한다면 **$g(n,m) = O(h(n,m))$이라고 씁니다**.

이 표기법을 음이 아닌 정수 덧셈의 예시에 연결하면, 우리는 두 $n$-비트 음이 아닌 정수를 더하는 $C_n$을 가지는 불 회로 패밀리 $\{C_1, C_2,\ldots,\}$가 존재하며, $\operatorname{size}(C_n) = O(n)$임을 결론 내립니다.
이는 덧셈 비용이 입력 크기에 따라 **선형적으로** 확장되는 방식의 가장 본질적인 특징을 보여줍니다.

또한, XOR 게이트의 비용이 단위 비용인지 7인지와 같은 **특정 세부 사항에 의존하지 않는다**는 점에 유의하십시오.
일반적으로, 빅-O 표기법을 사용하면 이러한 낮은 수준의 세부 사항에 민감하지 않은 계산 비용에 대한 진술을 할 수 있습니다.

### 4.4 추가 예시

다음은 **곱셈**부터 시작하는 계산 정수론 문제의 몇 가지 추가 예시입니다.

> **정수 곱셈**\
> 입력: 정수 $N$과 $M$\
> 출력: $NM$

이 문제에 대한 불 회로를 만드는 것은 덧셈을 위한 회로를 만드는 것보다 더 어렵습니다 — 그러나 표준 곱셈 알고리즘을 생각함으로써, 이 문제에 대해 **크기 $O(n^2)$를 가지는 회로**를 만들 수 있습니다 (N과 M이 모두 $n$-비트 이진 표현으로 표현된다고 가정).
더 일반적으로, $N$이 $n$ 비트를 가지고 $M$이 $m$ 비트를 가질 경우, $N$과 $M$을 곱하기 위한 **크기 $O(nm)$의 불 회로**가 있습니다.

사실, 더 잘 확장되는 다른 곱셈 방법도 있습니다.
예를 들어, **쇤하게-슈트라센 곱셈 알고리즘**을 사용하여 두 $n$-비트 정수를 **$O(n \operatorname{lg}(n) \operatorname{lg}(\operatorname{lg}(n)))$ 비용**으로 곱하기 위한 불 회로를 만들 수 있습니다.
그러나 이 방법의 복잡성은 많은 오버헤드를 유발하여, 수만 비트의 숫자에 대해서만 실용적입니다.

다른 기본 문제는 **나눗셈**으로, 이는 정수 제수와 피제수가 주어졌을 때 몫과 나머지를 모두 계산하는 것을 의미합니다.

> **정수 나눗셈**\
> 입력: 정수 $N$과 $M\neq0$\
> 출력: $0\leq r < |M|$과 $N = q M + r$을 만족하는 정수 $q$와 $r$

정수 나눗셈의 비용은 곱셈과 유사합니다: $N$이 $n$ 비트를 가지고 $M$이 $m$ 비트를 가질 경우, 이 문제를 해결하기 위한 **크기 $O(nm)$의 불 회로**가 있습니다.
그리고 곱셈과 마찬가지로, 점근적으로 우수한 방법들이 알려져 있습니다.

이제 **GCD를 계산하는 알려진 알고리즘**들을 덧셈 및 곱셈 알고리즘과 비교할 수 있습니다.
$n$-비트 숫자 $N$과 $m$-비트 숫자 $M$의 GCD를 계산하는 **유클리드 알고리즘**은 표준 곱셈 및 나눗셈 알고리즘과 유사하게 **크기 $O(nm)$의 불 회로**를 필요로 합니다.
또한 곱셈 및 나눗셈과 유사하게, 점근적으로 더 빠른 GCD 알고리즘이 있습니다 — 두 $n$-비트 숫자의 GCD를 계산하는 데 **$O(n(\operatorname{lg}(n))^2 \operatorname{lg}(\operatorname{lg}(n)))$ 기본 연산을 요구하는 알고리즘**도 포함됩니다.

정수론에서 발생하는 다소 더 비싼 계산은 **모듈러 거듭제곱**입니다.

> **정수 모듈러 거듭제곱**\
> 입력: $K\geq 0$ 및 $M\geq 1$인 정수 $N, K,$ 및 $M$\
> 출력: $N^K \hspace{1mm} (\text{mod }M)$

$N^K\hspace{1mm} (\text{mod }M)$은 $N^K$를 $M$으로 나눴을 때의 나머지를 의미하며, 즉 $0\leq r < M$과 $N^K = q M + r$을 만족하는 유일한 정수 $r$을 의미합니다.

$N$이 $n$ 비트, $M$이 $m$ 비트, $K$가 $k$ 비트를 가질 경우, 이 문제는 **크기 $O(k m^2 + nm)$를 가지는 불 회로**로 해결될 수 있습니다.
이것은 전혀 명백하지 않습니다.
해결책은 먼저 $N^K$를 계산한 다음 나머지를 취하는 것이 아닙니다. 그렇게 하면 $N^K$라는 숫자를 저장하는 데만 기하급수적으로 많은 비트를 사용해야 할 것입니다.
오히려, 우리는 **거듭제곱 알고리즘** (대안적으로 **이진법** 및 **반복 제곱법**으로 알려짐)을 사용할 수 있습니다. 이 알고리즘은 $K$의 이진 표현을 활용하여 전체 계산을 $M$을 법으로 수행합니다.
$N, M,$ 그리고 $K$가 모두 $n$-비트 숫자라고 가정하면, 우리는 **$O(n^3)$ 알고리즘** — 또는 **3차 시간 알고리즘**을 얻습니다.
그리고 다시 한번, 더 복잡하지만 점근적으로 더 빠른 알려진 알고리즘들이 있습니다.

### 4.5 정수 인수분해의 비용

방금 논의된 알고리즘들과 대조적으로, **정수 인수분해를 위한 알려진 알고리즘은 훨씬 더 비쌉니다** — 이 수업 앞부분의 논의에서 예상했듯이 말입니다.

인수분해의 한 가지 간단한 접근 방식은 **시행 나눗셈**으로, 알고리즘이 $2,\ldots,\sqrt{N}$ 목록을 탐색하여 입력 숫자 $N$의 소인수를 찾습니다.
이는 $N$이 $n$-비트 숫자일 때 **최악의 경우 $O(2^{n/2})$ 반복**을 필요로 합니다.
각 반복은 시행 나눗셈을 필요로 하며, 이는 각 반복에 대해 **$O(n^2)$ 기본 연산**을 의미합니다 (표준 정수 나눗셈 알고리즘 사용).
우리는 **크기 $O(n^2 2^{n/2})$의 회로**를 얻게 되는데, 이는 입력 크기 $n$에 대해 **지수적**입니다.

**더 나은 확장성을 가지는 정수 인수분해 알고리즘**이 있습니다.
예를 들어, 앞서 언급된 **수체 체(number field sieve)**는 무작위성을 활용하는 알고리즘으로, 높은 확률로 $n$-비트 정수를 인수분해하는 데 \[2^{O(n^{1/3} (\operatorname{lg}(n))^{2/3})}\] 기본 연산을 요구하는 것으로 일반적으로 믿어집니다 (엄격하게 증명되지는 않았지만).
이 표현식의 지수에서 $n$이 $1/3$ 제곱으로 올라간다는 점은 매우 중요하지만, **지수에 나타난다는 사실 자체가 여전히 불량한 확장성을 유발하는 문제**입니다 — 그리고 RSA1024가 적용 영역 밖에 남아 있는 이유를 부분적으로 설명합니다.

### 4.6 다항식 비용 대 지수 비용

정수 덧셈, 곱셈, 나눗셈, 최대공약수 계산을 위한 **고전 알고리즘**은 수천 비트의 입력에 대해 **눈 깜짝할 사이에 이 문제들을 해결**할 수 있게 합니다.
덧셈은 **선형 비용**을 가지는 반면, 다른 세 문제는 **2차 비용** (또는 점근적으로 빠른 알고리즘을 사용하면 하위 2차 비용)을 가집니다.
모듈러 거듭제곱은 더 비싸지만 여전히 매우 효율적으로 수행될 수 있으며, **3차 비용** (또는 점근적으로 빠른 알고리즘을 사용하면 하위 3차 비용)을 가집니다.

이들은 모두 **다항식 비용**을 가지는 알고리즘의 예시이며, 이는 어떤 고정된 상수 $c > 0$에 대해 **$O(n^c)$의 비용**을 가진다는 것을 의미합니다.
대략적인 1차 근사치로, **다항식 비용을 가지는 알고리즘은 추상적으로 효율적인 알고리즘으로 간주**됩니다.

대조적으로, **정수 인수분해를 위한 알려진 고전 알고리즘은 지수적 비용**을 가집니다.
수체 거름법의 비용은 지수에 $n$이 $1/3$ 제곱으로 올라가기 때문에 때때로 **준-지수적 (sub-exponential)**이라고 설명되기도 하지만, 복잡성 이론에서는 일반적으로 이 용어를 **모든 $\varepsilon > 0$에 대해 \[O\bigl(2^{n^{\varepsilon}}\bigr)\]인 비용을 가지는 알고리즘**에 한정하여 사용합니다.
소위 **NP-완전 문제**는 다항식 비용 알고리즘이 알려져 있지 않고 (그리고 광범위하게 그러한 알고리즘이 존재하지 않는다고 추정되는) 문제들의 한 종류입니다.
**지수 시간 가설**의 회로 기반 공식화는 훨씬 더 강력한 것을 가정합니다. 즉, 어떤 NP-완전 문제도 준-지수적 비용 알고리즘을 가질 수 없다는 것입니다.

**다항식 비용 알고리즘을 효율적인 알고리즘과 연결하는 것은 느슨한 추상화로 이해**되어야 합니다.
물론, 알고리즘의 비용이 $n$ 크기의 입력에 대해 $n^{1000}$ 또는 $n^{1000000}$으로 확장된다면, 그 알고리즘을 효율적이라고 설명하는 것은 무리입니다.
그러나 $n^{1000000}$으로 확장되는 비용을 가지는 알고리즘조차도 "무차별 대입" 또는 "철저한 탐색"에 어떤 식으로든 기반한 알고리즘에서 일반적으로 예상되는 **지수적 비용**을 피하기 위해 영리한 조치를 취해야 합니다.
예를 들어, 수체 체의 정교한 개선조차도 이러한 **비용의 지수적 확장을 피하는 데 실패**합니다.
반면에 **다항식 비용 알고리즘은 어떤 식으로든 문제 구조를 활용하여 지수적 확장을 피합니다**.

실제로, 문제에 대한 다항식 비용 알고리즘의 식별은 실제 효율성을 향한 첫걸음에 불과합니다.
알고리즘적 개선을 통해, 큰 지수를 가진 다항식 비용 알고리즘은 때때로 극적으로 개선되어 비용을 더 "합리적인" 다항식 확장으로 낮출 수 있습니다.
때로는 가능하다고 알려지면 일이 더 쉬워지므로, 문제에 대한 다항식 비용 알고리즘의 식별은 **새롭고 훨씬 더 효율적인 알고리즘을 고안하는 영감**을 줄 수도 있습니다.

고전 컴퓨팅에 대한 **양자 컴퓨팅의 이점**을 고려할 때, 우리의 시선은 일반적으로 **지수적 이점**, 또는 적어도 **초다항식적 이점** — 이상적으로는 다항식 비용 고전 알고리즘이 알려져 있지 않은 문제에 대해 다항식 비용 양자 알고리즘을 찾는 데 먼저 향합니다.
이러한 수준의 이론적 이점은 실제적인 이점으로 이어질 가장 큰 가능성을 가집니다 — 그러나 그러한 이점을 식별하는 것은 극도로 어려운 도전입니다.
현재까지 몇 가지 예시만이 알려져 있지만, 탐색은 계속되고 있습니다.

양자가 고전에 비해 계산 비용에서 **다항식 (그러나 초다항식은 아닌) 이점**을 가지는 것도 흥미롭고 무시되어서는 안 됩니다 — 그러나 양자 및 고전 컴퓨팅 기술 간의 현재 격차를 고려할 때, 현재로서는 다소 덜 설득력 있어 보입니다.

그러나 언젠가는 중요해질 수 있습니다.
예를 들어, 이후 수업에서 다루는 **그로버 알고리즘**은 소위 **비정형 검색**에 대해 **양자가 고전에 비해 2차 이점**을 제공하며, 광범위한 응용 가능성을 가집니다.

### 4.7 회로 계산의 숨겨진 비용

마지막으로 언급할 가치가 있는 한 가지 문제가 있지만, 이 과정에서는 더 이상 신경 쓰지 않을 것입니다.
회로를 다룰 때 "숨겨진" 계산 비용이 있으며, 이는 **회로 자체의 사양**에 관한 것입니다.
입력이 길어질수록 더 큰 회로가 필요합니다 — 그러나 우리가 그것들을 구현하려면 **이러한 회로에 대한 설명을 어떤 식으로든 얻어야 합니다**.

우리가 논의했거나 이후 수업에서 논의할 모든 예시에는 **회로가 파생되는 기본 알고리즘**이 있습니다.
일반적으로 패밀리의 회로는 **점점 더 큰 입력으로 쉽게 외삽할 수 있는 몇 가지 기본 패턴**을 따릅니다. 예를 들어, 전가산기를 캐스케이드하여 덧셈을 위한 불 회로를 만들거나, 하다마르 게이트 및 기타 게이트 레이어를 간단하게 설명할 수 있는 패턴으로 수행하는 것과 같습니다.

그러나 **회로 자체의 패턴과 관련된 엄청난 계산 비용이 있다면 어떻게 될까요?**
예를 들어, 회로 패밀리의 각 구성원 $C_n$의 설명은 원칙적으로 $n$의 매우 계산하기 어려운 함수에 의해 결정될 수 있습니다.

답은 이것이 실제로 문제라는 것입니다 — 그래서 우리는 **회로 패밀리가 진정으로 효율적인 알고리즘을 나타내기 위해 다항식 비용을 넘어서는 추가적인 제한을 두어야 합니다**.
회로의 **균일성 (uniformity)** 속성은 다양한 정확한 공식화를 통해 **패밀리의 각 회로에 대한 설명을 계산적으로 쉽게 얻을 수 있어야 한다고 규정함으로써 이를 수행**합니다.
우리가 논의할 모든 회로 패밀리는 이 속성을 가집니다 — 그러나 이것은 형식적인 관점에서 계산의 회로 모델을 연구할 때 일반적으로 알아야 할 중요한 문제입니다.