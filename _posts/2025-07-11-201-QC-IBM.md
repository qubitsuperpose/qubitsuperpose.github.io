---
title: 6차시 1:Quantum Query Algorithms(The query model of computation)
layout: single
classes: wide
categories:
  - Fundamentals of quantum algorithms
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

# 질의 계산 모델

- 출처: [The query model of computation](https://quantum.cloud.ibm.com/learning/en/courses/fundamentals-of-quantum-algorithms/quantum-query-algorithms/query-model-of-computation)

우리가 계산을 수학적인 용어로 모델링할 때, 일반적으로 다음 그림으로 표현되는 종류의 프로세스를 염두에 둡니다. 이 프로세스에서는 정보가 입력으로 제공되고, 계산이 이루어지며, 출력이 생성됩니다.

<img src="{{site.url}}{{site.baseurl}}/assets/images/QC2/standard-computation.svg" alt="Example of a Boolean circuit" style="width: 50%;" />


오늘날 우리가 사용하는 컴퓨터가 지속적으로 입력을 받고 출력을 생성하며, 본질적으로 그림에 반영되지 않은 방식으로 우리 및 다른 컴퓨터와 상호 작용하는 것은 사실이지만, 이는 컴퓨터의 **지속적인 작동을 나타내려는 의도가 아닙니다**. 오히려, 이는 **단일 계산 작업에 초점을 맞춰 계산의 단순한 추상화를 생성하기 위함입니다**.

예를 들어, 입력은 숫자, 벡터, 행렬, 그래프, 분자 설명 또는 더 복잡한 것을 인코딩할 수 있으며, 출력은 우리가 염두에 둔 계산 작업에 대한 해답을 인코딩합니다. 핵심은 **입력이 일반적으로 이진 문자열 형태로 계산에 제공되며, 그 어떤 부분도 숨겨지지 않는다는 것**입니다.

## 1. 모델 설명

**질의 계산 모델**에서는 위에서 제안된 더 표준적인 모델처럼 **전체 입력이 계산에 제공되지 않습니다**. 오히려, 입력은 계산이 **질의를 수행하여 접근하는 *함수*** 형태로 제공됩니다. 대안적으로, 우리는 질의 모델에서의 계산이 입력의 비트(또는 비트 세그먼트)에 대해 **임의 접근**을 갖는 것으로 볼 수 있습니다.

<img src="{{site.url}}{{site.baseurl}}/assets/images/QC2/query-computation.svg" alt="Example of a Boolean circuit" style="width: 50%;" />

우리는 질의 모델의 맥락에서 입력이 **'오라클' 또는 '블랙박스'에 의해 제공된다고 자주 언급합니다**. 두 용어 모두 **입력에 대한 완전한 설명이 계산에서 숨겨져 있으며, 이에 접근하는 유일한 방법은 질문을 하는 것임을 시사합니다**. 마치 델피의 오라클에게 입력에 대해 상담하는 것과 같습니다: 그녀는 아는 모든 것을 말해주지 않고, 특정 질문에만 답합니다. **'블랙박스'라는 용어는 입력이 함수로 표현된다고 생각할 때 특히 합리적입니다**. 우리는 함수 내부를 들여다보고 작동 방식을 이해할 수 없으며, 우리가 선택한 인수에 대해서만 함수를 평가할 수 있습니다.

이 단원에서는 다른 기호를 포함하는 문자열과 달리 **이진 문자열만 다룰 것이므로, 편의상 이진 알파벳을 나타내기 위해 $\Sigma = \{0,1\}$라고 쓰겠습니다**. 우리는 곧 몇 가지 간단한 예시와 함께 다양한 계산 문제를 다룰 것이지만, 모든 문제에서 **입력은 다음과 같은 형태의 함수로 표현됩니다**. 
\[
f:\Sigma^n \rightarrow \Sigma^m
\]
두 양의 정수 $n$과 $m$에 대해. 자연스럽게, 우리는 $f$ 대신 다른 이름을 선택할 수 있지만, 이 단원 내내 $f$를 사용하겠습니다.

계산이 **'질의'를 수행한다는 것은 어떤 문자열 $x \in \Sigma^n$가 선택되고, 그 다음 오라클에 의해 문자열 $f(x)\in\Sigma^m$가 계산에 제공됨을 의미합니다**. 이것이 양자 알고리즘에서 정확히 어떻게 작동하는지는 곧 논의될 것입니다 — 우리는 질의가 중첩 상태에서 이루어질 수 있도록 유니타리 양자 연산을 통해 이것이 가능한지 확인해야 합니다 — 하지만 지금은 높은 수준에서 직관적으로 생각할 수 있습니다. 

마지막으로, **질의 알고리즘의 효율성을 측정하는 방법은 간단합니다: 필요한 '질의 횟수'를 세는 것입니다**.
이것은 계산을 수행하는 데 필요한 시간과 관련이 있지만, 질의 외의 연산에 대한 시간을 무시하고 각 질의가 단위 비용을 갖는 것으로 취급하기 때문에 **정확히 같지는 않습니다**. 원한다면 질의 외의 연산도 고려할 수 있지만 (때로는 그렇게 합니다), **질의 횟수에만 초점을 맞추는 것이 일을 간단하게 유지하는 데 도움이 됩니다**.

## 2. 질의 문제 예시

다음은 몇 가지 간단한 질의 문제 예시입니다.

*   **OR.** 입력 함수는 $f:\Sigma^n \rightarrow \Sigma$ 형태를 취합니다 (이 문제에서는 $m=1$). **작업은 $f(x) = 1$인 문자열 $x\in\Sigma^n$가 존재하면 $1$을 출력하고, 그러한 문자열이 없으면 $0$을 출력하는 것입니다**. 함수 $f$를 우리가 임의 접근할 수 있는 $2^n$개의 비트 시퀀스로 생각한다면, 이 문제는 이 비트들의 OR을 계산하는 것입니다.

*   **Parity.** 입력 함수는 다시 $f:\Sigma^n \rightarrow \Sigma$ 형태를 취합니다. **작업은 $f(x) = 1$인 문자열 $x\in\Sigma^n$의 개수가 *짝수*인지 *홀수*인지를 결정하는 것입니다**. 정확히 말하면, 집합 $\{x\in\Sigma^n : f(x) = 1\}$의 원소 수가 짝수이면 $0$을, 홀수이면 $1$을 출력해야 합니다. 함수 $f$를 우리가 임의 접근할 수 있는 $2^n$개의 비트 시퀀스로 생각한다면, 이 문제는 이 비트들의 패리티(또는 배타적 OR)를 계산하는 것입니다.

*   **Minimum.** 입력 함수는 양의 정수 $n$과 $m$의 어떤 선택에 대해서도 $f:\Sigma^n \rightarrow \Sigma^m$ 형태를 취합니다. **요구되는 출력은 $\Sigma^m$의 사전식 (즉, 사전) 순서에서 가장 먼저 오는 문자열 $y \in \{f(x) : x\in\Sigma^n\}$입니다**. 함수 $f$를 우리가 임의 접근할 수 있는, 이진 표기법으로 길이 $m$의 문자열로 인코딩된 $2^n$개의 정수 시퀀스로 생각한다면, 이 문제는 이 정수들의 최소값을 계산하는 것입니다.

또한, 우리는 입력에 대한 **'약속(promise)'이 있는 질의 문제**를 고려합니다. 이것은 입력에 대한 **어떤 종류의 보장이 주어진다는 의미이며, 이 보장이 충족되지 않을 때 발생하는 일에 대해서는 우리가 책임지지 않는다는 것**입니다. 이러한 유형의 문제를 설명하는 또 다른 방법은 일부 입력 함수(약속이 충족되지 않는 함수)가 "**신경 쓰지 않아도 되는(don't care)**" 입력으로 간주된다고 말하는 것입니다. "신경 쓰지 않아도 되는" 입력이 주어질 때는 알고리즘에 **어떤 요구 사항도 부과되지 않습니다**.

다음은 약속이 있는 문제의 한 예시입니다.

*   **고유 검색(Unique search).** 입력 함수는 $f:\Sigma^n \rightarrow \Sigma$ 형태를 취하며, **$f(z) = 1$인 문자열 $z\in\Sigma^n$가 정확히 하나 존재하고, $x\neq z$인 모든 문자열 $x$에 대해 $f(x) = 0$이라고 *약속됩니다***. **작업은 이 고유한 문자열 $z$를 찾는 것입니다**.

방금 설명된 네 가지 예시는 모두 자연스러운데, 이는 설명하기 쉽고 다양한 상황이나 문맥에서 발생할 수 있다고 상상할 수 있다는 의미입니다. 

대조적으로, 어떤 질의 문제들은 이처럼 **전혀 "자연스럽지" 않습니다**. 사실, 질의 모델 연구에서는 때때로 **매우 복잡하고 고도로 인위적인 문제들이 고안되는데, 실제로는 아무도 풀고 싶어 하지 않을 것이라고 상상하기 어렵습니다**. 하지만 그렇다고 해서 그 문제들이 흥미롭지 않다는 뜻은 아닙니다! 처음에는 인위적이거나 부자연스럽게 보일 수 있는 것들이 예상치 못한 단서를 제공하거나 새로운 아이디어를 불러일으킬 수 있습니다. Simon의 알고리즘에서 영감을 받은 Shor의 양자 소인수분해 알고리즘이 훌륭한 예시입니다. 또한, 질의 모델 연구에서 **극단적인 사례를 찾는 것은 중요한 부분이며, 이는 양자 컴퓨팅의 잠재적 장점과 한계 모두를 밝혀줄 수 있습니다**.

## 3. 질의 게이트

회로로 계산을 설명할 때, 질의는 **'질의 게이트'라고 불리는 특별한 게이트에 의해 이루어집니다**. 

고전적인 불리언 회로에서 질의 게이트를 정의하는 가장 간단한 방법은 다음 그림이 제안하듯이 **입력 함수 $f$를 직접 계산하도록 허용하는 것**입니다.

<img src="{{site.url}}{{site.baseurl}}/assets/images/QC2/classical-query-gate.svg" alt="Example of a Boolean circuit" style="width: 50%;" />

질의 문제를 위해 불리언 회로가 생성될 때, **입력 함수 $f$는 이러한 게이트를 통해 접근되며, 회로가 수행하는 질의 횟수는 회로에 나타나는 질의 게이트의 수와 단순히 같습니다**. 불리언 회로 자체의 입력 와이어는 **고정된 값으로 초기화되며, 이는 알고리즘의 일부로 간주되어야 합니다** (문제의 입력이 아니라).

예를 들어, 다음은 $f:\Sigma\rightarrow\Sigma$ 형태의 함수에 대해 위에서 설명한 패리티 문제를 해결하는 고전적인 질의 게이트를 가진 불리언 회로입니다.

<img src="{{site.url}}{{site.baseurl}}/assets/images/QC2/classical-parity.svg" alt="Example of a Boolean circuit" style="width: 50%;" />


이 알고리즘은 **두 개의 질의 게이트가 있으므로 두 번의 질의를 수행합니다**. 작동 방식은 함수 $f$가 가능한 두 입력인 $0$과 $1$에 대해 질의되고, 그 결과는 XOR을 계산하는 불리언 회로에 연결됩니다. (이 특정 회로는 *양자 정보 기초* 과정의 *양자 회로* 단원에서 불리언 회로의 예시로 나타났습니다).

양자 회로의 경우, **이러한 질의 게이트 정의는 작동하지 않습니다. 왜냐하면 일부 함수 $f$의 선택에 대해 이러한 게이트가 비유니타리일 것이기 때문입니다**. 그래서 우리는 대신 **표준 기저 상태에서 이 그림이 제안하는 대로 작동하는 *유니타리 질의 게이트*를 정의합니다**.

<img src="{{site.url}}{{site.baseurl}}/assets/images/QC2/unitary-query-gate.svg" alt="Example of a Boolean circuit" style="width: 50%;" />

여기서 우리의 가정은 $x\in\Sigma^n$와 $y\in\Sigma^m$가 임의의 문자열이라는 것입니다. $y\oplus f(x)$ 표기법은 이 경우 길이 $m$을 가지는 두 문자열의 **비트별 배타적 OR**을 나타냅니다. 예를 들어, $001 \oplus 101 = 100$입니다. 

직관적으로 말해, **게이트 $U_f$는 (어떤 선택된 함수 $f$에 대해서도) 상위 입력 문자열 $x$를 반향하고, 함수 값 $f(x)$를 하위 입력 문자열 $y$에 XOR하는 것**이며, 이는 함수 $f$의 모든 선택에 대해 **유니타리 연산**입니다. 사실, 이것은 **확정적 연산이며, 자기 역입니다**. 이는 행렬로서 $U_f$가 항상 **'순열 행렬'임을 의미합니다. 순열 행렬은 각 행과 각 열에 하나의 $1$만 있고, 다른 모든 엔트리는 $0$인 행렬**입니다. 순열 행렬을 벡터에 적용하는 것은 단순히 벡터의 엔트리를 섞는 것이며 (이것이 *순열 행렬*이라는 용어의 유래입니다), 따라서 해당 벡터의 유클리드 노름을 변경하지 않습니다 — 이는 **순열 행렬이 항상 유니타리임을 보여줍니다**.

질의 알고리즘이 수행하는 질의 횟수를 단순히 세어 질의 알고리즘을 분석할 때, **방금 설명한 고전적 및 양자 버전 모두에서 질의 게이트를 물리적으로 구성하는 어려움을 완전히 무시하고 있다는 점**을 강조해야 합니다. 직관적으로 말해, **질의 게이트의 구성은 입력 준비의 일부이지, 해답을 찾는 과정의 일부가 아닙니다**. 

그것이 불합리하게 보일 수도 있지만, 우리는 **실제적인 컴퓨팅을 묘사하거나 필요한 자원을 완전히 설명하려는 것이 아님을 명심해야 합니다**. 오히려, 우리는 **양자 컴퓨팅의 잠재적 장점을 밝히는 데 도움이 되는 이론적 모델을 정의하고 있습니다**. 입력이 회로에 이진 문자열로 명시적으로 주어지는 더 표준적인 계산 모델로 전환할 다음 단원에서 이 점에 대해 더 자세히 설명할 것입니다.