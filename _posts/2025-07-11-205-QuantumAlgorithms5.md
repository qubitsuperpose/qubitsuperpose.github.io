---
title: 6차시 5:Fundamentals of quantum algorithms(Factoring and GCDs)
layout: single
classes: wide
categories:
  - Fundamentals of quantum algorithms
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

# **인수분해와 최대공약수**
- 출처: [Two examples: factoring and GCDs](https://quantum.cloud.ibm.com/learning/en/courses/fundamentals-of-quantum-algorithms/quantum-algorithmic-foundations/factoring-and-gcd)

오늘날 존재하는 **고전 컴퓨터**는 놀랍도록 빠르며, 그 속도는 끊임없이 증가하는 것처럼 보인다. 이러한 이유로, 어떤 사람들은 컴퓨터가 너무 빨라서 어떤 **계산 문제**도 그 능력을 벗어나지 못한다고 믿는 경향이 있을 수 있다. 

**이 믿음은 거짓이다**. 일부 **계산 문제**는 본질적으로 너무 복잡하여, 비록 그것들을 해결할 **알고리즘**이 존재하더라도, 오늘날 지구상의 어떤 컴퓨터도 인간의 수명 내에 — 심지어 지구 자체의 수명 내에도 — 중간 크기 정도의 입력에 대해서조차 이 **알고리즘**들을 완벽하게 실행할 만큼 빠르지 않다.

더 자세히 설명하기 위해, **정수 인수분해** 문제를 소개하겠다.
>   **정수 인수분해** \
>   입력: 정수 \
>   출력: $N$의 소인수분해

$N$의 **소인수분해**란 $N$의 **소인수**들과, 이들을 곱하여 $N$을 얻기 위해 각 **소인수**를 몇 제곱해야 하는지를 나타내는 목록을 의미한다. 
예를 들어, $12$의 **소인수**는 $2$와 $3$이며, $12$를 얻기 위해서는 $2$를 $2$제곱하고 $3$을 $1$제곱한 것의 곱을 취해야 한다.
\[
12 = 2^2 \cdot 3
\]

**소인수**의 순서를 고려하지 않으면, 각 양의 정수에 대해 오직 하나의 **소인수분해**만이 존재하며, 이는 **산술의 기본 정리**로 알려진 사실이다. 

파이썬으로 작성된 몇 가지 간단한 코드 시연은 **정수 인수분해** 및 이 논의와 관련된 다른 개념들을 더 설명하는 데 도움이 될 것이다. 이러한 시연을 위해 다음 **임포트**가 필요하다.

```
import math
from sympy.ntheory import factorint
```
Python용 기호 수학 패키지 `SymPy`의 `factorint` 함수는 입력 $N$에 대한 정수 인수분해 문제를 해결합니다. 예를 들어, 12에 대한 소인수분해를 얻을 수 있는데, 이는 위의 인수분해와 자연스럽게 일치합니다.

```
N = 12
print(factorint(N))
```

12와 같은 작은 수를 인수분해하는 것은 쉽지만, 인수분해할 수 N이 커지면 문제는 더 어려워집니다.

예를 들어, 훨씬 큰 수에 대해 `factorint`를 실행하면 일반적인 개인용 컴퓨터에서 짧지만 눈에 띄는 지연이 발생합니다.

```
N = 3402823669209384634633740743176823109843098343
print(factorint(N))
```

$N$의 값이 더 커지면, 적어도 우리가 아는 한 상황은 엄청나게 어려워집니다.

예를 들어, 1991년부터 2007년까지 RSA 연구소에서 운영한 *RSA 인수분해 챌린지*는 십진수 309자리(이진수로 표현하면 1024비트)의 다음 수를 인수분해하는 사람에게 10만 달러의 상금을 걸었습니다.
이 수에 대한 상금은 수령되지 않았고, 그 소인수분해 결과는 아직 알려지지 않았습니다.

```
RSA1024 = 135066410865995223349603216278805969938881475605667027524485143851526510604859533833940287150571909441798207282164471551373680419703964191743046496589274256239341020864383202110372958725762358509643110564073501508187510676594629205563685529475213500852879416377328533906109750544334999811150056977236890927563
print(RSA1024)
```

RSA1024에서 `factorint`를 실행할 필요는 없습니다. 우리 생애 안에 끝나지 않을 테니까요.

큰 정수를 인수분해하는 가장 빠른 알고리즘은 *숫자 체 거름법*으로 알려져 있습니다.
이 알고리즘의 사용 사례로, 십진수 250자리(이진수로는 829비트)를 가진 RSA 챌린지 번호 RSA250이 2020년에 수체 거름법을 사용하여 인수분해되었습니다.
이 계산에는 전 세계 수만 대의 컴퓨터에 분산된 수천 개의 CPU 코어-년(core-year)이 필요했습니다.

여기서 해답을 확인하여 이러한 노력을 평가할 수 있습니다.

```
RSA250 = 2140324650240744961264423072839333563008614715144755017797754920881418023447140136643345519095804679610992851872470914587687396261921557363047454770520805119056493106687691590019759405693457452230589325976697471681738069364894699871578494975937497937

p = 64135289477071580278790190170577389084825014742943447208116859632024532344630238623598752668347708737661925585694639798853367
q = 33372027594978156556226010605355114227940760344767554666784520987023841729210037080257448673296881877565718986258036932062711

print(RSA250 == p * q)
```

RSA 공개 키 암호 시스템의 보안성은 정수 인수분해의 계산적 어려움에 기반합니다. 즉, 효율적인 정수 인수분해 알고리즘이 이를 깨뜨릴 수 있다는 의미입니다.

다음으로, 관련은 있지만 매우 다른 문제인 두 정수의 최대공약수(GCD)를 계산하는 문제를 살펴보겠습니다.

> **최대공약수(GCD)** \
> 입력: 음이 아닌 정수 $N$과 $M$, 그중 적어도 하나는 양수 \
> 출력: $N$과 $M$의 최대공약수

두 수의 최대공약수는 두 수를 나누어 떨어지는 가장 큰 정수입니다.

이 문제는 컴퓨터를 사용하면 쉽게 해결할 수 있습니다. 두 입력 숫자를 곱하는 것과 거의 같은 계산 비용이 듭니다.
Python `math` 모듈의 `gcd` 함수는 RSA1024보다 훨씬 큰 수의 최대공약수를 눈 깜짝할 사이에 계산합니다. (실제로, 이 예에서 RSA1024는 두 숫자의 최대공약수입니다.)

```
N = 4636759690183918349682239573236686632636353319755818421393667064929987310592347460711767784882455889983961546491666129915628431549982893638464243493812487979530329460863532041588297885958272943021122033997933550246447236884738870576045537199814804920281890355275625050796526864093092006894744790739778376848205654332434378295899591539239698896074
M = 5056714874804877864225164843977749374751021379176083540426461360945653967249306494545888621353613218518084414930846655066495767441010526886803458300440345782982127522212209489410315422285463057656809702949608368597012967321172325810519806487247195259818074918082416290513738155834341957254558278151385588990304622183174568167973121179585331770773

print(math.gcd(N, M))
```

이것이 가능한 이유는 최대공약수(GCD)를 계산하는 매우 효율적인 알고리즘이 있기 때문입니다. 그중 가장 잘 알려진 것은 2,000년 전에 발견된 *유클리드 알고리즘*입니다.

우리가 아직 발견하지 못한, RSA1024와 같은 큰 수를 눈 깜짝할 새에 인수분해할 수 있는 빠른 정수 인수분해 알고리즘이 있을까요?
정답은 '예'입니다.

유클리드의 최대공약수 계산 알고리즘처럼 간단하고 우아한 효율적인 인수분해 알고리즘이 지금쯤 발견되었을 것이라고 기대할 수 있지만, 지금까지 찾지 못했다는 사실 외에는 매우 빠른 고전적 정수 인수분해 알고리즘의 존재를 배제할 수 있는 것은 없습니다.
내일 발견될 수도 있지만, 기대하지 마세요.
수 세대에 걸쳐 수학자와 컴퓨터 과학자들이 RSA1024와 같은 수를 인수분해하는 것은 여전히 우리의 손이 닿지 않는 곳에 있습니다.
