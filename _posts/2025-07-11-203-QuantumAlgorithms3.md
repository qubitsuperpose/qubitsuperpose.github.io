---
title: 6차시 3:Fundamentals of quantum algorithms(The Deutsch-Jozsa algorithm)
layout: single
classes: wide
categories:
  - Fundamentals of quantum algorithms
toc: true # 이 포스트에서 목차를 활성화
toc_sticky: true # 목차를 고정할지 여부 (선택 사항)
---

# **도이치-조사 알고리즘**

- 출처: [The Deutsch-Jozsa algorithm](http://localhost:4000/fundamentals%20of%20quantum%20algorithms/203-QC-IBM/)

도이치 알고리즘은 질의 문제에 대해 모든 고전 알고리즘을 능가하지만, 그 이점은 꽤 미미합니다: 한 번의 질의 대 두 번의 질의. 도이치-조사 알고리즘은 이러한 이점을 확장하며 — 사실상, 몇 가지 다른 질의 문제를 해결하는 데 사용될 수 있습니다. 

여기에 도이치-조사 알고리즘의 양자 회로 설명이 있습니다. 그림에는 나와 있지 않지만, 해결하려는 특정 문제에 따라 추가적인 고전적인 후처리 단계가 필요할 수도 있습니다.

<img src="{{site.url}}{{site.baseurl}}/assets/images/QC2/Deutsch-Jozsa.svg" alt="Example of a Boolean circuit" style="width: 50%;" />


물론, 우리는 이 알고리즘이 어떤 문제를 해결하는지에 대해 실제로 논의하지 않았습니다; 이는 이어지는 두 섹션에서 다룹니다.

## 1. **도이치-조사 문제**

우리는 도이치-조사 알고리즘이 원래 해결하고자 했던 질의 문제인 *도이치-조사 문제*로 시작하겠습니다. 

이 문제의 입력 함수는 임의의 양의 정수 $n$에 대해 $f:\Sigma^n \rightarrow \Sigma$ 형태를 취합니다. 도이치 문제와 마찬가지로, $f$가 상수이면 $0$을 출력하고 $f$가 균형이면 $1$을 출력하는 것이 과제입니다. 여기서 균형이라는 것은 함수가 값 $0$을 취하는 입력 문자열의 수가 함수가 값 $1$을 취하는 입력 문자열의 수와 같다는 것을 다시 의미합니다.

$n$이 $1$보다 클 때, $f:\Sigma^n \rightarrow \Sigma$ 형태의 함수 중 상수도 아니고 균형도 아닌 함수가 있다는 점에 유의하십시오. 예를 들어, 함수 $f:\Sigma^2\rightarrow\Sigma$는 다음과 같이 정의됩니다.

<br>
$$
\begin{aligned}
f(00) & = 0 \\
f(01) & = 0 \\
f(10) & = 0 \\
f(11) & = 1
\end{aligned}
$$

이 함수는 이 두 범주 중 어느 쪽에도 속하지 않습니다. 도이치-조사 문제의 경우, 우리는 이러한 함수에 대해 단순히 신경 쓰지 않습니다 — 이들은 "관심 없는(don't care)" 입력으로 간주됩니다. 즉, 이 문제에서는 $f$가 상수이거나 균형이라는 **약속(promise)**이 있습니다.

*   **도이치-조사 문제**
    *   입력: 함수 $f:\\{0,1\\}^n\rightarrow\\{0,1\\}$
    *   약속: $f$는 상수이거나 균형이다
    *   출력: $f$가 상수이면 $0$, $f$가 균형이면 $1$

도이치-조사 알고리즘은 단 한 번의 질의로 이 문제를 다음과 같은 의미에서 해결합니다: $n$개의 측정 결과가 모두 $0$이라면, 함수 $f$는 상수입니다; 그렇지 않고, 측정 결과 중 적어도 하나가 $1$이라면, 함수 $f$는 균형입니다. 다른 말로 하면, 위에 설명된 회로는 측정 결과의 OR 연산을 계산하여 출력을 생성하는 고전적인 후처리 단계가 뒤따릅니다.

### 1.1 **알고리즘 분석**

도이치-조사 문제에 대한 도이치-조사 알고리즘의 성능을 분석하기 위해, 단일 하다마르 게이트 층의 동작에 대해 생각하는 것부터 시작하는 것이 유용합니다. 하다마르 연산은 일반적인 방식으로 행렬로 표현될 수 있습니다,

<br>
$$
H = \begin{pmatrix}
\frac{1}{\sqrt{2}} & \frac{1}{\sqrt{2}} \\[2mm]
\frac{1}{\sqrt{2}} & -\frac{1}{\sqrt{2}}
\end{pmatrix},
$$

하지만 우리는 이 연산을 표준 기저 상태에 대한 동작으로도 표현할 수 있습니다:
\[
H \vert 0\rangle  = \frac{1}{\sqrt{2}} \vert 0 \rangle + \frac{1}{\sqrt{2}} \vert 1 \rangle
H \vert 1\rangle  = \frac{1}{\sqrt{2}} \vert 0 \rangle - \frac{1}{\sqrt{2}} \vert 1 \rangle.
\]

이 두 방정식은 하나의 공식으로 결합될 수 있습니다,
\[
H \vert a \rangle = \frac{1}{\sqrt{2}} \vert 0 \rangle + \frac{1}{\sqrt{2}} (-1)^a \vert 1 \rangle
= \frac{1}{\sqrt{2}} \sum_{b\in\{0,1\}} (-1)^{ab} \vert b\rangle,
\]

이는 $a\in\Sigma$의 두 가지 선택 모두에 대해 참입니다. 이제 단일 큐비트 대신 $n$개의 큐비트가 있고, 각각에 하다마르 연산이 수행된다고 가정해 봅시다.

$n$개의 큐비트에 대한 결합된 연산은 텐서곱 $H\otimes \cdots \otimes H$ ($n$회)로 설명되며, 간결성과 명확성을 위해 이를 $H^{\otimes n}$으로 표기합니다. 위의 공식을 사용하여, 확장한 다음 단순화함으로써, 이 결합된 연산이 $n$개 큐비트의 표준 기저 상태에 미치는 영향을 다음과 같이 표현할 수 있습니다:

\[
 H^{\otimes n} \vert x_{n-1} \cdots x_1 x_0 \rangle \\
 \qquad = \bigl(H \vert x_{n-1} \rangle \bigr) \otimes \cdots \otimes \bigl(H \vert x_{0} \rangle \bigr) \]
 \[ \qquad = \Biggl( \frac{1}{\sqrt{2}} \sum_{y_{n-1}\in\Sigma} (-1)^{x_{n-1} y_{n-1}} \vert y_{n-1} \rangle \Biggr)
\otimes \cdots \otimes
\Biggl( \frac{1}{\sqrt{2}} \sum_{y_{0}\in\Sigma} (-1)^{x_{0} y_{0}} \vert y_{0} \rangle \Biggr) \]
\[ \qquad = \frac{1}{\sqrt{2^n}} \sum_{y_{n-1}\cdots y_0 \in \Sigma^n}
(-1)^{x_{n-1}y_{n-1} + \cdots + x_0 y_0} \vert y_{n-1} \cdots y_0 \rangle.
\]

참고로, 여기서 우리는 Qiskit의 인덱싱 규칙에 따라 길이 $n$의 이진 문자열을 $x_{n-1}\cdots x_0$와 $y_{n-1}\cdots y_0$로 작성하고 있습니다.

이 공식은 위 양자 회로를 분석하는 데 유용한 도구를 제공합니다. 하다마르 게이트의 첫 번째 층이 수행된 후, $n+1$개의 큐비트(나머지와 별도로 취급되는 가장 왼쪽/아래쪽 큐비트 포함)의 상태는 다음과 같습니다:
\[
\bigl( H \vert 1 \rangle \bigr) \bigl( H^{\otimes n} \vert 0 \cdots 0 \rangle \bigr)
= \vert - \rangle \otimes \frac{1}{\sqrt{2^n}} \sum_{x_{n-1}\cdots x_0 \in \Sigma^n} \vert x_{n-1} \cdots x_0 \rangle.
\]

$U_f$ 연산이 수행되면, 이 상태는 다음으로 변환됩니다:
\[
\vert - \rangle \otimes \frac{1}{\sqrt{2^n}}
\sum_{x_{n-1}\cdots x_0 \in \Sigma^n} (-1)^{f(x_{n-1}\cdots x_0)} \vert x_{n-1} \cdots x_0 \rangle
\]

도이치 알고리즘 분석에서 보았던 것과 정확히 동일한 위상 킥백(phase kick-back) 현상을 통해. 그 다음 하다마르 게이트의 두 번째 층이 수행되는데, 이는 (위 공식에 의해) 이 상태를 다음으로 변환합니다:
\[
\vert - \rangle \otimes \frac{1}{2^n}
\sum_{x_{n-1}\cdots x_0 \in \Sigma^n}
\sum_{y_{n-1}\cdots y_0 \in \Sigma^n}
(-1)^{f(x_{n-1}\cdots x_0) + x_{n-1}y_{n-1} + \cdots + x_0 y_0}
\vert y_{n-1} \cdots y_0 \rangle.
\]


이 표현은 다소 복잡해 보이며, 함수 $f$에 대해 더 많이 알지 않고서는 다른 측정 결과를 얻을 확률에 대해 많은 것을 결론 내릴 수 없습니다. 다행히도, 우리가 알아야 할 것은 모든 측정 결과가 $0$일 확률 뿐입니다 — 왜냐하면 그것이 알고리즘이 $f$가 상수라고 판단하는 확률이기 때문입니다. 이 확률은 간단한 공식을 가지고 있습니다.

<br>
$$
\Biggl\vert
\frac{1}{2^n}
\sum_{x_{n-1}\cdots x_0 \in \Sigma^n}
(-1)^{f(x_{n-1}\cdots x_0)}
\Biggr\vert^2
= \begin{cases}
1 & \text{if $f$ is constant}\\[1mm]
0 & \text{if $f$ is balanced}
\end{cases}
$$

더 자세히 말하면, $f$가 상수이면, 모든 문자열 $x_{n-1}\cdots x_0$에 대해 $f(x_{n-1}\cdots x_0) = 0$이거나, 이 경우 합의 값은 $2^n$이거나, 모든 문자열 $x_{n-1}\cdots x_0$에 대해 $f(x_{n-1}\cdots x_0) = 1$입니다, 이 경우 합의 값은 $-2^n$입니다. $2^n$으로 나누고 절댓값의 제곱을 취하면 $1$이 됩니다. 

반면에 $f$가 균형이면, $f$는 문자열 $x_{n-1}\cdots x_0$의 절반에 대해 $0$ 값을 취하고 나머지 절반에 대해 $1$ 값을 취하므로, 합에서 $+1$항과 $-1$항이 상쇄되어 값 $0$이 남습니다.

우리는 약속이 지켜진다면 알고리즘이 올바르게 작동한다고 결론 내립니다.

### 1.2 **고전적 난이도**

도이치-조사 알고리즘은 약속이 충족되면 항상 올바른 답을 주며 매번 작동하고, 단 한 번의 질의를 필요로 합니다. 이것이 도이치-조사 문제에 대한 고전적 질의 알고리즘과 비교하여 어떻습니까? 

첫째, 도이치-조사 문제를 올바르게 해결하는 모든 *결정론적* 고전 알고리즘은 기하급수적으로 많은 질의를 해야 합니다: 최악의 경우 $2^{n-1} + 1$회의 질의가 필요합니다.
그 이유는 결정론적 알고리즘이 $2^{n-1}$개 이하의 다른 문자열에 대해 $f$를 질의하고 매번 동일한 함수 값을 얻는다면, 두 가지 답(상수 또는 균형) 모두 여전히 가능하기 때문입니다. 함수는 상수일 수도 있고, 아니면 균형이지만 운 나쁘게도 모든 질의가 동일한 함수 값을 반환하는 것일 수도 있습니다. 

두 번째 가능성은 희박해 보일 수 있지만 — 결정론적 알고리즘에는 무작위성이나 불확실성이 없으므로, 특정 함수에 대해 체계적으로 실패할 것입니다. 따라서 우리는 이 점에서 고전 알고리즘에 대한 양자 알고리즘의 상당한 이점을 가지고 있습니다.

그러나 함정이 있습니다. 즉, *확률론적* 고전 알고리즘은 몇 번의 질의만으로 도이치-조사 문제를 매우 높은 확률로 해결할 수 있다는 것입니다. 특히, 길이 $n$의 서로 다른 문자열 몇 개를 무작위로 선택하고 해당 문자열에 대해 $f$를 질의하면, $f$가 균형일 때 모든 문자열에 대해 동일한 함수 값을 얻을 가능성은 낮습니다. 

구체적으로 말하면, 우리가 $k$개의 입력 문자열 $x^1,\ldots,x^k \in \Sigma^n$를 균일하게 무작위로 선택하고, $f(x^1),\ldots,f(x^k)$를 평가한 다음, 함수 값이 모두 동일하면 $0$을, 그렇지 않으면 $1$을 답한다면, $f$가 상수일 때는 항상 올바르고, $f$가 균형인 경우에는 $2^{-k + 1}$의 확률로 틀리게 됩니다.
예를 들어, $k = 11$로 설정하면, 이 알고리즘은 $99.9$ %보다 높은 확률로 올바르게 답할 것입니다. 

이러한 이유로, 우리는 여전히 고전 알고리즘에 대한 양자 알고리즘의 다소 미미한 이점을 가지고 있습니다 — 하지만 이는 그럼에도 불구하고 도이치 알고리즘에 대한 개선을 나타내는 정량화 가능한 이점입니다.

## 2. **베른슈타인-바지라니 문제**

다음으로, 우리는 *베른슈타인-바지라니 문제*로 알려진 문제에 대해 논의할 것입니다. 이 문제에 대한 더 일반적인 공식들도 그 이름으로 불리지만, 이는 또한 *푸리에 샘플링 문제*라고도 불립니다.

먼저, 몇 가지 표기법을 소개하겠습니다. 길이 $n$의 임의의 두 이진 문자열 $x = x_{n-1} \cdots x_0$와 $y = y_{n-1}\cdots y_0$에 대해, 우리는 다음과 같이 정의합니다.
\[
x \cdot y = x_{n-1} y_{n-1} \oplus \cdots \oplus x_0 y_0.
\]

우리는 이 연산을 **이진 내적(binary dot product)**이라고 부를 것입니다. 이를 정의하는 또 다른 방법은 다음과 같습니다.


$x \cdot y$ = $$
\begin{cases}
1 & x_{\{n-1\}} y_{n-1} + \cdots + x_0 y_0 \text{ is odd} \\
0 & x_{\{n-1\}} y_{n-1} + \cdots + x_0 y_0 \text{ is even}
\end{cases}
$$

이는 대칭 연산이라는 점에 유의하십시오. 즉, $x$와 $y$를 바꾸어도 결과가 변하지 않으므로, 편리할 때마다 그렇게 할 수 있습니다.

때로는 이진 내적 $x \cdot y$를 문자열 $y$가 $1$을 가지는 위치에서 $x$의 비트의 패리티로, 또는 동등하게, 문자열 $x$가 $1$을 가지는 위치에서 $y$의 비트의 패리티로 생각하는 것이 유용합니다. 이러한 표기법을 바탕으로 이제 베른슈타인-바지라니 문제를 정의할 수 있습니다.

*   **베른슈타인-바지라니 문제**
    *   입력: 함수 $f:\\{0,1\\}^n\rightarrow\\{0,1\\}$
    *   약속: 모든 $x\in\Sigma^n$에 대해 $f(x) = s\cdot x$인 이진 문자열 $s = s_{n-1} \cdots s_0$가 존재한다
    *   출력: 문자열 $s$

이 문제를 위해 새로운 양자 알고리즘이 실제로 필요한 것은 아닙니다; 도이치-조사 알고리즘이 이를 해결합니다. 명확성을 위해, 위에 언급된 양자 회로(OR 연산을 계산하는 고전적인 후처리 단계가 포함되지 않은)를 **도이치-조사 회로**라고 부르겠습니다.

### 2.1 **알고리즘 분석**

베른슈타인-바지라니 문제의 약속을 만족하는 함수에 대해 도이치-조사 회로가 어떻게 작동하는지 분석하기 위해, 간단한 관찰부터 시작하겠습니다. 이진 내적을 사용하여, $n$개의 하다마르 게이트가 $n$개 큐비트의 표준 기저 상태에 미치는 영향을 다음과 같이 대안적으로 설명할 수 있습니다.
\[
H^{\otimes n} \vert x \rangle = \frac{1}{\sqrt{2^n}} \sum_{y\in\Sigma^n} (-1)^{x\cdot y} \vert y\rangle
\]

도이치 알고리즘을 분석할 때 보았던 것과 유사하게, 이는 임의의 정수 $k$에 대한 값 $(-1)^k$이 $k$가 짝수인지 홀수인지에만 의존하기 때문입니다. 도이치-조사 회로로 돌아가서, 하다마르 게이트의 첫 번째 층이 수행된 후, $n+1$개의 큐비트의 상태는 다음과 같습니다.
\[
\vert - \rangle \otimes \frac{1}{\sqrt{2^n}} \sum_{x \in \Sigma^n} \vert x \rangle.
\]

그 다음 질의 게이트가 수행되는데, 이는 (위상 킥백 현상을 통해) 상태를 다음으로 변환합니다.
\[
\vert - \rangle \otimes \frac{1}{\sqrt{2^n}} \sum_{x \in \Sigma^n} (-1)^{f(x)} \vert x \rangle.
\]

하다마르 게이트 층의 동작에 대한 우리의 공식을 사용하면, 두 번째 하다마르 게이트 층이 이 상태를 다음으로 변환한다는 것을 알 수 있습니다.
\[
\vert - \rangle \otimes \frac{1}{2^n}
\sum_{x \in \Sigma^n} \sum_{y \in \Sigma^n} (-1)^{f(x) + x \cdot y} \vert y \rangle.
\]

이제 합 안에 있는 $-1$의 지수에서 몇 가지 단순화를 할 수 있습니다. 우리는 어떤 문자열 $s = s_{n-1} \cdots s_0$에 대해 $f(x) = s\cdot x$라는 약속을 받았으므로, 상태를 다음과 같이 표현할 수 있습니다.
\[
\vert - \rangle \otimes \frac{1}{2^n}
\sum_{x \in \Sigma^n} \sum_{y \in \Sigma^n} (-1)^{s\cdot x + x \cdot y} \vert y \rangle.
\]

$s\cdot x$와 $x\cdot y$는 이진 값이므로, 덧셈을 배타적 논리합으로 대체할 수 있습니다 — 다시 말해 $-1$의 지수에 있는 정수에게 중요한 것은 짝수인지 홀수인지 뿐이기 때문입니다. 이진 내적의 대칭성을 활용하여, 우리는 상태에 대한 다음 표현을 얻습니다:
\[
\vert - \rangle \otimes \frac{1}{2^n}
\sum_{x \in \Sigma^n} \sum_{y \in \Sigma^n} (-1)^{(s\cdot x) \oplus (y \cdot x)} \vert y \rangle.
\]

(명확성을 위해 괄호가 추가되었지만, 이진 내적이 배타적 논리합보다 우선순위가 높다고 간주하는 것이 일반적이므로 실제로는 필요하지 않습니다.)

이 시점에서 우리는 다음 공식을 활용할 것입니다.
\[
(s\cdot x) \oplus (y \cdot x) = (s \oplus y) \cdot x
\]

이 공식은 비트에 대한 유사한 공식,
\[
(a c) \oplus (b c) = (a \oplus b) c,
\]

이진 내적과 비트별 배타적 논리합의 확장을 통해 얻을 수 있습니다:
<br>
$$
\begin{aligned}
(s\cdot x) \oplus (y \cdot x)
& = (s_{n-1} x_{n-1}) \oplus \cdots \oplus (s_{0} x_{0}) \oplus
(y_{n-1} x_{n-1})  \oplus \cdots \oplus (y_{0} x_{0}) \\
& = (s_{n-1} \oplus y_{n-1}) x_{n-1}  \oplus \cdots \oplus (s_{0} \oplus y_{0}) x_{0} \\
& = (s \oplus y) \cdot x
\end{aligned}
$$

이는 측정 직전 회로의 상태를 다음과 같이 표현할 수 있게 합니다:
\[
\vert - \rangle \otimes \frac{1}{2^n}
\sum_{x \in \Sigma^n} \sum_{y \in \Sigma^n} (-1)^{(s\oplus y)\cdot x} \vert y \rangle.
\]

마지막 단계는 모든 이진 문자열 $z = z_{n-1}\cdots z_0$에 대해 작동하는 또 다른 공식을 활용하는 것입니다.
\[
\frac{1}{2^n}
\sum_{x \in \Sigma^n} (-1)^{z \cdot x}
= \begin{cases}
1 & \text{if $z = 0^n$}\\
0 & \text{if $z\neq 0^n$}
\end{cases}
\]

여기서 우리는 이 수업에서 여러 번 더 사용할 문자열에 대한 간단한 표기법을 사용하고 있습니다: $0^n$은 길이 $n$의 모든 비트가 $0$인 문자열입니다. 이 공식이 작동하는 이유를 간단히 설명하는 방법은 두 가지 경우를 별도로 고려하는 것입니다. 만약 $z = 0^n$이라면, 모든 문자열 $x\in\Sigma^n$에 대해 $z\cdot x = 0$이므로, 합의 각 항의 값은 $1$이며, 합산 후 $2^n$으로 나누면 $1$을 얻습니다.

다른 한편으로, $z$의 비트 중 어느 하나라도 $1$과 같다면, 이진 내적 $z\cdot x$는 $x\in\Sigma^n$에 대한 가능한 선택의 정확히 절반에 대해 $0$과 같고 나머지 절반에 대해 $1$과 같습니다 — 이는 $z$가 $1$을 가지는 위치에서 $x$의 어떤 비트를 뒤집으면 이진 내적 $z\cdot x$의 값이 뒤집히기(0에서 1로 또는 1에서 0으로) 때문입니다. 

이제 이 공식을 적용하여 측정 전 회로의 상태를 단순화하면, 다음을 얻습니다.
\[
\vert - \rangle \otimes \frac{1}{2^n}
\sum_{x \in \Sigma^n} \sum_{y \in \Sigma^n} (-1)^{(s\oplus y)\cdot x} \vert y \rangle
= \vert - \rangle \otimes \vert s \rangle,
\]

이는 $s\oplus y = 0^n$이 $y = s$인 경우에만 성립한다는 사실 때문입니다. 따라서, 측정은 우리가 찾고 있는 문자열 $s$를 정확히 드러냅니다.

### 2.2 **고전적 난이도**

도이치-조사 회로가 단 한 번의 질의로 베른슈타인-바지라니 문제를 해결하는 반면, 어떤 고전적인 질의 알고리즘이라도 이 문제를 해결하려면 적어도 $n$번의 질의를 해야 합니다. 이는 이 경우 매우 간단한 소위 *정보 이론적* 논증을 통해 설명될 수 있습니다.

각 고전적 질의는 해에 대한 단일 비트 정보를 드러내며, 드러내야 할 정보는 $n$비트이므로 — 적어도 $n$번의 질의가 필요합니다. 실제로, 베른슈타인-바지라니 문제는 각 가능한 위치에 하나의 $1$만 있고 나머지 비트는 $0$인 $n$개의 문자열 각각에 대해 함수를 질의함으로써 고전적으로 해결할 수 있으며, 이는 $s$의 비트들을 한 번에 하나씩 드러냅니다. 따라서, 이 문제에 대한 양자 알고리즘의 고전 알고리즘 대비 이점은 1회 질의 대 $n$회 질의입니다.

### 2.3 **명명법에 대한 주석**

베른슈타인-바지라니 문제의 맥락에서, 도이치-조사 알고리즘이 "베른슈타인-바지라니 알고리즘"으로 불리는 것이 일반적입니다. 이는 약간 오해의 소지가 있는데, 왜냐하면 그 알고리즘은 *도이치-조사 알고리즘*이기 때문이며, 베른슈타인과 바지라니는 그들의 작업에서 이 점을 매우 명확히 했습니다. 베른슈타인과 바지라니가 (위에 명시된 대로) 도이치-조사 알고리즘이 베른슈타인-바지라니 문제를 해결한다는 것을 보인 후에 한 일은 *재귀적 푸리에 샘플링 문제*로 알려진 훨씬 더 복잡한 문제를 정의하는 것이었습니다.

이는 문제의 다른 인스턴스에 대한 해가 트리와 같은 구조로 배열된 문제의 새로운 수준을 효과적으로 해제하는 매우 인위적인 문제입니다. 베른슈타인-바지라니 문제는 본질적으로 이 더 복잡한 문제의 기본 사례일 뿐입니다. 재귀적 푸리에 샘플링 문제는 양자 알고리즘이 확률론적 알고리즘에 대해 소위 **초다항식적(super-polynomial)** 이점을 가지는 질의 문제의 첫 번째 알려진 예시였으며, 이로써 도이치-조사 알고리즘이 제공하는 고전 알고리즘에 대한 양자 알고리즘의 이점을 능가했습니다.

직관적으로 말하면, 문제의 재귀 버전은 양자 알고리즘의 1 대 $n$ 이점을 훨씬 더 큰 것으로 증폭시킵니다. 이 이점을 확립하는 수학적 분석의 가장 어려운 측면은 고전적 질의 알고리즘이 많은 질의를 하지 않고는 문제를 해결할 수 없다는 것을 보여주는 것입니다. 이는 상당히 일반적입니다; 많은 문제에 대해 효율적으로 해결하는 창의적인 고전적 접근 방식을 배제하는 것은 매우 어려울 수 있습니다. 사이먼 문제와 다음 섹션에서 설명하는 해당 알고리즘은 고전 알고리즘에 대한 양자 알고리즘의 초다항식적(그리고 실제로는 지수적) 이점의 훨씬 더 간단한 예를 제공하며, 이러한 이유로 재귀적 푸리에 샘플링 문제는 덜 자주 논의됩니다. 그럼에도 불구하고, 이는 그 자체로 흥미로운 계산 문제입니다.